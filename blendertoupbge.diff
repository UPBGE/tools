diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8b64f7b..f1c6f52 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -234,12 +234,19 @@ option(WITH_BULLET        "Enable Bullet (Physics Engine)" ON)
 option(WITH_SYSTEM_BULLET "Use the systems bullet library (currently unsupported due to missing features in upstream!)" )
 mark_as_advanced(WITH_SYSTEM_BULLET)
 option(WITH_GAMEENGINE    "Enable Game Engine" ${_init_GAMEENGINE})
+
+option(WITH_GAMEENGINE_SECURITY "Disable game engine python debugging tools" OFF)
+mark_as_advanced(WITH_GAMEENGINE_SECURITY)
+
+option(WITH_GAMEENGINE_GPU_SYNC "Enable GPU synchronization for VideoTexture module image rendering (ImageRender)" OFF)
+mark_as_advanced(WITH_GAMEENGINE_GPU_SYNC)
+
 if(APPLE)
 	set(WITH_GAMEENGINE_DECKLINK OFF)
 else()
 	option(WITH_GAMEENGINE_DECKLINK "Support BlackMagicDesign DeckLink cards in the Game Engine" ON)
 endif()
-option(WITH_PLAYER        "Build Player" OFF)
+option(WITH_PLAYER        "Build Player" ON)
 option(WITH_OPENCOLORIO   "Enable OpenColorIO color management" ${_init_OPENCOLORIO})
 
 # Compositor
@@ -282,6 +289,7 @@ endif()
 
 if(WITH_X11)
 	option(WITH_X11_XINPUT    "Enable X11 Xinput (tablet support and unicode input)"  ON)
+	option(WITH_X11_XINERAMA  "Enable multi-monitor support"                          ON)
 	option(WITH_X11_XF86VMODE "Enable X11 video mode switching"                       ON)
 	option(WITH_X11_ALPHA     "Enable X11 transparent background"                     ON)
 endif()
@@ -688,9 +696,6 @@ if(NOT WITH_AUDASPACE)
 	if(WITH_JACK)
 		message(FATAL_ERROR "WITH_JACK requires WITH_AUDASPACE")
 	endif()
-	if(WITH_GAMEENGINE)
-		message(FATAL_ERROR "WITH_GAMEENGINE requires WITH_AUDASPACE")
-	endif()
 endif()
 
 if(NOT WITH_SDL AND WITH_GHOST_SDL)
@@ -780,6 +785,7 @@ endif()
 if(WITH_GHOST_SDL OR WITH_HEADLESS)
 	set(WITH_X11           OFF)
 	set(WITH_X11_XINPUT    OFF)
+	set(WITH_X11_XINERAMA  OFF)
 	set(WITH_X11_XF86VMODE OFF)
 	set(WITH_X11_ALPHA     OFF)
 	set(WITH_GHOST_XDND    OFF)
@@ -910,6 +916,14 @@ if(WITH_X11)
 		endif()
 	endif()
 
+	if(WITH_X11_XINERAMA)
+		if(X11_Xinerama_LIB)
+			list(APPEND PLATFORM_LINKLIBS ${X11_Xinerama_LIB})
+		else()
+			set(WITH_X11_XINERAMA OFF)
+		endif()
+	endif()
+
 	if(WITH_X11_XF86VMODE)
 		# XXX, why dont cmake make this available?
 		find_library(X11_Xxf86vmode_LIB Xxf86vm   ${X11_LIB_SEARCH_PATH})
@@ -1727,7 +1741,9 @@ if(FIRST_RUN)
 
 	info_cfg_text("Build Options:")
 	info_cfg_option(WITH_GAMEENGINE)
+	info_cfg_option(WITH_GAMEENGINE_SECURITY)
 	info_cfg_option(WITH_PLAYER)
+	info_cfg_option(WITH_GAMEENGINE_GPU_SYNC)
 	info_cfg_option(WITH_BULLET)
 	info_cfg_option(WITH_IK_SOLVER)
 	info_cfg_option(WITH_IK_ITASC)
@@ -1751,6 +1767,7 @@ if(FIRST_RUN)
 	info_cfg_option(WITH_X11_ALPHA)
 	info_cfg_option(WITH_X11_XF86VMODE)
 	info_cfg_option(WITH_X11_XINPUT)
+	info_cfg_option(WITH_X11_XINERAMA)
 	info_cfg_option(WITH_MEM_JEMALLOC)
 	info_cfg_option(WITH_MEM_VALGRIND)
 	info_cfg_option(WITH_SYSTEM_GLEW)
diff --git a/build_files/cmake/macros.cmake b/build_files/cmake/macros.cmake
index 2e3a190..57823db 100644
--- a/build_files/cmake/macros.cmake
+++ b/build_files/cmake/macros.cmake
@@ -627,6 +627,8 @@ function(SETUP_BLENDER_SORTED_LIBS)
 		bf_intern_ctr
 		bf_intern_utfconv
 		ge_blen_routines
+		ge_launcher
+		ge_blen_routines
 		ge_converter
 		ge_phys_dummy
 		ge_phys_bullet
@@ -636,13 +638,13 @@ function(SETUP_BLENDER_SORTED_LIBS)
 		ge_logic_ketsji
 		extern_recastnavigation
 		ge_logic
-		ge_rasterizer
+		ge_device
 		ge_oglrasterizer
+		ge_rasterizer
+		ge_common
 		ge_logic_expressions
 		ge_scenegraph
 		ge_logic_network
-		ge_logic_ngnetwork
-		ge_logic_loopbacknetwork
 		bf_intern_moto
 		extern_openjpeg
 		ge_videotex
@@ -735,7 +737,7 @@ function(SETUP_BLENDER_SORTED_LIBS)
 	endif()
 
 	if(WITH_BULLET AND NOT WITH_SYSTEM_BULLET)
-		list_insert_after(BLENDER_SORTED_LIBS "ge_logic_ngnetwork" "extern_bullet")
+		list(APPEND BLENDER_SORTED_LIBS extern_bullet)
 	endif()
 
 	if(WITH_GAMEENGINE_DECKLINK)
diff --git a/intern/ghost/CMakeLists.txt b/intern/ghost/CMakeLists.txt
index e549a48..16d6183 100644
--- a/intern/ghost/CMakeLists.txt
+++ b/intern/ghost/CMakeLists.txt
@@ -246,6 +246,13 @@ elseif(WITH_X11)
 		)
 	endif()
 
+	if(WITH_X11_XINERAMA)
+		add_definitions(-DWITH_X11_XINERAMA)
+		list(APPEND INC_SYS
+			${X11_Xinerama_INCLUDE_PATH}
+		)
+	endif()
+
 	add_definitions(-DWITH_X11)
 
 elseif(WIN32)
diff --git a/intern/ghost/intern/GHOST_SystemX11.cpp b/intern/ghost/intern/GHOST_SystemX11.cpp
index 30cfac0..31b3361 100644
--- a/intern/ghost/intern/GHOST_SystemX11.cpp
+++ b/intern/ghost/intern/GHOST_SystemX11.cpp
@@ -55,6 +55,10 @@
 #  include "GHOST_DropTargetX11.h"
 #endif
 
+#ifdef WITH_X11_XINERAMA
+#  include "X11/extensions/Xinerama.h"
+#endif
+
 #include "GHOST_Debug.h"
 
 #ifdef WITH_XF86KEYSYM
@@ -283,9 +287,47 @@ getMainDisplayDimensions(
 		GHOST_TUns32& height) const
 {
 	if (m_display) {
-		/* note, for this to work as documented,
-		 * we would need to use Xinerama check r54370 for code that did this,
-		 * we've since removed since its not worth the extra dep - campbell */
+
+#ifdef WITH_X11_XINERAMA
+		GHOST_TInt32 m_x = 1, m_y = 1;
+		getCursorPosition(m_x, m_y);
+
+		/* NOTE, no way to select a primary monitor, uses the first */
+		bool success = false;
+		int dummy1, dummy2;
+		if (XineramaQueryExtension(m_display, &dummy1, &dummy2)) {
+			if (XineramaIsActive(m_display)) {
+				int heads = 0;
+				XineramaScreenInfo *p = XineramaQueryScreens(m_display, &heads);
+				/* with a single head, all dimensions is fine */
+				if (heads > 1) {
+					int i;
+					for (i = 0; i < heads; i++) {
+						if ((m_x >= p[i].x_org) && (m_x <= p[i].x_org + p[i].width) &&
+						    (m_y >= p[i].y_org) && (m_y <= p[i].y_org + p[i].height))
+						{
+							width = p[i].width;
+							height = p[i].height;
+							break;
+						}
+					}
+					/* highly unlikely! */
+					if (i == heads) {
+						width = p[0].width;
+						height = p[0].height;
+					}
+					success = true;
+				}
+				XFree(p);
+			}
+		}
+
+		if (success) {
+			return;
+		}
+#endif
+
+		/* fallback to all */
 		getAllDisplayDimensions(width, height);
 	}
 }
diff --git a/intern/string/STR_String.h b/intern/string/STR_String.h
index 4607db4..2053163 100644
--- a/intern/string/STR_String.h
+++ b/intern/string/STR_String.h
@@ -46,6 +46,7 @@
 #endif
 
 #include <vector>
+#include <string> // Compatibility
 #include <limits.h>
 
 #include <cstring>
@@ -81,6 +82,7 @@ public:
 	STR_String(const STR_String &str);
 	STR_String(const STR_String & str, int len);
 	STR_String(const char *src1, int src1_len, const char *src2, int src2_len);
+	STR_String(const std::string& s); // Compatibility
 	explicit STR_String(int val);
 	explicit STR_String(dword val);
 	explicit STR_String(float val);
diff --git a/intern/string/intern/STR_String.cpp b/intern/string/intern/STR_String.cpp
index 4612c91..9e936fb 100644
--- a/intern/string/intern/STR_String.cpp
+++ b/intern/string/intern/STR_String.cpp
@@ -175,7 +175,15 @@ STR_String::STR_String(const char *src1, int len1, const char *src2, int len2) :
 	this->m_data[len1 + len2] = 0;
 }
 
-
+STR_String::STR_String(const std::string& s) :
+	m_data(new char[s.size() + 8]),
+	m_len(s.size()),
+	m_max(s.size() + 8)
+{
+	assertd(this->m_data != NULL);
+	memcpy(this->m_data, s.c_str(), s.size());
+	this->m_data[s.size()] = 0;
+}
 
 //
 // Create a string with an integer value
diff --git a/intern/termcolor/LICENSE b/intern/termcolor/LICENSE
new file mode 100644
index 0000000..0905ac6
--- /dev/null
+++ b/intern/termcolor/LICENSE
@@ -0,0 +1,31 @@
+Copyright (c) 2013 by Igor Kalnitsky.
+All rights reserved.
+
+Redistribution and use in source and binary forms of the software as well
+as documentation, with or without modification, are permitted provided
+that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above
+  copyright notice, this list of conditions and the following
+  disclaimer in the documentation and/or other materials provided
+  with the distribution.
+
+* The names of the contributors may not be used to endorse or
+  promote products derived from this software without specific
+  prior written permission.
+
+THIS SOFTWARE AND DOCUMENTATION IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
+NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE AND DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGE.
diff --git a/intern/termcolor/README b/intern/termcolor/README
new file mode 100644
index 0000000..b042d13
--- /dev/null
+++ b/intern/termcolor/README
@@ -0,0 +1,42 @@
+                          //  termcolor  //
+
+               a library for printing colored messages
+
+                          by Igor Kalnitsky
+
+
+    ~ What is termcolor?
+
+      Termcolor is a header-only C++ library for printing colored
+      messages to the terminal. Written just for fun with a help of
+      the Force.
+
+      And yeah, it's BSD licensed so you are free to do whatever you
+      want as long as copyright sticks around!
+
+
+    ~ How to use?
+
+      Add `termcolor.hpp` to the project and use provided stream
+      manimulators from the `termcolor` namespace.
+
+      For example:
+
+          std::cout << termcolor::red << termcolor::on_blue
+                    << "Red text on blue background!"
+                    << termcolor::reset << std::endl;
+
+      Please, don't forgot to reset termcolor's settings on the stream!
+
+
+    ~ What terminals are supported?
+
+      Termcolor supports ANSI color formatting. This formatting is
+      supported by most popular terminals on Linux, Unix and Mac OS.
+      On Windows, WinAPI is used instead, however, some limitations
+      are applied. Check the docs for details!
+
+
+    ~ Where the docs?
+
+      https://termcolor.readthedocs.io/
diff --git a/intern/termcolor/termcolor.hpp b/intern/termcolor/termcolor.hpp
new file mode 100644
index 0000000..1ff0e63
--- /dev/null
+++ b/intern/termcolor/termcolor.hpp
@@ -0,0 +1,518 @@
+//!
+//! termcolor
+//! ~~~~~~~~~
+//!
+//! termcolor is a header-only c++ library for printing colored messages
+//! to the terminal. Written just for fun with a help of the Force.
+//!
+//! :copyright: (c) 2013 by Igor Kalnitsky
+//! :license: BSD, see LICENSE for details
+//!
+
+#ifndef TERMCOLOR_HPP_
+#define TERMCOLOR_HPP_
+
+// the following snippet of code detects the current OS and
+// defines the appropriate macro that is used to wrap some
+// platform specific things
+#if defined(_WIN32) || defined(_WIN64)
+#   define TERMCOLOR_OS_WINDOWS
+#elif defined(__APPLE__)
+#   define TERMCOLOR_OS_MACOS
+#elif defined(__unix__) || defined(__unix)
+#   define TERMCOLOR_OS_LINUX
+#else
+#   error unsupported platform
+#endif
+
+
+// This headers provides the `isatty()`/`fileno()` functions,
+// which are used for testing whether a standart stream refers
+// to the terminal. As for Windows, we also need WinApi funcs
+// for changing colors attributes of the terminal.
+#if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+#   include <unistd.h>
+#elif defined(TERMCOLOR_OS_WINDOWS)
+#   include <io.h>
+#   include <windows.h>
+#endif
+
+
+#include <iostream>
+#include <cstdio>
+
+
+
+namespace termcolor
+{
+    // Forward declaration of the `_internal` namespace.
+    // All comments are below.
+    namespace _internal
+    {
+        inline FILE* get_standard_stream(const std::ostream& stream);
+        inline bool is_atty(const std::ostream& stream);
+
+    #if defined(TERMCOLOR_OS_WINDOWS)
+        inline void win_change_attributes(std::ostream& stream, int foreground, int background=-1);
+    #endif
+    }
+
+
+    inline
+    std::ostream& reset(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[00m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream, -1, -1);
+        #endif
+        }
+        return stream;
+    }
+
+
+    inline
+    std::ostream& bold(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[1m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+        #endif
+        }
+        return stream;
+    }
+
+
+    inline
+    std::ostream& dark(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[2m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+        #endif
+        }
+        return stream;
+    }
+
+
+    inline
+    std::ostream& underline(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[4m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+        #endif
+        }
+        return stream;
+    }
+
+
+    inline
+    std::ostream& blink(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[5m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+        #endif
+        }
+        return stream;
+    }
+
+
+    inline
+    std::ostream& reverse(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[7m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+        #endif
+        }
+        return stream;
+    }
+
+
+    inline
+    std::ostream& concealed(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[8m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+        #endif
+        }
+        return stream;
+    }
+
+
+    inline
+    std::ostream& grey(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[30m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream,
+                0   // grey (black)
+            );
+        #endif
+        }
+        return stream;
+    }
+
+    inline
+    std::ostream& red(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[31m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream,
+                FOREGROUND_RED
+            );
+        #endif
+        }
+        return stream;
+    }
+
+    inline
+    std::ostream& green(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[32m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream,
+                FOREGROUND_GREEN
+            );
+        #endif
+        }
+        return stream;
+    }
+
+    inline
+    std::ostream& yellow(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[33m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream,
+                FOREGROUND_GREEN | FOREGROUND_RED
+            );
+        #endif
+        }
+        return stream;
+    }
+
+    inline
+    std::ostream& blue(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[34m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream,
+                FOREGROUND_BLUE
+            );
+        #endif
+        }
+        return stream;
+    }
+
+    inline
+    std::ostream& magenta(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[35m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream,
+                FOREGROUND_BLUE | FOREGROUND_RED
+            );
+        #endif
+        }
+        return stream;
+    }
+
+    inline
+    std::ostream& cyan(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[36m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream,
+                FOREGROUND_BLUE | FOREGROUND_GREEN
+            );
+        #endif
+        }
+        return stream;
+    }
+
+    inline
+    std::ostream& white(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[37m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream,
+                FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED
+            );
+        #endif
+        }
+        return stream;
+    }
+
+
+
+    inline
+    std::ostream& on_grey(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[40m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream, -1,
+                0   // grey (black)
+            );
+        #endif
+        }
+        return stream;
+    }
+
+    inline
+    std::ostream& on_red(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[41m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream, -1,
+                BACKGROUND_RED
+            );
+        #endif
+        }
+        return stream;
+    }
+
+    inline
+    std::ostream& on_green(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[42m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream, -1,
+                BACKGROUND_GREEN
+            );
+        #endif
+        }
+        return stream;
+    }
+
+    inline
+    std::ostream& on_yellow(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[43m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream, -1,
+                BACKGROUND_GREEN | BACKGROUND_RED
+            );
+        #endif
+        }
+        return stream;
+    }
+
+    inline
+    std::ostream& on_blue(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[44m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream, -1,
+                BACKGROUND_BLUE
+            );
+        #endif
+        }
+        return stream;
+    }
+
+    inline
+    std::ostream& on_magenta(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[45m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream, -1,
+                BACKGROUND_BLUE | BACKGROUND_RED
+            );
+        #endif
+        }
+        return stream;
+    }
+
+    inline
+    std::ostream& on_cyan(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[46m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream, -1,
+                BACKGROUND_GREEN | BACKGROUND_BLUE
+            );
+        #endif
+        }
+        return stream;
+    }
+
+    inline
+    std::ostream& on_white(std::ostream& stream)
+    {
+        if (_internal::is_atty(stream))
+        {
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            stream << "\033[47m";
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            _internal::win_change_attributes(stream, -1,
+                BACKGROUND_GREEN | BACKGROUND_BLUE | BACKGROUND_RED
+            );
+        #endif
+        }
+
+        return stream;
+    }
+
+
+
+    //! Since C++ hasn't a way to hide something in the header from
+    //! the outer access, I have to introduce this namespace which
+    //! is used for internal purpose and should't be access from
+    //! the user code.
+    namespace _internal
+    {
+        //! Since C++ hasn't a true way to extract stream handler
+        //! from the a given `std::ostream` object, I have to write
+        //! this kind of hack.
+        inline
+        FILE* get_standard_stream(const std::ostream& stream)
+        {
+            if (&stream == &std::cout)
+                return stdout;
+            else if ((&stream == &std::cerr) || (&stream == &std::clog))
+                return stderr;
+
+            return 0;
+        }
+
+
+        //! Test whether a given `std::ostream` object refers to
+        //! a terminal.
+        inline
+        bool is_atty(const std::ostream& stream)
+        {
+            FILE* std_stream = get_standard_stream(stream);
+
+        #if defined(TERMCOLOR_OS_MACOS) || defined(TERMCOLOR_OS_LINUX)
+            return ::isatty(fileno(std_stream));
+        #elif defined(TERMCOLOR_OS_WINDOWS)
+            return ::_isatty(_fileno(std_stream));
+        #endif
+        }
+
+
+    #if defined(TERMCOLOR_OS_WINDOWS)
+        //! Change Windows Terminal colors attribute. If some
+        //! parameter is `-1` then attribute won't changed.
+        inline void win_change_attributes(std::ostream& stream, int foreground, int background)
+        {
+            // yeah, i know.. it's ugly, it's windows.
+            static WORD defaultAttributes = 0;
+
+            // get terminal handle
+            HANDLE hTerminal = INVALID_HANDLE_VALUE;
+            if (&stream == &std::cout)
+                hTerminal = GetStdHandle(STD_OUTPUT_HANDLE);
+            else if (&stream == &std::cerr)
+                hTerminal = GetStdHandle(STD_ERROR_HANDLE);
+
+            // save default terminal attributes if it unsaved
+            if (!defaultAttributes)
+            {
+                CONSOLE_SCREEN_BUFFER_INFO info;
+                if (!GetConsoleScreenBufferInfo(hTerminal, &info))
+                    return;
+                defaultAttributes = info.wAttributes;
+            }
+
+            // restore all default settings
+            if (foreground == -1 && background == -1)
+            {
+                SetConsoleTextAttribute(hTerminal, defaultAttributes);
+                return;
+            }
+
+            // get current settings
+            CONSOLE_SCREEN_BUFFER_INFO info;
+            if (!GetConsoleScreenBufferInfo(hTerminal, &info))
+                return;
+
+            if (foreground != -1)
+            {
+                info.wAttributes &= ~(info.wAttributes & 0x0F);
+                info.wAttributes |= static_cast<WORD>(foreground);
+            }
+
+            if (background != -1)
+            {
+                info.wAttributes &= ~(info.wAttributes & 0xF0);
+                info.wAttributes |= static_cast<WORD>(background);
+            }
+
+            SetConsoleTextAttribute(hTerminal, info.wAttributes);
+        }
+    #endif // TERMCOLOR_OS_WINDOWS
+
+    } // namespace _internal
+
+} // namespace termcolor
+
+
+#undef TERMCOLOR_OS_WINDOWS
+#undef TERMCOLOR_OS_MACOS
+#undef TERMCOLOR_OS_LINUX
+
+#endif // TERMCOLOR_HPP_
diff --git a/release/scripts/bge/interpreter.py b/release/scripts/bge/interpreter.py
new file mode 100644
index 0000000..8f2031b
--- /dev/null
+++ b/release/scripts/bge/interpreter.py
@@ -0,0 +1,25 @@
+import sys
+import os
+import bge
+import code
+
+# Check if a console exits.
+if os.isatty(sys.stdin.fileno()):
+	try:
+		import readline
+	except ImportError:
+		print("Can not enable autocompletion, readline module is missing")
+	else:
+		import rlcompleter
+		# Autocompletion with tab.
+		readline.parse_and_bind("tab: complete")
+
+	if sys.platform.startswith("win"):
+		print("Python interpreter started. Press Ctrl+C or Ctrl+Z+Enter to quit.")
+	elif sys.platform.startswith("linux"):
+		print("Python interpreter started. Press Ctrl+D to quit.")
+	else:
+		print("Python interpreter started.") #TODO: find OSX shortcut.
+
+	# Launch interactive console with current locals.
+	code.interact(local=locals())
diff --git a/release/scripts/startup/bl_ui/properties_data_camera.py b/release/scripts/startup/bl_ui/properties_data_camera.py
index c6fa77a..1f5bf2e 100644
--- a/release/scripts/startup/bl_ui/properties_data_camera.py
+++ b/release/scripts/startup/bl_ui/properties_data_camera.py
@@ -258,6 +258,8 @@ class DATA_PT_camera_display(CameraButtonsPanel, Panel):
 
         col = split.column()
         col.prop(cam, "show_limits", text="Limits")
+        if context.scene.render.engine == 'BLENDER_GAME':
+            col.prop(cam, "show_frustum", text="Frustum")
         col.prop(cam, "show_mist", text="Mist")
 
         col.prop(cam, "show_sensor", text="Sensor")
diff --git a/release/scripts/startup/bl_ui/properties_game.py b/release/scripts/startup/bl_ui/properties_game.py
index 98b7a76..87e4465 100644
--- a/release/scripts/startup/bl_ui/properties_game.py
+++ b/release/scripts/startup/bl_ui/properties_game.py
@@ -26,7 +26,6 @@ class PhysicsButtonsPanel:
     bl_region_type = 'WINDOW'
     bl_context = "physics"
 
-
 class PHYSICS_PT_game_physics(PhysicsButtonsPanel, Panel):
     bl_label = "Physics"
     COMPAT_ENGINES = {'BLENDER_GAME'}
@@ -66,7 +65,7 @@ class PHYSICS_PT_game_physics(PhysicsButtonsPanel, Panel):
             col.prop(ob, "hide_render", text="Invisible")  # out of place but useful
 
             col = split.column()
-            col.prop(game, "use_material_physics_fh")
+            col.prop(game, "use_physics_fh")
             col.prop(game, "use_rotate_from_normal")
             col.prop(game, "use_sleep")
 
@@ -79,8 +78,19 @@ class PHYSICS_PT_game_physics(PhysicsButtonsPanel, Panel):
             col.prop(game, "mass")
             col.prop(game, "radius")
             col.prop(game, "form_factor")
+            col.prop(game, "elasticity", slider=True)
+
+            col.label(text="Linear velocity:")
+            sub = col.column(align=True)
+            sub.prop(game, "velocity_min", text="Minimum")
+            sub.prop(game, "velocity_max", text="Maximum")
 
             col = split.column()
+            col.label(text="Friction:")
+            col.prop(game, "friction")
+            col.prop(game, "rolling_friction")
+            col.separator()
+
             sub = col.column()
             sub.prop(game, "use_anisotropic_friction")
             subsub = sub.column()
@@ -88,12 +98,7 @@ class PHYSICS_PT_game_physics(PhysicsButtonsPanel, Panel):
             subsub.prop(game, "friction_coefficients", text="", slider=True)
 
             split = layout.split()
-
             col = split.column()
-            col.label(text="Linear velocity:")
-            sub = col.column(align=True)
-            sub.prop(game, "velocity_min", text="Minimum")
-            sub.prop(game, "velocity_max", text="Maximum")
             col.label(text="Angular velocity:")
             sub = col.column(align=True)
             sub.prop(game, "angular_velocity_min", text="Minimum")
@@ -107,20 +112,22 @@ class PHYSICS_PT_game_physics(PhysicsButtonsPanel, Panel):
 
             layout.separator()
 
-            split = layout.split()
+            col = layout.column()
 
-            col = split.column()
             col.label(text="Lock Translation:")
-            col.prop(game, "lock_location_x", text="X")
-            col.prop(game, "lock_location_y", text="Y")
-            col.prop(game, "lock_location_z", text="Z")
+            row = col.row()
+            row.prop(game, "lock_location_x", text="X")
+            row.prop(game, "lock_location_y", text="Y")
+            row.prop(game, "lock_location_z", text="Z")
 
         if physics_type == 'RIGID_BODY':
-            col = split.column()
+            col = layout.column()
+
             col.label(text="Lock Rotation:")
-            col.prop(game, "lock_rotation_x", text="X")
-            col.prop(game, "lock_rotation_y", text="Y")
-            col.prop(game, "lock_rotation_z", text="Z")
+            row = col.row()
+            row.prop(game, "lock_rotation_x", text="X")
+            row.prop(game, "lock_rotation_y", text="Y")
+            row.prop(game, "lock_rotation_z", text="Z")
 
         elif physics_type == 'SOFT_BODY':
             col = layout.column()
@@ -162,7 +169,6 @@ class PHYSICS_PT_game_physics(PhysicsButtonsPanel, Panel):
             col = layout.column()
             col.prop(game, "use_actor")
             col.prop(game, "use_ghost")
-            col.prop(game, "use_record_animation")
             col.prop(ob, "hide_render", text="Invisible")
 
             layout.separator()
@@ -172,6 +178,9 @@ class PHYSICS_PT_game_physics(PhysicsButtonsPanel, Panel):
             col = split.column()
             col.label(text="Attributes:")
             col.prop(game, "radius")
+            col.label(text="Friction:")
+            col.prop(game, "friction")
+            col.prop(game, "rolling_friction")
 
             col = split.column()
             sub = col.column()
@@ -197,6 +206,18 @@ class PHYSICS_PT_game_physics(PhysicsButtonsPanel, Panel):
             layout.operator("mesh.navmesh_reset")
             layout.operator("mesh.navmesh_clear")
 
+        if physics_type in {"STATIC", "DYNAMIC", "RIGID_BODY"}:
+            row = layout.row()
+            row.label(text="Force Field:")
+
+            row = layout.row()
+            row.prop(game, "fh_force")
+            row.prop(game, "fh_damping", slider=True)
+
+            row = layout.row()
+            row.prop(game, "fh_distance")
+            row.prop(game, "use_fh_normal")
+
 
 class PHYSICS_PT_game_collision_bounds(PhysicsButtonsPanel, Panel):
     bl_label = "Collision Bounds"
@@ -326,7 +347,6 @@ class RENDER_PT_game_player(RenderButtonsPanel, Panel):
 
         col = layout.column()
         col.label(text="Quality:")
-        col.prop(gs, "samples")
         col = layout.column(align=True)
         col.prop(gs, "depth", text="Bit Depth", slider=False)
         col.prop(gs, "frequency", text="Refresh Rate", slider=False)
@@ -350,38 +370,6 @@ class RENDER_PT_game_stereo(RenderButtonsPanel, Panel):
             layout.prop(gs, "stereo_mode")
             layout.prop(gs, "stereo_eye_separation")
 
-        # dome:
-        elif stereo_mode == 'DOME':
-            layout.prop(gs, "dome_mode", text="Dome Type")
-
-            dome_type = gs.dome_mode
-
-            split = layout.split()
-
-            if dome_type in {'FISHEYE', 'TRUNCATED_REAR', 'TRUNCATED_FRONT'}:
-                col = split.column()
-                col.prop(gs, "dome_buffer_resolution", text="Resolution", slider=True)
-                col.prop(gs, "dome_angle", slider=True)
-
-                col = split.column()
-                col.prop(gs, "dome_tessellation", text="Tessellation")
-                col.prop(gs, "dome_tilt")
-
-            elif dome_type == 'PANORAM_SPH':
-                col = split.column()
-                col.prop(gs, "dome_buffer_resolution", text="Resolution", slider=True)
-
-                col = split.column()
-                col.prop(gs, "dome_tessellation", text="Tessellation")
-
-            else:  # cube map
-                col = split.column()
-                col.prop(gs, "dome_buffer_resolution", text="Resolution", slider=True)
-
-                col = split.column()
-
-            layout.prop(gs, "dome_text")
-
 
 class RENDER_PT_game_shading(RenderButtonsPanel, Panel):
     bl_label = "Shading"
@@ -392,21 +380,17 @@ class RENDER_PT_game_shading(RenderButtonsPanel, Panel):
 
         gs = context.scene.game_settings
 
-        layout.prop(gs, "material_mode", expand=True)
-
-        if gs.material_mode == 'GLSL':
-            split = layout.split()
-
-            col = split.column()
-            col.prop(gs, "use_glsl_lights", text="Lights")
-            col.prop(gs, "use_glsl_shaders", text="Shaders")
-            col.prop(gs, "use_glsl_shadows", text="Shadows")
-            col.prop(gs, "use_glsl_environment_lighting", text="Environment Lighting")
+        split = layout.split()
 
-            col = split.column()
-            col.prop(gs, "use_glsl_ramps", text="Ramps")
-            col.prop(gs, "use_glsl_nodes", text="Nodes")
-            col.prop(gs, "use_glsl_extra_textures", text="Extra Textures")
+        col = split.column()
+        col.prop(gs, "use_glsl_lights", text="Lights")
+        col.prop(gs, "use_glsl_shaders", text="Shaders")
+        col.prop(gs, "use_glsl_shadows", text="Shadows")
+        col.prop(gs, "use_glsl_environment_lighting", text="Environment Lighting")
+        col = split.column()
+        col.prop(gs, "use_glsl_ramps", text="Ramps")
+        col.prop(gs, "use_glsl_nodes", text="Nodes")
+        col.prop(gs, "use_glsl_extra_textures", text="Extra Textures")
 
 
 class RENDER_PT_game_system(RenderButtonsPanel, Panel):
@@ -417,25 +401,21 @@ class RENDER_PT_game_system(RenderButtonsPanel, Panel):
         layout = self.layout
 
         gs = context.scene.game_settings
-        col = layout.column()
-        row = col.row()
-        col = row.column()
+        split = layout.split(percentage=0.4)
+
+        col = split.column()
         col.prop(gs, "use_frame_rate")
         col.prop(gs, "use_restrict_animation_updates")
-        col.prop(gs, "use_material_caching")
-        col = row.column()
-        col.prop(gs, "use_display_lists")
-        col.active = gs.raster_storage != 'VERTEX_BUFFER_OBJECT'
-
-        row = layout.row()
-        row.prop(gs, "vsync")
 
-        row = layout.row()
-        row.prop(gs, "raster_storage")
+        col = split.column()
+        col.prop(gs, "vsync")
+        col.prop(gs, "samples")
+        col.prop(gs, "hdr")
 
         row = layout.row()
-        row.label("Exit Key")
-        row.prop(gs, "exit_key", text="", event=True)
+        col = row.column()
+        col.label("Exit Key:")
+        col.prop(gs, "exit_key", text="", event=True)
 
 
 class RENDER_PT_game_display(RenderButtonsPanel, Panel):
@@ -453,14 +433,15 @@ class RENDER_PT_game_display(RenderButtonsPanel, Panel):
         flow.prop(gs, "show_debug_properties", text="Debug Properties")
         flow.prop(gs, "show_framerate_profile", text="Framerate and Profile")
         flow.prop(gs, "show_physics_visualization", text="Physics Visualization")
+        flow.prop(gs, "show_bounding_box", text="Bounding Box")
+        flow.prop(gs, "show_armatures", text="Debug Armatures")
         flow.prop(gs, "use_deprecation_warnings")
         flow.prop(gs, "show_mouse", text="Mouse Cursor")
 
         col = layout.column()
         col.label(text="Framing:")
         col.row().prop(gs, "frame_type", expand=True)
-        if gs.frame_type == 'LETTERBOX':
-            col.prop(gs, "frame_color", text="")
+        col.prop(gs, "frame_color", text="")
 
 
 class SceneButtonsPanel:
@@ -551,6 +532,33 @@ class SCENE_PT_game_hysteresis(SceneButtonsPanel, Panel):
         row.prop(gs, "scene_hysteresis_percentage", text="")
 
 
+class RENDER_PT_game_console(SceneButtonsPanel, Panel):
+    bl_label = "Python Console"
+    COMPAT_ENGINES = {'BLENDER_GAME'}
+
+    @classmethod
+    def poll(cls, context):
+        scene = context.scene
+        return (scene and scene.render.engine in cls.COMPAT_ENGINES)
+
+    def draw_header(self, context):
+        gs = context.scene.game_settings
+
+        self.layout.prop(gs, "use_python_console", text="")
+
+    def draw(self, context):
+        layout = self.layout
+
+        gs = context.scene.game_settings
+        row = layout.row(align=True)
+        row.active = gs.use_python_console
+        row.label("Keys:")
+        row.prop(gs, "python_console_key1", text="", event=True)
+        row.prop(gs, "python_console_key2", text="", event=True)
+        row.prop(gs, "python_console_key3", text="", event=True)
+        row.prop(gs, "python_console_key4", text="", event=True)
+
+
 class WorldButtonsPanel:
     bl_space_type = 'PROPERTIES'
     bl_region_type = 'WINDOW'
@@ -593,13 +601,26 @@ class WORLD_PT_game_world(WorldButtonsPanel, Panel):
     def draw(self, context):
         layout = self.layout
 
+        self.layout.template_preview(context.world)
+
         world = context.world
 
         row = layout.row()
+        row.prop(world, "use_sky_paper")
+        row.prop(world, "use_sky_blend")
+        row.prop(world, "use_sky_real")
+
+        row = layout.row()
         row.column().prop(world, "horizon_color")
-        row.column().prop(world, "zenith_color")
+        col = row.column()
+        col.prop(world, "zenith_color")
+        col.active = world.use_sky_blend
         row.column().prop(world, "ambient_color")
 
+        row = layout.row()
+        row.prop(world, "exposure")
+        row.prop(world, "color_range")
+
 
 class WORLD_PT_game_environment_lighting(WorldButtonsPanel, Panel):
     bl_label = "Environment Lighting"
@@ -768,6 +789,7 @@ class DATA_PT_shadow_game(DataButtonsPanel, Panel):
         col.prop(lamp, "shadow_color", text="")
         if lamp.type == 'SUN':
             col.prop(lamp, "show_shadow_box")
+        col.prop(lamp, "static_shadow")
 
         col = split.column()
         col.prop(lamp, "use_shadow_layer", text="This Layer Only")
@@ -776,11 +798,20 @@ class DATA_PT_shadow_game(DataButtonsPanel, Panel):
         col = layout.column()
         col.label("Buffer Type:")
         col.prop(lamp, "ge_shadow_buffer_type", text="", toggle=True)
+        if lamp.ge_shadow_buffer_type == "SIMPLE":
+            col.label("Filter Type:")
+            col.prop(lamp, "shadow_filter", text="", toggle=True)
+
         col.label("Quality:")
         col = layout.column(align=True)
         col.prop(lamp, "shadow_buffer_size", text="Size")
         col.prop(lamp, "shadow_buffer_bias", text="Bias")
-        col.prop(lamp, "shadow_buffer_bleed_bias", text="Bleed Bias")
+        if lamp.ge_shadow_buffer_type == "VARIANCE":
+            col.prop(lamp, "shadow_buffer_bleed_bias", text="Bleed Bias")
+            col.prop(lamp, "shadow_buffer_sharp", text="Sharpness")
+        elif lamp.shadow_filter in ("PCF", "PCF_BAIL"):
+            col.prop(lamp, "shadow_buffer_samples", text="Samples")
+            col.prop(lamp, "shadow_buffer_soft", text="Soft")
 
         row = layout.row()
         row.label("Clipping:")
@@ -809,6 +840,20 @@ class OBJECT_MT_lod_tools(Menu):
         layout.operator("object.lod_generate", text="Generate")
         layout.operator("object.lod_clear_all", text="Clear All", icon='PANEL_CLOSE')
 
+class OBJECT_MT_culling(ObjectButtonsPanel, Panel):
+    bl_label = "Culling Bounding Volume"
+    COMPAT_ENGINES = {'BLENDER_GAME'}
+
+    @classmethod
+    def poll(cls, context):
+        return context.scene.render.engine in cls.COMPAT_ENGINES
+
+    def draw(self, context):
+        layout = self.layout
+        game = context.active_object.game
+
+        layout.label(text="Predefined Bound:")
+        layout.prop(game, "predefined_bound", "")
 
 class OBJECT_PT_levels_of_detail(ObjectButtonsPanel, Panel):
     bl_label = "Levels of Detail"
diff --git a/release/scripts/startup/bl_ui/properties_material.py b/release/scripts/startup/bl_ui/properties_material.py
index d916007..c168ea3 100644
--- a/release/scripts/startup/bl_ui/properties_material.py
+++ b/release/scripts/startup/bl_ui/properties_material.py
@@ -511,7 +511,7 @@ class MATERIAL_PT_mirror(MaterialButtonsPanel, Panel):
 class MATERIAL_PT_sss(MaterialButtonsPanel, Panel):
     bl_label = "Subsurface Scattering"
     bl_options = {'DEFAULT_CLOSED'}
-    COMPAT_ENGINES = {'BLENDER_RENDER'}
+    COMPAT_ENGINES = {'BLENDER_RENDER', 'BLENDER_GAME'}
 
     @classmethod
     def poll(cls, context):
@@ -542,22 +542,26 @@ class MATERIAL_PT_sss(MaterialButtonsPanel, Panel):
 
         split = layout.split()
 
-        col = split.column()
-        col.prop(sss, "ior")
-        col.prop(sss, "scale")
-        col.prop(sss, "color", text="")
-        col.prop(sss, "radius", text="RGB Radius", expand=True)
-
-        col = split.column()
-        sub = col.column(align=True)
-        sub.label(text="Blend:")
-        sub.prop(sss, "color_factor", text="Color")
-        sub.prop(sss, "texture_factor", text="Texture")
-        sub.label(text="Scattering Weight:")
-        sub.prop(sss, "front")
-        sub.prop(sss, "back")
-        col.separator()
-        col.prop(sss, "error_threshold", text="Error")
+        if context.scene.render.engine != 'BLENDER_GAME':
+            col = split.column()
+            col.prop(sss, "ior")
+            col.prop(sss, "scale")
+            col.prop(sss, "color", text="")
+            col.prop(sss, "radius", text="RGB Radius", expand=True)
+            col = split.column()
+            sub = col.column(align=True)
+            sub.label(text="Blend:")
+            sub.prop(sss, "color_factor", text="Color")
+            sub.prop(sss, "texture_factor", text="Texture")
+            sub.label(text="Scattering Weight:")
+            sub.prop(sss, "front")
+            sub.prop(sss, "back")
+            col.separator()
+            col.prop(sss, "error_threshold", text="Error")
+        else:
+            col = split.column()
+            col.prop(sss, "scale")
+            col.prop(sss, "radius", text="RGB Radius", expand=True)
 
 
 class MATERIAL_PT_halo(MaterialButtonsPanel, Panel):
@@ -658,55 +662,28 @@ class MATERIAL_PT_game_settings(MaterialButtonsPanel, Panel):
 
     def draw(self, context):
         layout = self.layout
-        game = context.material.game_settings  # don't use node material
-
-        row = layout.row()
-        row.prop(game, "use_backface_culling")
-        row.prop(game, "invisible")
-        row.prop(game, "text")
-
-        row = layout.row()
-        row.label(text="Alpha Blend:")
-        row.label(text="Face Orientation:")
-        row = layout.row()
-        row.prop(game, "alpha_blend", text="")
-        row.prop(game, "face_orientation", text="")
-
-
-class MATERIAL_PT_physics(MaterialButtonsPanel, Panel):
-    bl_label = "Physics"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
-
-    def draw_header(self, context):
-        game = context.material.game_settings
-        self.layout.prop(game, "physics", text="")
-
-    @classmethod
-    def poll(cls, context):
-        return context.material and (context.scene.render.engine in cls.COMPAT_ENGINES)
-
-    def draw(self, context):
-        layout = self.layout
-        layout.active = context.material.game_settings.physics
-
-        phys = context.material.physics  # don't use node material
+        mat = context.material
+        game = mat.game_settings  # don't use node material
 
         split = layout.split()
-        row = split.row()
-        row.prop(phys, "friction")
-        row.prop(phys, "elasticity", slider=True)
-
-        row = layout.row()
-        row.label(text="Force Field:")
-
-        row = layout.row()
-        row.prop(phys, "fh_force")
-        row.prop(phys, "fh_damping", slider=True)
 
-        row = layout.row()
-        row.prop(phys, "fh_distance")
-        row.prop(phys, "use_fh_normal")
+        col = split.column()
+        col.prop(game, "use_backface_culling")
+        col.prop(game, "invisible")
+        col.prop(game, "physics")
+        col.label(text="Face Orientation:")
+        col.prop(game, "face_orientation", text="")
+        col.label(text="Alpha Blend:")
+        col.prop(game, "alpha_blend", text="")
 
+        col = split.column()
+        col.label(text="Constant Values:")
+        col.prop(mat, "use_constant_material")
+        col.prop(mat, "use_constant_lamp")
+        col.prop(mat, "use_constant_texture")
+        col.prop(mat, "use_constant_texture_uv")
+        col.prop(mat, "use_constant_world")
+        col.prop(mat, "use_constant_mist")
 
 class MATERIAL_PT_strand(MaterialButtonsPanel, Panel):
     bl_label = "Strand"
@@ -757,7 +734,7 @@ class MATERIAL_PT_strand(MaterialButtonsPanel, Panel):
 
 class MATERIAL_PT_options(MaterialButtonsPanel, Panel):
     bl_label = "Options"
-    COMPAT_ENGINES = {'BLENDER_RENDER', 'BLENDER_GAME'}
+    COMPAT_ENGINES = {'BLENDER_RENDER'}
 
     @classmethod
     def poll(cls, context):
@@ -805,11 +782,49 @@ class MATERIAL_PT_options(MaterialButtonsPanel, Panel):
         if simple_material(base_mat):
             col.prop(mat, "pass_index")
 
+class MATERIAL_PT_game_options(MaterialButtonsPanel, Panel):
+    bl_label = "Options"
+    COMPAT_ENGINES = {'BLENDER_GAME'}
+
+    @classmethod
+    def poll(cls, context):
+        mat = context.material
+        engine = context.scene.render.engine
+        return check_material(mat) and (mat.type in {'SURFACE', 'WIRE'}) and (engine in cls.COMPAT_ENGINES)
+
+    def draw(self, context):
+        layout = self.layout
+
+        base_mat = context.material
+        mat = active_node_mat(base_mat)
+
+        split = layout.split()
+
+        col = split.column()
+        if simple_material(base_mat):
+            col.prop(mat, "invert_z")
+            sub = col.row()
+            sub.prop(mat, "offset_z")
+            sub.active = mat.use_transparency and mat.transparency_method == 'Z_TRANSPARENCY'
+        sub = col.column(align=True)
+        sub.label(text="Light Group:")
+        sub.prop(mat, "light_group", text="")
+        row = sub.row(align=True)
+        row.active = bool(mat.light_group)
+        row.prop(mat, "use_light_group_exclusive", text="Exclusive")
+        row.prop(mat, "use_light_group_local", text="Local")
+
+        col = split.column()
+        col.prop(mat, "use_mist")
+        col.prop(mat, "use_vertex_color_paint")
+        col.prop(mat, "use_vertex_color_light")
+        col.prop(mat, "use_object_color")
+        col.prop(mat, "use_instancing")
 
 class MATERIAL_PT_shadow(MaterialButtonsPanel, Panel):
     bl_label = "Shadow"
     bl_options = {'DEFAULT_CLOSED'}
-    COMPAT_ENGINES = {'BLENDER_RENDER', 'BLENDER_GAME'}
+    COMPAT_ENGINES = {'BLENDER_RENDER'}
 
     @classmethod
     def poll(cls, context):
@@ -855,6 +870,33 @@ class MATERIAL_PT_shadow(MaterialButtonsPanel, Panel):
         if simple_material(base_mat):
             col.prop(mat, "use_cast_approximate")
 
+class MATERIAL_PT_game_shadow(MaterialButtonsPanel, Panel):
+    bl_label = "Shadow"
+    bl_options = {'DEFAULT_CLOSED'}
+    COMPAT_ENGINES = {'BLENDER_GAME'}
+
+    @classmethod
+    def poll(cls, context):
+        mat = context.material
+        engine = context.scene.render.engine
+        return check_material(mat) and (mat.type in {'SURFACE', 'WIRE'}) and (engine in cls.COMPAT_ENGINES)
+
+    def draw(self, context):
+        layout = self.layout
+
+        base_mat = context.material
+        mat = active_node_mat(base_mat)
+
+        split = layout.split()
+
+        if simple_material(base_mat):
+            col = split.column()
+
+            col.prop(mat, "use_cast_shadows", text="Cast")
+            col.prop(mat, "use_cast_shadows_only", text="Cast Only")
+
+        col = split.column()
+        col.prop(mat, "use_shadows", text="Receive")
 
 class MATERIAL_PT_transp_game(MaterialButtonsPanel, Panel):
     bl_label = "Transparency"
@@ -880,6 +922,13 @@ class MATERIAL_PT_transp_game(MaterialButtonsPanel, Panel):
 
         layout.active = mat.use_transparency
 
+        split = layout.split()
+        col = split.column()
+        col.active = mat.use_depth_transparency
+        col.prop(mat, "depth_transp_factor", text="Depth Factor")
+        col = split.column()
+        col.prop(mat, "use_depth_transparency")
+
         if simple_material(base_mat):
             row = layout.row()
             row.prop(mat, "transparency_method", expand=True)
diff --git a/release/scripts/startup/bl_ui/properties_texture.py b/release/scripts/startup/bl_ui/properties_texture.py
index caf19a9..0715dfd 100644
--- a/release/scripts/startup/bl_ui/properties_texture.py
+++ b/release/scripts/startup/bl_ui/properties_texture.py
@@ -250,7 +250,7 @@ class TEXTURE_PT_preview(TextureButtonsPanel, Panel):
 class TEXTURE_PT_colors(TextureButtonsPanel, Panel):
     bl_label = "Colors"
     bl_options = {'DEFAULT_CLOSED'}
-    COMPAT_ENGINES = {'BLENDER_RENDER', 'BLENDER_GAME'}
+    COMPAT_ENGINES = {'BLENDER_RENDER'}
 
     def draw(self, context):
         layout = self.layout
@@ -527,29 +527,24 @@ class TEXTURE_PT_image_sampling(TextureTypePanel, Panel):
         split = layout.split()
 
         col = split.column()
-        col.label(text="Alpha:")
-        col.prop(tex, "use_calculate_alpha", text="Calculate")
-        col.prop(tex, "invert_alpha", text="Invert")
-
-        col = split.column()
 
         # Only for Material based textures, not for Lamp/World...
         if slot and isinstance(idblock, Material):
             col.prop(tex, "use_normal_map")
-            row = col.row()
-            row.active = tex.use_normal_map
-            row.prop(slot, "normal_map_space", text="")
+            sub = col.column()
+            sub.active = tex.use_normal_map
+            sub.prop(slot, "normal_map_space", text="")
 
-            row = col.row()
-            row.active = not tex.use_normal_map
-            row.prop(tex, "use_derivative_map")
+            col = split.column()
+            col.active = not tex.use_normal_map
+            col.prop(tex, "use_derivative_map")
 
 
 class TEXTURE_PT_image_mapping(TextureTypePanel, Panel):
     bl_label = "Image Mapping"
     bl_options = {'DEFAULT_CLOSED'}
     tex_type = 'IMAGE'
-    COMPAT_ENGINES = {'BLENDER_RENDER', 'BLENDER_GAME'}
+    COMPAT_ENGINES = {'BLENDER_RENDER'}
 
     def draw(self, context):
         layout = self.layout
@@ -620,17 +615,24 @@ class TEXTURE_PT_envmap(TextureTypePanel, Panel):
             layout.template_ID(tex, "image", open="image.open")
             layout.template_image(tex, "image", tex.image_user, compact=True)
         else:
+            if env.source == 'REALTIME':
+                layout.template_ID(tex, "image", new="image.new", open="image.open")
+                layout.template_image(tex, "image", tex.image_user, compact=True)
             layout.prop(env, "mapping")
             if env.mapping == 'PLANE':
                 layout.prop(env, "zoom")
+
             layout.prop(env, "viewpoint_object")
 
             split = layout.split()
 
             col = split.column()
             col.prop(env, "layers_ignore")
-            col.prop(env, "resolution")
-            col.prop(env, "depth")
+            if env.source == 'REALTIME':
+                col.prop(env, "auto_update")
+            else:
+                col.prop(env, "resolution")
+                col.prop(env, "depth")
 
             col = split.column(align=True)
 
@@ -638,12 +640,16 @@ class TEXTURE_PT_envmap(TextureTypePanel, Panel):
             col.prop(env, "clip_start", text="Start")
             col.prop(env, "clip_end", text="End")
 
+            if env.source == 'REALTIME':
+                row = layout.row()
+                row.prop(env, "filtering", expand=False)
+
 
 class TEXTURE_PT_envmap_sampling(TextureTypePanel, Panel):
     bl_label = "Environment Map Sampling"
     bl_options = {'DEFAULT_CLOSED'}
     tex_type = 'ENVIRONMENT_MAP'
-    COMPAT_ENGINES = {'BLENDER_RENDER', 'BLENDER_GAME'}
+    COMPAT_ENGINES = {'BLENDER_RENDER'}
 
     def draw(self, context):
         layout = self.layout
@@ -918,9 +924,80 @@ class TEXTURE_PT_ocean(TextureTypePanel, Panel):
         col.prop(ot, "output")
 
 
+class TEXTURE_PT_game_mapping(TextureSlotPanel, Panel):
+    bl_label = "Mapping"
+    COMPAT_ENGINES = {'BLENDER_GAME'}
+
+    @classmethod
+    def poll(cls, context):
+        idblock = context_tex_datablock(context)
+        if isinstance(idblock, Brush) and not context.sculpt_object:
+            return False
+
+        if not getattr(context, "texture_slot", None):
+            return False
+
+        engine = context.scene.render.engine
+        return (engine in cls.COMPAT_ENGINES)
+
+    def draw(self, context):
+        layout = self.layout
+
+        idblock = context_tex_datablock(context)
+
+        tex = context.texture_slot
+
+        if not isinstance(idblock, Brush):
+            split = layout.split(percentage=0.3)
+            col = split.column()
+            col.label(text="Coordinates:")
+            col = split.column()
+            col.prop(tex, "texture_coords", text="")
+
+            if tex.texture_coords == 'ORCO':
+                """
+                ob = context.object
+                if ob and ob.type == 'MESH':
+                    split = layout.split(percentage=0.3)
+                    split.label(text="Mesh:")
+                    split.prop(ob.data, "texco_mesh", text="")
+                """
+            elif tex.texture_coords == 'UV':
+                split = layout.split(percentage=0.3)
+                split.label(text="Map:")
+                ob = context.object
+                if ob and ob.type == 'MESH':
+                    split.prop_search(tex, "uv_layer", ob.data, "uv_textures", text="")
+                else:
+                    split.prop(tex, "uv_layer", text="")
+
+            elif tex.texture_coords == 'OBJECT':
+                split = layout.split(percentage=0.3)
+                split.label(text="Object:")
+                split.prop(tex, "object", text="")
+
+            elif tex.texture_coords == 'ALONG_STROKE':
+                split = layout.split(percentage=0.3)
+                split.label(text="Use Tips:")
+                split.prop(tex, "use_tips", text="")
+
+        if isinstance(idblock, Brush):
+            if context.sculpt_object or context.image_paint_object:
+                brush_texture_settings(layout, idblock, context.sculpt_object)
+        else:
+            split = layout.split()
+
+            col = split.column()
+
+            row = layout.row()
+            row.column().prop(tex, "offset")
+            row.column().prop(tex, "scale")
+            row = layout.row()
+            row.prop(tex, "rotation")
+
 class TEXTURE_PT_mapping(TextureSlotPanel, Panel):
     bl_label = "Mapping"
-    COMPAT_ENGINES = {'BLENDER_RENDER', 'BLENDER_GAME'}
+    COMPAT_ENGINES = {'BLENDER_RENDER'}
 
     @classmethod
     def poll(cls, context):
@@ -1020,10 +1097,180 @@ class TEXTURE_PT_mapping(TextureSlotPanel, Panel):
             row.column().prop(tex, "offset")
             row.column().prop(tex, "scale")
 
+class TEXTURE_PT_game_parallax(TextureSlotPanel, Panel):
+    bl_label = "Parallax"
+    COMPAT_ENGINES = {'BLENDER_GAME'}
+
+    @classmethod
+    def poll(cls, context):
+        idblock = context_tex_datablock(context)
+        if isinstance(idblock, Brush) and not context.sculpt_object:
+            return False
+
+        if not getattr(context, "texture_slot", None):
+            return False
+
+        tex = context.texture_slot
+
+        engine = context.scene.render.engine
+        return (engine in cls.COMPAT_ENGINES and tex.texture_coords == 'UV')
+
+    def draw(self, context):
+        layout = self.layout
+
+        tex = context.texture_slot
+
+        split = layout.split()
+        col = split.column()
+        col.prop(tex, "use_map_parallax")
+        sub = col.column()
+        sub.active = not tex.use_map_parallax
+        sub.prop(tex, "use_parallax_uv")
+        sub = col.column()
+        sub.active = tex.use_map_parallax
+        sub.prop(tex, "parallax_uv_discard", text="Discard Edges")
+
+        col = split.column()
+        col.active = tex.use_map_parallax
+        col.prop(tex, "parallax_uv_shift", text="Height Scale")
+        col.prop(tex, "parallax_steps", text="Steps")
+        col.prop(tex, "parallax_bump_scale", text="Bump Scale")
+
+class TEXTURE_PT_game_influence(TextureSlotPanel, Panel):
+    bl_label = "Influence"
+    COMPAT_ENGINES = {'BLENDER_GAME'}
+
+    @classmethod
+    def poll(cls, context):
+        idblock = context_tex_datablock(context)
+        if isinstance(idblock, Brush):
+            return False
+
+        if not getattr(context, "texture_slot", None):
+            return False
+
+        engine = context.scene.render.engine
+        return (engine in cls.COMPAT_ENGINES)
+
+    def draw(self, context):
+
+        layout = self.layout
+
+        idblock = context_tex_datablock(context)
+
+        tex = context.texture_slot
+
+        def factor_but(layout, toggle, factor, name):
+            row = layout.row(align=True)
+            row.prop(tex, toggle, text="")
+            sub = row.row(align=True)
+            sub.active = getattr(tex, toggle)
+            sub.prop(tex, factor, text=name, slider=True)
+            return sub  # XXX, temp. use_map_normal needs to override.
+
+        if isinstance(idblock, Material):
+            split = layout.split()
+
+            col = split.column()
+            col.label(text="Diffuse:")
+            factor_but(col, "use_map_diffuse", "diffuse_factor", "Intensity")
+            factor_but(col, "use_map_color_diffuse", "diffuse_color_factor", "Color")
+            factor_but(col, "use_map_alpha", "alpha_factor", "Alpha")
+            factor_but(col, "use_map_translucency", "translucency_factor", "Translucency")
+
+            col.label(text="Specular:")
+            factor_but(col, "use_map_specular", "specular_factor", "Intensity")
+            factor_but(col, "use_map_color_spec", "specular_color_factor", "Color")
+            factor_but(col, "use_map_hardness", "hardness_factor", "Hardness")
+
+            col.label(text="Mipmapping:")
+            col.prop(tex, "lod_bias")
+
+            col = split.column()
+            col.label(text="Shading:")
+            factor_but(col, "use_map_ambient", "ambient_factor", "Ambient")
+            factor_but(col, "use_map_emit", "emit_factor", "Emit")
+            factor_but(col, "use_map_mirror", "mirror_factor", "Mirror")
+            factor_but(col, "use_map_raymir", "raymir_factor", "Ray Mirror")
+
+            col.label(text="Geometry:")
+            # XXX replace 'or' when displacement is fixed to not rely on normal influence value.
+            sub_tmp = factor_but(col, "use_map_normal", "normal_factor", "Normal")
+            sub_tmp.active = (tex.use_map_normal or tex.use_map_displacement)
+            # END XXX
+
+            sub = col.column()
+            sub.active = (tex.texture_coords == "REFLECTION")
+            sub.label(text="Refraction:")
+            sub.prop(tex, "ior", text="IOR")
+            sub.prop(tex, "refraction_ratio", text="Ratio")
+
+        elif isinstance(idblock, Lamp):
+            split = layout.split()
+
+            col = split.column()
+            factor_but(col, "use_map_color", "color_factor", "Color")
+
+            col = split.column()
+            factor_but(col, "use_map_shadow", "shadow_factor", "Shadow")
+
+            split = layout.split()
+            col = split.column()
+            col.label(text="Mipmapping:")
+            col.prop(tex, "lod_bias")
+            col = split.column()
+
+        elif isinstance(idblock, World):
+            split = layout.split()
+
+            col = split.column()
+            factor_but(col, "use_map_blend", "blend_factor", "Blend")
+            factor_but(col, "use_map_horizon", "horizon_factor", "Horizon")
+
+            col = split.column()
+            factor_but(col, "use_map_zenith_up", "zenith_up_factor", "Zenith Up")
+            factor_but(col, "use_map_zenith_down", "zenith_down_factor", "Zenith Down")
+
+            split = layout.split()
+            col = split.column()
+            col.label(text="Mipmapping:")
+            col.prop(tex, "lod_bias")
+            col = split.column()
+
+        if not isinstance(idblock, ParticleSettings):
+            split = layout.split()
+
+            col = split.column()
+            col.prop(tex, "blend_type", text="Blend")
+            col.prop(tex, "use_rgb_to_intensity")
+            # color is used on gray-scale textures even when use_rgb_to_intensity is disabled.
+            col.prop(tex, "color", text="")
+
+            col = split.column()
+            col.prop(tex, "invert", text="Negative")
+            col.prop(tex, "use_stencil")
+
+        if isinstance(idblock, Material) or isinstance(idblock, World):
+            col.prop(tex, "default_value", text="DVar", slider=True)
+
+        if isinstance(idblock, Material):
+            layout.label(text="Bump Mapping:")
+
+            # only show bump settings if activated but not for normal-map images
+            row = layout.row()
+
+            sub = row.row()
+            sub.active = (tex.use_map_normal or tex.use_map_warp) and not (tex.texture.type == 'IMAGE' and (tex.texture.use_normal_map or tex.texture.use_derivative_map))
+            sub.prop(tex, "bump_method", text="Method")
+
+            # the space setting is supported for: derivative-maps + bump-maps (DEFAULT,BEST_QUALITY), not for normal-maps
+            sub = row.row()
+            sub.active = (tex.use_map_normal or tex.use_map_warp) and not (tex.texture.type == 'IMAGE' and tex.texture.use_normal_map) and ((tex.bump_method in {'BUMP_LOW_QUALITY', 'BUMP_MEDIUM_QUALITY', 'BUMP_BEST_QUALITY'}) or (tex.texture.type == 'IMAGE' and tex.texture.use_derivative_map))
+            sub.prop(tex, "bump_objectspace", text="Space")
 
 class TEXTURE_PT_influence(TextureSlotPanel, Panel):
     bl_label = "Influence"
-    COMPAT_ENGINES = {'BLENDER_RENDER', 'BLENDER_GAME'}
+    COMPAT_ENGINES = {'BLENDER_RENDER'}
 
     @classmethod
     def poll(cls, context):
@@ -1085,6 +1332,15 @@ class TEXTURE_PT_influence(TextureSlotPanel, Panel):
                 factor_but(col, "use_map_warp", "warp_factor", "Warp")
                 factor_but(col, "use_map_displacement", "displacement_factor", "Displace")
 
+                col.label(text="Mipmapping:")
+                col.prop(tex, "lod_bias")
+
+                sub = col.column()
+                sub.active = (tex.texture_coords == "REFLECTION")
+                sub.label(text="Refraction:")
+                sub.prop(tex, "ior", text="IOR")
+                sub.prop(tex, "refraction_ratio", text="Ratio")
+
                 #~ sub = col.column()
                 #~ sub.active = tex.use_map_translucency or tex.map_emit or tex.map_alpha or tex.map_raymir or tex.map_hardness or tex.map_ambient or tex.map_specularity or tex.map_reflection or tex.map_mirror
                 #~ sub.prop(tex, "default_value", text="Amount", slider=True)
@@ -1137,6 +1393,9 @@ class TEXTURE_PT_influence(TextureSlotPanel, Panel):
             col = split.column()
             factor_but(col, "use_map_shadow", "shadow_factor", "Shadow")
 
+            col = split.column()
+            col.prop(tex, "lod_bias")
+
         elif isinstance(idblock, World):
             split = layout.split()
 
@@ -1147,6 +1406,9 @@ class TEXTURE_PT_influence(TextureSlotPanel, Panel):
             col = split.column()
             factor_but(col, "use_map_zenith_up", "zenith_up_factor", "Zenith Up")
             factor_but(col, "use_map_zenith_down", "zenith_down_factor", "Zenith Down")
+
+            col = split.column()
+            col.prop(tex, "lod_bias")
         elif isinstance(idblock, ParticleSettings):
             split = layout.split()
 
diff --git a/release/scripts/startup/bl_ui/space_info.py b/release/scripts/startup/bl_ui/space_info.py
index 780dc4c..729705c 100644
--- a/release/scripts/startup/bl_ui/space_info.py
+++ b/release/scripts/startup/bl_ui/space_info.py
@@ -230,8 +230,9 @@ class INFO_MT_game(Menu):
         layout.prop(gs, "show_debug_properties")
         layout.prop(gs, "show_framerate_profile")
         layout.prop(gs, "show_physics_visualization")
+        layout.prop(gs, "show_bounding_box")
+        layout.prop(gs, "show_armatures")
         layout.prop(gs, "use_deprecation_warnings")
-        layout.prop(gs, "use_animation_record")
         layout.separator()
         layout.prop(gs, "use_auto_start")
 
@@ -330,10 +331,7 @@ class INFO_MT_help(Menu):
                 ).url = "https://developer.blender.org/maniphest/task/edit/form/1"
         layout.separator()
 
-        layout.operator(
-                "wm.url_open", text="Python API Reference", icon='URL',
-                ).url = bpy.types.WM_OT_doc_view._prefix
-
+        layout.operator("wm.url_open", text="Python API Reference", icon='URL').url = "https://pythonapi.upbge.org/"
         layout.operator("wm.operator_cheat_sheet", icon='TEXT')
         layout.operator("wm.sysinfo", icon='TEXT')
         layout.separator()
diff --git a/release/scripts/startup/bl_ui/space_logic.py b/release/scripts/startup/bl_ui/space_logic.py
index 1b316a3..cf9ce01 100644
--- a/release/scripts/startup/bl_ui/space_logic.py
+++ b/release/scripts/startup/bl_ui/space_logic.py
@@ -20,6 +20,40 @@
 import bpy
 from bpy.types import Header, Menu, Panel
 
+class LOGIC_PT_components(bpy.types.Panel):
+    bl_space_type = 'LOGIC_EDITOR'
+    bl_region_type = 'UI'
+    bl_label = 'Components'
+
+    @classmethod
+    def poll(cls, context):
+        ob = context.active_object
+        return ob and ob.name
+
+    def draw(self, context):
+        layout = self.layout
+
+        ob = context.active_object
+        game = ob.game
+
+        st = context.space_data
+
+        row = layout.row()
+        row.operator("logic.add_python_component", text="Add Component", icon="ZOOMIN")
+
+        for i, c in enumerate(game.components):
+            box = layout.box()
+            row = box.row()
+            row.prop(c, "name", text="")
+            row.operator("logic.component_reload", text="", icon='RECOVER_LAST').index = i
+            row.operator("logic.component_remove", text="", icon='X').index = i
+
+            for prop in c.properties:
+                row = box.row()
+                row.label(text=prop.name)
+                col = row.column()
+                col.prop(prop, "value", text="")
+
 
 class LOGIC_PT_properties(Panel):
     bl_space_type = 'LOGIC_EDITOR'
diff --git a/release/scripts/startup/bl_ui/space_view3d.py b/release/scripts/startup/bl_ui/space_view3d.py
index 5e93607..a5a424a 100644
--- a/release/scripts/startup/bl_ui/space_view3d.py
+++ b/release/scripts/startup/bl_ui/space_view3d.py
@@ -3345,21 +3345,17 @@ class VIEW3D_PT_view3d_shading(Panel):
 
         view = context.space_data
         scene = context.scene
-        gs = scene.game_settings
         obj = context.object
 
         col = layout.column()
 
-        if not scene.render.use_shading_nodes:
-            col.prop(gs, "material_mode", text="")
-
         if view.viewport_shade == 'SOLID':
             col.prop(view, "show_textured_solid")
             col.prop(view, "use_matcap")
             if view.use_matcap:
                 col.template_icon_view(view, "matcap_icon")
         if view.viewport_shade == 'TEXTURED' or context.mode == 'PAINT_TEXTURE':
-            if scene.render.use_shading_nodes or gs.material_mode != 'GLSL':
+            if scene.render.use_shading_nodes:
                 col.prop(view, "show_textured_shadeless")
 
         col.prop(view, "show_backface_culling")
diff --git a/source/blender/blenkernel/BKE_python_component.h b/source/blender/blenkernel/BKE_python_component.h
new file mode 100644
index 0000000..9ad95d4
--- /dev/null
+++ b/source/blender/blenkernel/BKE_python_component.h
@@ -0,0 +1,42 @@
+/**
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contributor(s): Mitchell Stokes, Diego Lopes, Tristan Porteries.
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef __BKE_PYTHON_COMPONENT_H__
+#define __BKE_PYTHON_COMPONENT_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct PythonComponent *BKE_python_component_new(char *import, struct ReportList *reports, struct bContext *context);
+void BKE_python_component_reload(struct PythonComponent *pc, struct ReportList *reports, struct bContext *context);
+void BKE_python_component_copy_list(struct ListBase *lbn, struct ListBase *lbo);
+void BKE_python_component_free(struct PythonComponent *pc);
+void BKE_python_component_free_list(struct ListBase *base);
+
+void *BKE_python_component_argument_dict_new(struct PythonComponent *pc);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __BKE_PYTHON_COMPONENT_H__ */
diff --git a/source/blender/blenkernel/CMakeLists.txt b/source/blender/blenkernel/CMakeLists.txt
index 157c440..800d719 100644
--- a/source/blender/blenkernel/CMakeLists.txt
+++ b/source/blender/blenkernel/CMakeLists.txt
@@ -40,6 +40,7 @@ set(INC
 	../nodes
 	../physics
 	../render/extern/include
+	../windowmanager
 	../../../intern/ghost
 	../../../intern/guardedalloc
 	../../../intern/glew-mx
@@ -54,6 +55,7 @@ set(INC
 set(INC_SYS
 	${GLEW_INCLUDE_PATH}
 	${ZLIB_INCLUDE_DIRS}
+	${PYTHON_INCLUDE_DIRS}
 )
 
 set(SRC
@@ -156,6 +158,7 @@ set(SRC
 	intern/pbvh_bmesh.c
 	intern/pointcache.c
 	intern/property.c
+	intern/python_component.c
 	intern/report.c
 	intern/rigidbody.c
 	intern/sca.c
@@ -272,6 +275,7 @@ set(SRC
 	BKE_pbvh.h
 	BKE_pointcache.h
 	BKE_property.h
+	BKE_python_component.h
 	BKE_report.h
 	BKE_rigidbody.h
 	BKE_sca.h
diff --git a/source/blender/blenkernel/intern/library_query.c b/source/blender/blenkernel/intern/library_query.c
index fa75c90..41111d9 100644
--- a/source/blender/blenkernel/intern/library_query.c
+++ b/source/blender/blenkernel/intern/library_query.c
@@ -430,8 +430,6 @@ void BKE_library_foreach_ID_link(ID *id, LibraryIDLinkCallback callback, void *u
 					BKE_rigidbody_world_id_loop(scene->rigidbody_world, library_foreach_rigidbodyworldSceneLooper, &data);
 				}
 
-				CALLBACK_INVOKE(scene->gm.dome.warptext, IDWALK_NOP);
-
 				break;
 			}
 
diff --git a/source/blender/blenkernel/intern/material.c b/source/blender/blenkernel/intern/material.c
index 5494524..8350765 100644
--- a/source/blender/blenkernel/intern/material.c
+++ b/source/blender/blenkernel/intern/material.c
@@ -108,6 +108,7 @@ void BKE_material_free(Material *ma)
 	MEM_SAFE_FREE(ma->texpaintslot);
 
 	GPU_material_free(&ma->gpumaterial);
+	GPU_material_free(&ma->gpumaterialinstancing);
 
 	BKE_icon_id_delete((ID *)ma);
 	BKE_previewimg_free(&ma->preview);
@@ -131,7 +132,6 @@ void BKE_material_init(Material *ma)
 	ma->flaresize = ma->subsize = 1.0;
 	ma->flareboost = 1;
 	ma->seed2 = 6;
-	ma->friction = 0.5;
 	ma->refrac = 4.0;
 	ma->roughness = 0.5;
 	ma->param[0] = 0.5;
@@ -201,11 +201,15 @@ void BKE_material_init(Material *ma)
 	ma->game.flag = GEMAT_BACKCULL;
 	ma->game.alpha_blend = 0;
 	ma->game.face_orientation = 0;
-	
+
+	ma->depthtranspfactor = 1.0f;
+
 	ma->mode = MA_TRACEBLE | MA_SHADBUF | MA_SHADOW | MA_RAYBIAS | MA_TANGENT_STR | MA_ZTRANSP;
 	ma->mode2 = MA_CASTSHADOW;
 	ma->shade_flag = MA_APPROX_OCCLUSION;
 	ma->preview = NULL;
+
+	ma->constflag = MA_CONSTANT_MATERIAL | MA_CONSTANT_LAMP | MA_CONSTANT_TEXTURE | MA_CONSTANT_TEXTURE_UV | MA_CONSTANT_WORLD | MA_CONSTANT_MIST;
 }
 
 Material *BKE_material_add(Main *bmain, const char *name)
@@ -247,6 +251,7 @@ Material *BKE_material_copy(Main *bmain, Material *ma)
 	BKE_previewimg_id_copy(&man->id, &ma->id);
 
 	BLI_listbase_clear(&man->gpumaterial);
+	BLI_listbase_clear(&man->gpumaterialinstancing);
 
 	BKE_id_copy_ensure_local(bmain, &ma->id, &man->id);
 
@@ -279,7 +284,8 @@ Material *localize_material(Material *ma)
 		man->nodetree = ntreeLocalize(ma->nodetree);
 	
 	BLI_listbase_clear(&man->gpumaterial);
-	
+	BLI_listbase_clear(&man->gpumaterialinstancing);
+
 	return man;
 }
 
@@ -1805,8 +1811,7 @@ static void decode_tfaceflag(Material *ma, int flag, int convertall)
 	/* Special Face Properties */
 	if ((flag & TF_TWOSIDE) == 0) (*game).flag |= GEMAT_BACKCULL;
 	if (flag & TF_INVISIBLE) (*game).flag |= GEMAT_INVISIBLE;
-	if (flag & TF_BMFONT) (*game).flag |= GEMAT_TEXT;
-	
+
 	/* Face Orientation */
 	if (flag & TF_BILLBOARD) (*game).face_orientation |= GEMAT_HALO;
 	else if (flag & TF_BILLBOARD2) (*game).face_orientation |= GEMAT_BILLBOARD;
diff --git a/source/blender/blenkernel/intern/object.c b/source/blender/blenkernel/intern/object.c
index e93bfcd..bd37211 100644
--- a/source/blender/blenkernel/intern/object.c
+++ b/source/blender/blenkernel/intern/object.c
@@ -117,6 +117,7 @@
 #include "BKE_material.h"
 #include "BKE_camera.h"
 #include "BKE_image.h"
+#include "BKE_python_component.h"
 
 #ifdef WITH_MOD_FLUID
 #include "LBM_fluidsim.h"
@@ -425,6 +426,7 @@ void BKE_object_free(Object *ob)
 	free_sensors(&ob->sensors);
 	free_controllers(&ob->controllers);
 	free_actuators(&ob->actuators);
+	BKE_python_component_free_list(&ob->components);
 	
 	BKE_constraints_free_ex(&ob->constraints, false);
 	
@@ -635,7 +637,9 @@ void BKE_object_init(Object *ob)
 	ob->anisotropicFriction[1] = 1.0f;
 	ob->anisotropicFriction[2] = 1.0f;
 	ob->gameflag = OB_PROP | OB_COLLISION;
+	ob->gameflag2 = 0;
 	ob->margin = 0.04f;
+	ob->friction = 0.5;
 	ob->init_state = 1;
 	ob->state = 1;
 	ob->obstacleRad = 1.0f;
@@ -1124,6 +1128,7 @@ Object *BKE_object_copy_ex(Main *bmain, Object *ob, bool copy_caches)
 	BKE_bproperty_copy_list(&obn->prop, &ob->prop);
 
 	BKE_sca_logic_copy(obn, ob);
+	BKE_python_component_copy_list(&obn->components, &ob->components);
 
 	if (ob->pose) {
 		copy_object_pose(obn, ob);
diff --git a/source/blender/blenkernel/intern/python_component.c b/source/blender/blenkernel/intern/python_component.c
new file mode 100644
index 0000000..65de2db
--- /dev/null
+++ b/source/blender/blenkernel/intern/python_component.c
@@ -0,0 +1,598 @@
+/**
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contributor(s): Mitchell Stokes, Diego Lopes, Tristan Porteries.
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "DNA_python_component_types.h"
+#include "DNA_property_types.h" /* For MAX_PROPSTRING */
+#include "DNA_windowmanager_types.h"
+#include "BLI_listbase.h"
+#include "BLI_string.h"
+#include "BLI_path_util.h"
+#include "MEM_guardedalloc.h"
+
+#include "BKE_python_component.h"
+#include "BKE_report.h"
+#include "BKE_context.h"
+#include "BKE_main.h"
+
+#include "RNA_types.h"
+
+#ifdef WITH_PYTHON
+#include "Python.h"
+#include "generic/py_capi_utils.h"
+#endif
+
+#include <string.h>
+
+#ifdef WITH_PYTHON
+
+PyDoc_STRVAR(class_documentation,
+"This is the fake BGE class KX_PythonComponent from fake BGE module bge.types"
+);
+
+static PyTypeObject PythonComponentType = {
+	PyVarObject_HEAD_INIT(NULL, 0)
+	"KX_PythonComponent",           /* tp_name */
+	sizeof(PyObject),               /* tp_basicsize */
+	0,                              /* tp_itemsize */
+	(destructor)NULL,               /* tp_dealloc */
+	NULL,                           /* tp_print */
+	NULL,                           /* tp_getattr */
+	NULL,                           /* tp_setattr */
+	NULL,                           /* tp_compare */
+	(reprfunc)NULL,                 /* tp_repr */
+	NULL,                           /* tp_as_number */
+	NULL,                           /* tp_as_sequence */
+	NULL,                           /* tp_as_mapping */
+	(hashfunc)NULL,                 /* tp_hash */
+	NULL,                           /* tp_call */
+	NULL,                           /* tp_str */
+	NULL,                           /* tp_getattro */
+	NULL,                           /* tp_setattro */
+	NULL,                           /* tp_as_buffer */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
+	class_documentation,            /* tp_doc */
+	(traverseproc)NULL,             /* tp_traverse */
+	(inquiry)NULL,                  /* tp_clear */
+	(richcmpfunc)NULL,              /* tp_richcompare */
+	0,                              /* tp_weaklistoffset */
+	NULL,                           /* tp_iter */
+	NULL,                           /* tp_iternext */
+	NULL,                           /* tp_methods */
+	NULL,                           /* tp_members */
+	NULL,                           /* tp_getset */
+	NULL,                           /* tp_base */
+	NULL,                           /* tp_dict */
+	NULL,                           /* tp_descr_get */
+	NULL,                           /* tp_descr_set */
+	0,                              /* tp_dictoffset */
+	NULL,                           /* tp_init */
+	PyType_GenericAlloc,            /* tp_alloc */
+	PyType_GenericNew,              /* tp_new */
+	NULL,                           /* tp_free */
+	NULL,                           /* tp_is_gc */
+	NULL,                           /* tp_bases */
+	NULL,                           /* tp_mro */
+	NULL,                           /* tp_cache */
+	NULL,                           /* tp_subclasses */
+	NULL,                           /* tp_weaklist */
+	NULL                            /* tp_del */
+};
+
+PyDoc_STRVAR(module_documentation,
+"This is the fake BGE API module used only to import the KX_PythonComponent class from bge.types.KX_PythonComponent"
+);
+
+static struct PyModuleDef bge_module_def = {
+	PyModuleDef_HEAD_INIT, /* m_base */
+	"bge",  /* m_name */
+	module_documentation,  /* m_doc */
+	0,  /* m_size */
+	NULL,  /* m_methods */
+	NULL,  /* m_reload */
+	NULL,  /* m_traverse */
+	NULL,  /* m_clear */
+	NULL,  /* m_free */
+};
+
+static struct PyModuleDef bge_types_module_def = {
+	PyModuleDef_HEAD_INIT, /* m_base */
+	"types",  /* m_name */
+	module_documentation,  /* m_doc */
+	0,  /* m_size */
+	NULL,  /* m_methods */
+	NULL,  /* m_reload */
+	NULL,  /* m_traverse */
+	NULL,  /* m_clear */
+	NULL,  /* m_free */
+};
+
+static int verify_class(PyObject *cls)
+{
+	return PyType_IsSubtype((PyTypeObject *)cls, &PythonComponentType);
+}
+
+static PythonComponentProperty *create_property(char *name)
+{
+	PythonComponentProperty *cprop;
+
+	cprop = MEM_callocN(sizeof(PythonComponentProperty), "PythonComponentProperty");
+	BLI_strncpy(cprop->name, name, sizeof(cprop->name));
+
+	return cprop;
+}
+
+#endif
+
+static PythonComponentProperty *copy_property(PythonComponentProperty *cprop)
+{
+	PythonComponentProperty *cpropn;
+
+	cpropn = MEM_dupallocN(cprop);
+
+	BLI_duplicatelist(&cpropn->enumval, &cprop->enumval);
+	for (LinkData *link = cpropn->enumval.first; link; link = link->next) {
+		link->data = MEM_dupallocN(link->data);
+	}
+
+	return cpropn;
+}
+
+static void free_property(PythonComponentProperty *cprop)
+{
+	for (LinkData *link = cprop->enumval.first; link; link = link->next) {
+		MEM_freeN(link->data);
+	}
+	BLI_freelistN(&cprop->enumval);
+	MEM_freeN(cprop);
+}
+
+static void free_properties(ListBase *lb)
+{
+	PythonComponentProperty *cprop;
+
+	while ((cprop = lb->first)) {
+		BLI_remlink(lb, cprop);
+		free_property(cprop);
+	}
+}
+
+#ifdef WITH_PYTHON
+static void create_properties(PythonComponent *pycomp, PyObject *cls)
+{
+	PyObject *args_dict, *pyitems;
+	ListBase properties;
+	memset(&properties, 0, sizeof(ListBase));
+
+	args_dict = PyObject_GetAttrString(cls, "args");
+
+	// If there is no args dict, then we are already done
+	if (!args_dict || !PyDict_Check(args_dict)) {
+		Py_XDECREF(args_dict);
+		return;
+	}
+
+	// Otherwise, parse the dict:
+	// key => value
+	// key = property name
+	// value = default value
+	// type(value) = property type
+	pyitems = PyMapping_Items(args_dict);
+
+	for (unsigned int i = 0, size = PyList_Size(pyitems); i < size; ++i) {
+		PythonComponentProperty *cprop;
+		char name[64];
+		bool free = false;
+		PyObject *pyitem = PyList_GetItem(pyitems, i);
+		PyObject *pykey = PyTuple_GetItem(pyitem, 0);
+		PyObject *pyvalue = PyTuple_GetItem(pyitem, 1);
+
+		// Make sure type(key) == string
+		if (!PyUnicode_Check(pykey)) {
+			printf("Non-string key found in the args dictionary, skipping\n");
+			continue;
+		}
+
+		BLI_strncpy(name, _PyUnicode_AsString(pykey), sizeof(name));
+
+		cprop = create_property(name);
+
+		// Determine the type and default value
+		if (PyBool_Check(pyvalue)) {
+			cprop->type = CPROP_TYPE_BOOLEAN;
+			cprop->boolval = PyLong_AsLong(pyvalue) != 0;
+		}
+		else if (PyLong_Check(pyvalue)) {
+			cprop->type = CPROP_TYPE_INT;
+			cprop->intval = PyLong_AsLong(pyvalue);
+		}
+		else if (PyFloat_Check(pyvalue)) {
+			cprop->type = CPROP_TYPE_FLOAT;
+			cprop->floatval = (float)PyFloat_AsDouble(pyvalue);
+		}
+		else if (PyUnicode_Check(pyvalue)) {
+			cprop->type = CPROP_TYPE_STRING;
+			BLI_strncpy((char*)cprop->strval, _PyUnicode_AsString(pyvalue), MAX_PROPSTRING);
+		}
+		else if (PySet_Check(pyvalue)) {
+			PyObject *iterator = PyObject_GetIter(pyvalue), *v = NULL;
+			unsigned int j = 0;
+			cprop->type = CPROP_TYPE_SET;
+
+			memset(&cprop->enumval, 0, sizeof(ListBase));
+			// Iterate to convert every enums to char.
+			while ((v = PyIter_Next(iterator))) {
+				if (!PyUnicode_Check(v)) {
+					printf("Enum property \"%s\" contains a non-string item (%u)\n", name, j);
+					continue;
+				}
+
+				LinkData *link = MEM_callocN(sizeof(LinkData), "PythonComponentProperty set link data");
+				char *str = MEM_callocN(MAX_PROPSTRING, "PythonComponentProperty set string");
+				BLI_strncpy(str, _PyUnicode_AsString(v), MAX_PROPSTRING);
+
+				link->data = str;
+				BLI_addtail(&cprop->enumval, link);
+
+				Py_DECREF(v);
+				++j;
+			}
+			Py_DECREF(iterator);
+			cprop->itemval = 0;
+		}
+		else if (PySequence_Check(pyvalue)) {
+			int len = PySequence_Size(pyvalue);
+			switch (len) {
+				case 2:
+					cprop->type = CPROP_TYPE_VEC2;
+					break;
+				case 3:
+					cprop->type = CPROP_TYPE_VEC3;
+					break;
+				case 4:
+					cprop->type = CPROP_TYPE_VEC4;
+					break;
+				default:
+					printf("Sequence property \"%s\" length %i out of range [2, 4]\n", name, len);
+					free = true;
+					break;
+			}
+
+			if (!free) {
+				for (unsigned int j = 0; j < len; ++j) {
+					PyObject *item = PySequence_GetItem(pyvalue, j);
+					if (PyFloat_Check(item)) {
+						cprop->vec[j] = PyFloat_AsDouble(item);
+					}
+					else {
+						printf("Sequence property \"%s\" contains a non-float item (%u)\n", name, j);
+					}
+					Py_DECREF(item);
+				}
+			}
+		}
+		else {
+			// Unsupported type
+			printf("Unsupported type %s found for property \"%s\", skipping\n", Py_TYPE(pyvalue)->tp_name, name);
+			free = true;
+		}
+
+		if (free) {
+			free_property(cprop);
+			continue;
+		}
+
+		bool found = false;
+		for (PythonComponentProperty *propit = pycomp->properties.first; propit; propit = propit->next) {
+			if ((strcmp(propit->name, cprop->name) == 0) && propit->type == cprop->type) {
+				/* We never reuse a enum property because we don't know if one of the
+				 * enum value was modified and it easier to just copy the current item
+				 * index than the list.
+				 */
+				if (cprop->type == CPROP_TYPE_SET) {
+					/* Unfortunatly the python type set doesn't repect an order even with same
+					 * content. To solve that we iterate on all new enums and find the coresponding
+					 * index for the old enum name.
+					 */
+					char *str = ((LinkData *)BLI_findlink(&propit->enumval, propit->itemval))->data;
+					int j = 0;
+					for (LinkData *link = cprop->enumval.first; link; link = link->next) {
+						if (strcmp(link->data, str) == 0) {
+							cprop->itemval = j;
+						}
+						++j;
+					}
+					break;
+				}
+				/* We found a coresponding property in the old component, so the new one
+				 * is released, the old property is removed from the original list and
+				 * added to the new list.
+				 */
+				free_property(cprop);
+				/* The exisiting property is removed to allow at the end free properties
+				 * that are no longuer used.
+				 */
+				BLI_remlink(&pycomp->properties, propit);
+				BLI_addtail(&properties, propit);
+				found = true;
+				break;
+			}
+		}
+		// If no exisiting property was found we add it simply.
+		if (!found) {
+			BLI_addtail(&properties, cprop);
+		}
+	}
+
+	// Free properties no used in the new component.
+	for (PythonComponentProperty *propit = pycomp->properties.first; propit;) {
+		PythonComponentProperty *prop = propit;
+		propit = propit->next;
+		free_property(prop);
+	}
+	// Set the new property list.
+	pycomp->properties = properties;
+
+}
+#endif /* WITH_PYTHON */
+
+static bool load_component(PythonComponent *pc, ReportList *reports, char *filename)
+{
+#ifdef WITH_PYTHON
+
+	/* Macro used to release all python variable if the convertion fail or succeed.
+	 * The "value" argument is false on failure and true on succes.
+	 */
+	#define FINISH(value) \
+		if (mod) { \
+			/* Take the module out of the module list so it's not cached \
+			   by Python (this allows for simpler reloading of components)*/ \
+			PyDict_DelItemString(sys_modules, pc->module); \
+		} \
+		Py_XDECREF(mod); \
+		Py_XDECREF(item); \
+		PyDict_DelItemString(sys_modules, "bge"); \
+		PyDict_DelItemString(sys_modules, "bge.types"); \
+		PySequence_DelItem(sys_path, 0); \
+		PyGILState_Release(state); \
+		return value;
+
+	PyObject *mod, *item = NULL, *sys_path, *pypath, *sys_modules, *bgemod, *bgesubmod;
+	PyGILState_STATE state;
+	char path[FILE_MAX];
+
+	state = PyGILState_Ensure();
+
+	// Set the current file directory do import path to allow extern modules.
+	sys_path = PySys_GetObject("path");
+	BLI_split_dir_part(filename, path, sizeof(path));
+	pypath = PyC_UnicodeFromByte(path);
+	PyList_Insert(sys_path, 0, pypath);
+
+	// Setup BGE fake module and submodule.
+	sys_modules = PyThreadState_GET()->interp->modules;
+	bgemod = PyModule_Create(&bge_module_def);
+	bgesubmod = PyModule_Create(&bge_types_module_def);
+
+	PyModule_AddObject(bgemod, "types", bgesubmod);
+	PyType_Ready(&PythonComponentType);
+	PyModule_AddObject(bgesubmod, "KX_PythonComponent", (PyObject *)&PythonComponentType);
+
+	PyDict_SetItemString(sys_modules, "bge", bgemod);
+	PyDict_SetItemString(sys_modules, "bge.types", bgesubmod);
+	PyDict_SetItemString(PyModule_GetDict(bgemod), "__component__", Py_True);
+	Py_INCREF(Py_True);
+
+	// Try to load up the module
+	mod = PyImport_ImportModule(pc->module);
+
+	if (!mod) {
+		BKE_reportf(reports, RPT_ERROR_INVALID_INPUT, "No module named \"%s\" or script error at loading.", pc->module);
+		FINISH(false);
+	}
+	else if (strlen(pc->module) > 0 && strlen(pc->name) == 0) {
+		BKE_report(reports, RPT_ERROR_INVALID_INPUT, "No component class was specified, only the module was.");
+		FINISH(false);
+	}
+
+	item = PyObject_GetAttrString(mod, pc->name);
+	if (!item) {
+		BKE_reportf(reports, RPT_ERROR_INVALID_INPUT, "No class named %s was found.", pc->name);
+		FINISH(false);
+	}
+
+	// Check the subclass with our own function since we don't have access to the KX_PythonComponent type object
+	if (!verify_class(item)) {
+		BKE_reportf(reports, RPT_ERROR_INVALID_INPUT, "A %s type was found, but it was not a valid subclass of KX_PythonComponent.", pc->name);
+		FINISH(false);
+	}
+	else {
+		// Setup the properties
+		create_properties(pc, item);
+	}
+
+	FINISH(true);
+
+	#undef ERROR
+
+#else
+
+	(void)pc;
+	(void)reports;
+	(void)filename;
+
+	return true;
+
+#endif /* WITH_PYTHON */
+}
+
+PythonComponent *BKE_python_component_new(char *import, ReportList *reports, bContext *context)
+{
+	char *classname;
+	char *modulename;
+	PythonComponent *pc;
+
+	// Don't bother with an empty string
+	if (strcmp(import, "") == 0) {
+		BKE_report(reports, RPT_ERROR_INVALID_INPUT, "No component was specified.");
+		return NULL;
+	}
+
+	// Extract the module name and the class name.
+	modulename = strtok(import, ".");
+	classname = strtok(NULL, ".");
+
+	pc = MEM_callocN(sizeof(PythonComponent), "PythonComponent");
+
+	// Copy module and class names.
+	strcpy(pc->module, modulename);
+	if (classname) {
+		strcpy(pc->name, classname);
+	}
+
+	// Try load the component.
+	if (!load_component(pc, reports, CTX_data_main(context)->name)) {
+		BKE_python_component_free(pc);
+		return NULL;
+	}
+
+	return pc;
+}
+
+void BKE_python_component_reload(PythonComponent *pc, ReportList *reports, bContext *context)
+{
+	load_component(pc, reports, CTX_data_main(context)->name);
+}
+
+static PythonComponent *copy_component(PythonComponent *comp)
+{
+	PythonComponent *compn;
+	PythonComponentProperty *cprop, *cpropn;
+
+	compn = MEM_dupallocN(comp);
+
+	BLI_listbase_clear(&compn->properties);
+	cprop = comp->properties.first;
+	while (cprop) {
+		cpropn = copy_property(cprop);
+		BLI_addtail(&compn->properties, cpropn);
+		cprop = cprop->next;
+	}
+
+	return compn;
+}
+
+void BKE_python_component_copy_list(ListBase *lbn, ListBase *lbo)
+{
+	PythonComponent *comp, *compn;
+
+	lbn->first = lbn->last = NULL;
+	comp = lbo->first;
+	while (comp) {
+		compn = copy_component(comp);
+		BLI_addtail(lbn, compn);
+		comp = comp->next;
+	}
+}
+
+void BKE_python_component_free(PythonComponent *pc)
+{
+	free_properties(&pc->properties);
+
+	MEM_freeN(pc);
+}
+
+void BKE_python_component_free_list(ListBase *lb)
+{
+	PythonComponent *pc;
+
+	while ((pc = lb->first)) {
+		BLI_remlink(lb, pc);
+		BKE_python_component_free(pc);
+	}
+}
+
+void *BKE_python_component_argument_dict_new(PythonComponent *pc)
+{
+#ifdef WITH_PYTHON
+	PythonComponentProperty *cprop = (PythonComponentProperty *)pc->properties.first;
+	PyObject *args = PyDict_New();
+
+	while (cprop) {
+		PyObject *value;
+		if (cprop->type == CPROP_TYPE_INT) {
+			value = PyLong_FromLong(cprop->intval);
+		}
+		else if (cprop->type == CPROP_TYPE_FLOAT) {
+			value = PyFloat_FromDouble(cprop->floatval);
+		}
+		else if (cprop->type == CPROP_TYPE_BOOLEAN) {
+			value = PyBool_FromLong(cprop->boolval);
+		}
+		else if (cprop->type == CPROP_TYPE_STRING) {
+			value = PyUnicode_FromString(cprop->strval);
+		}
+		else if (cprop->type == CPROP_TYPE_SET) {
+			LinkData *link = BLI_findlink(&cprop->enumval, cprop->itemval);
+			value = PyUnicode_FromString(link->data);
+		}
+		else if (cprop->type == CPROP_TYPE_VEC2 ||
+				 cprop->type == CPROP_TYPE_VEC3 ||
+				 cprop->type == CPROP_TYPE_VEC4)
+		{
+			int size;
+			switch (cprop->type) {
+				case CPROP_TYPE_VEC2:
+					size = 2;
+					break;
+				case CPROP_TYPE_VEC3:
+					size = 3;
+					break;
+				case CPROP_TYPE_VEC4:
+					size = 4;
+					break;
+			}
+			value = PyList_New(size);
+			// Fill the vector list.
+			for (unsigned int i = 0; i < size; ++i) {
+				PyList_SetItem(value, i, PyFloat_FromDouble(cprop->vec[i]));
+			}
+		}
+		else {
+			cprop = cprop->next;
+			continue;
+		}
+
+		PyDict_SetItemString(args, cprop->name, value);
+
+		cprop = cprop->next;
+	}
+
+	return args;
+
+#else
+
+	(void)pc;
+
+	return NULL;
+
+#endif /* WITH_PYTHON */
+}
diff --git a/source/blender/blenkernel/intern/sca.c b/source/blender/blenkernel/intern/sca.c
index fa22134..c50d829 100644
--- a/source/blender/blenkernel/intern/sca.c
+++ b/source/blender/blenkernel/intern/sca.c
@@ -107,6 +107,7 @@ void init_sensor(bSensor *sens)
 	bMouseSensor *ms;
 	bJoystickSensor *js;
 	bRaySensor *rs;
+	bMovementSensor *movs;
 	
 	if (sens->data) MEM_freeN(sens->data);
 	sens->data= NULL;
@@ -149,10 +150,16 @@ void init_sensor(bSensor *sens)
 	case SENS_RANDOM:
 		sens->data= MEM_callocN(sizeof(bRandomSensor), "randomsens");
 		break;
+	case SENS_MOVEMENT:
+		sens->data = MEM_callocN(sizeof(bMovementSensor), "movementsens");
+		movs = sens->data;
+		movs->threshold = 0.01f;
+		break;
 	case SENS_RAY:
 		sens->data= MEM_callocN(sizeof(bRaySensor), "raysens");
 		rs = sens->data;
 		rs->range = 0.01f;
+		rs->mask = (1 << OB_MAX_COL_MASKS) - 1;
 		break;
 	case SENS_MESSAGE:
 		sens->data= MEM_callocN(sizeof(bMessageSensor), "messagesens");
@@ -160,9 +167,10 @@ void init_sensor(bSensor *sens)
 	case SENS_JOYSTICK:
 		sens->data= MEM_callocN(sizeof(bJoystickSensor), "joysticksens");
 		js= sens->data;
-		js->hatf = SENS_JOY_HAT_UP;
-		js->axis = 1;
-		js->hat = 1;
+		js->type = SENS_JOY_AXIS;
+		js->axis = SENS_JOY_LEFT_STICK;
+		js->axis_single = SENS_JOY_LEFT_STICK_HORIZONTAL;
+		js->precision = 5000;
 		break;
 	default:
 		; /* this is very severe... I cannot make any memory for this        */
@@ -329,7 +337,6 @@ void free_actuator(bActuator *act)
 	if (act->data) {
 		switch (act->type) {
 			case ACT_ACTION:
-			case ACT_SHAPEACTION:
 			{
 				bActionActuator *aa = (bActionActuator *)act->data;
 				if (aa->act)
@@ -371,7 +378,6 @@ bActuator *copy_actuator(bActuator *act)
 	
 	switch (act->type) {
 		case ACT_ACTION:
-		case ACT_SHAPEACTION:
 		{
 			bActionActuator *aa = (bActionActuator *)act->data;
 			if (aa->act)
@@ -413,13 +419,13 @@ void init_actuator(bActuator *act)
 	bArmatureActuator *arma;
 	bMouseActuator *ma;
 	bEditObjectActuator *eoa;
+	bVibrationActuator *via;
 	
 	if (act->data) MEM_freeN(act->data);
 	act->data= NULL;
 	
 	switch (act->type) {
 	case ACT_ACTION:
-	case ACT_SHAPEACTION:
 		act->data= MEM_callocN(sizeof(bActionActuator), "actionact");
 		break;
 	case ACT_SOUND:
@@ -472,6 +478,12 @@ void init_actuator(bActuator *act)
 	case ACT_GAME:
 		act->data= MEM_callocN(sizeof(bGameActuator), "game act");
 		break;
+	case ACT_VIBRATION:
+		act->data = MEM_callocN(sizeof(bVibrationActuator), "vibration act");
+		via = act->data;
+		via->duration = 500; //milliseconds
+		via->strength = 0.4;
+		break;
 	case ACT_VISIBILITY:
 		act->data= MEM_callocN(sizeof(bVisibilityActuator), "visibility act");
 		break;
@@ -1016,6 +1028,7 @@ void BKE_sca_sensors_id_loop(ListBase *senslist, SCASensorIDFunc func, void *use
 			case SENS_RADAR:
 			case SENS_RANDOM:
 			case SENS_RAY:
+			case SENS_MOVEMENT:
 			case SENS_JOYSTICK:
 			case SENS_ACTUATOR:
 			case SENS_DELAY:
@@ -1149,6 +1162,7 @@ void BKE_sca_actuators_id_loop(ListBase *actlist, SCAActuatorIDFunc func, void *
 			case ACT_GROUP:
 			case ACT_RANDOM:
 			case ACT_GAME:
+			case ACT_VIBRATION:
 			case ACT_VISIBILITY:
 			case ACT_SHAPEACTION:
 			case ACT_STATE:
diff --git a/source/blender/blenkernel/intern/scene.c b/source/blender/blenkernel/intern/scene.c
index 091b810..5facd18 100644
--- a/source/blender/blenkernel/intern/scene.c
+++ b/source/blender/blenkernel/intern/scene.c
@@ -102,6 +102,8 @@
 #include "IMB_colormanagement.h"
 #include "IMB_imbuf.h"
 
+#include "wm_event_types.h"
+
 #include "bmesh.h"
 
 const char *RE_engine_id_BLENDER_RENDER = "BLENDER_RENDER";
@@ -189,7 +191,6 @@ Scene *BKE_scene_copy(Main *bmain, Scene *sce, int type)
 		
 		id_us_plus((ID *)scen->world);
 		id_us_plus((ID *)scen->set);
-		/* id_us_plus((ID *)scen->gm.dome.warptext); */  /* XXX Not refcounted? see readfile.c */
 
 		scen->ed = NULL;
 		scen->theDag = NULL;
@@ -694,12 +695,6 @@ void BKE_scene_init(Scene *sce)
 	sce->gm.stereomode = STEREO_ANAGLYPH;
 	sce->gm.eyeseparation = 0.10;
 
-	sce->gm.dome.angle = 180;
-	sce->gm.dome.mode = DOME_FISHEYE;
-	sce->gm.dome.res = 4;
-	sce->gm.dome.resbuf = 1.0f;
-	sce->gm.dome.tilt = 0;
-
 	sce->gm.xplay = 640;
 	sce->gm.yplay = 480;
 	sce->gm.freqplay = 60;
@@ -717,9 +712,6 @@ void BKE_scene_init(Scene *sce)
 	sce->gm.angulardeactthreshold = 1.0f;
 	sce->gm.deactivationtime = 0.0f;
 
-	sce->gm.flag = GAME_DISPLAY_LISTS;
-	sce->gm.matmode = GAME_MAT_MULTITEX;
-
 	sce->gm.obstacleSimulation = OBSTSIMULATION_NONE;
 	sce->gm.levelHeight = 2.f;
 
@@ -742,6 +734,11 @@ void BKE_scene_init(Scene *sce)
 
 	sce->gm.exitkey = 218; // Blender key code for ESC
 
+	sce->gm.pythonkeys[0] = LEFTCTRLKEY;
+	sce->gm.pythonkeys[1] = LEFTSHIFTKEY;
+	sce->gm.pythonkeys[2] = LEFTALTKEY;
+	sce->gm.pythonkeys[3] = TKEY;
+
 	BKE_sound_create_scene(sce);
 
 	/* color management */
diff --git a/source/blender/blenkernel/intern/texture.c b/source/blender/blenkernel/intern/texture.c
index 2d3ecad..c50dfe5 100644
--- a/source/blender/blenkernel/intern/texture.c
+++ b/source/blender/blenkernel/intern/texture.c
@@ -650,6 +650,7 @@ void BKE_texture_default(Tex *tex)
 		tex->env->clipend = 100;
 		tex->env->cuberes = 512;
 		tex->env->depth = 0;
+		tex->env->flag = ENVMAP_AUTO_UPDATE;
 	}
 
 	if (tex->pd) {
@@ -742,6 +743,9 @@ void BKE_texture_mtex_default(MTex *mtex)
 	mtex->blendtype = MTEX_BLEND;
 	mtex->colfac = 1.0;
 	mtex->norfac = 1.0;
+	mtex->parallaxuv = 0.0f;
+	mtex->parallaxbumpsc = 0.03f;
+	mtex->parallaxsteps = 10.0f;
 	mtex->varfac = 1.0;
 	mtex->dispfac = 0.2;
 	mtex->colspecfac = 1.0f;
@@ -781,6 +785,8 @@ void BKE_texture_mtex_default(MTex *mtex)
 	mtex->brush_map_mode = MTEX_MAP_MODE_TILED;
 	mtex->random_angle = 2.0f * (float)M_PI;
 	mtex->brush_angle_mode = 0;
+	mtex->ior = 1.0f;
+	mtex->refrratio = 0.0f;
 }
 
 
@@ -1257,7 +1263,8 @@ EnvMap *BKE_texture_envmap_add(void)
 	env->clipend = 100.0;
 	env->cuberes = 512;
 	env->viewscale = 0.5;
-	
+	env->flag = ENVMAP_AUTO_UPDATE;
+
 	return env;
 } 
 
diff --git a/source/blender/blenlib/BLI_utildefines.h b/source/blender/blenlib/BLI_utildefines.h
index 746eb92..e36d083 100644
--- a/source/blender/blenlib/BLI_utildefines.h
+++ b/source/blender/blenlib/BLI_utildefines.h
@@ -44,6 +44,10 @@ extern "C" {
 #include <stdio.h>
 #endif
 
+#ifdef WITH_ASSERT_ABORT
+#include <stdlib.h>
+#endif
+
 
 /* varargs macros (keep first so others can use) */
 /* --- internal helpers --- */
diff --git a/source/blender/blenloader/CMakeLists.txt b/source/blender/blenloader/CMakeLists.txt
index 8cb9ef8..7fe150b 100644
--- a/source/blender/blenloader/CMakeLists.txt
+++ b/source/blender/blenloader/CMakeLists.txt
@@ -33,6 +33,7 @@ set(INC
 	../makesdna
 	../makesrna
 	../nodes
+	../windowmanager
 	../render/extern/include
 	../../../intern/guardedalloc
 
@@ -53,6 +54,7 @@ set(SRC
 	intern/versioning_250.c
 	intern/versioning_260.c
 	intern/versioning_270.c
+	intern/versioning_upbge.c
 	intern/versioning_defaults.c
 	intern/versioning_legacy.c
 	intern/writefile.c
diff --git a/source/blender/blenloader/intern/readfile.c b/source/blender/blenloader/intern/readfile.c
index a63b9ed..07a84c9 100644
--- a/source/blender/blenloader/intern/readfile.c
+++ b/source/blender/blenloader/intern/readfile.c
@@ -85,6 +85,7 @@
 #include "DNA_packedFile_types.h"
 #include "DNA_particle_types.h"
 #include "DNA_property_types.h"
+#include "DNA_python_component_types.h"
 #include "DNA_rigidbody_types.h"
 #include "DNA_text_types.h"
 #include "DNA_view3d_types.h"
@@ -3982,6 +3983,7 @@ static void direct_link_material(FileData *fd, Material *ma)
 	
 	ma->preview = direct_link_preview_image(fd, ma->preview);
 	BLI_listbase_clear(&ma->gpumaterial);
+	BLI_listbase_clear(&ma->gpumaterialinstancing);
 }
 
 /* ************ READ PARTICLE SETTINGS ***************** */
@@ -4928,7 +4930,9 @@ static void lib_link_object(FileData *fd, Main *main)
 					/* bMouseActuator *moa= act->data; */
 				}
 			}
-			
+
+			ob->gamePredefinedBound = newlibadr_us(fd, ob->id.lib, ob->gamePredefinedBound);
+
 			{
 				FluidsimModifierData *fluidmd = (FluidsimModifierData *)modifiers_findByType(ob, eModifierType_Fluidsim);
 				
@@ -5322,6 +5326,8 @@ static void direct_link_object(FileData *fd, Object *ob)
 	bSensor *sens;
 	bController *cont;
 	bActuator *act;
+	PythonComponent *pc;
+	PythonComponentProperty *cprop;
 	
 	/* weak weak... this was only meant as draw flag, now is used in give_base_to_objects too */
 	ob->flag &= ~OB_FROMGROUP;
@@ -5491,6 +5497,9 @@ static void direct_link_object(FileData *fd, Object *ob)
 	else if (!ob->state) {
 		ob->state = 1;
 	}
+	else if (!ob->init_state) {
+		ob->init_state = 1;
+	}
 	for (cont = ob->controllers.first; cont; cont = cont->next) {
 		cont->data = newdataadr(fd, cont->data);
 		cont->links = newdataadr(fd, cont->links);
@@ -5504,6 +5513,21 @@ static void direct_link_object(FileData *fd, Object *ob)
 		act->data = newdataadr(fd, act->data);
 	}
 
+	link_glob_list(fd, &ob->components);
+	pc = ob->components.first;
+	while (pc) {
+		link_glob_list(fd, &pc->properties);
+		cprop = pc->properties.first;
+		while (cprop) {
+			link_list(fd, &cprop->enumval);
+			for (LinkData *link = cprop->enumval.first; link; link = link->next) {
+				link->data = newdataadr(fd, link->data);
+			}
+			cprop = cprop->next;
+		}
+		pc = pc->next;
+	}
+
 	link_list(fd, &ob->hooks);
 	while (ob->hooks.first) {
 		ObHook *hook = ob->hooks.first;
@@ -5768,9 +5792,7 @@ static void lib_link_scene(FileData *fd, Main *main)
 					fls->group = newlibadr_us(fd, sce->id.lib, fls->group);
 				}
 			}
-			/*Game Settings: Dome Warp Text*/
-			sce->gm.dome.warptext = newlibadr(fd, sce->id.lib, sce->gm.dome.warptext);
-			
+
 			/* Motion Tracking */
 			sce->clip = newlibadr_us(fd, sce->id.lib, sce->clip);
 
@@ -8254,6 +8276,8 @@ static BHead *read_global(BlendFileData *bfd, FileData *fd, BHead *bhead)
 	
 	/* copy to bfd handle */
 	bfd->main->subversionfile = fg->subversion;
+	bfd->main->upbgeversionfile = fg->upbgeversion;
+	bfd->main->upbgesubversionfile = fg->upbgesubversion;
 	bfd->main->minversionfile = fg->minversion;
 	bfd->main->minsubversionfile = fg->minsubversion;
 	bfd->main->build_commit_timestamp = fg->build_commit_timestamp;
@@ -8372,6 +8396,7 @@ static void do_versions(FileData *fd, Library *lib, Main *main)
 	blo_do_versions_250(fd, lib, main);
 	blo_do_versions_260(fd, lib, main);
 	blo_do_versions_270(fd, lib, main);
+	blo_do_versions_upbge(fd, lib, main);
 
 	/* WATCH IT!!!: pointers from libdata have not been converted yet here! */
 	/* WATCH IT 2!: Userdef struct init see do_versions_userdef() above! */
@@ -9502,10 +9527,7 @@ static void expand_scene(FileData *fd, Main *mainvar, Scene *sce)
 			expand_doit(fd, mainvar, lineset->linestyle);
 		}
 	}
-	
-	if (sce->r.dometext)
-		expand_doit(fd, mainvar, sce->gm.dome.warptext);
-	
+
 	if (sce->gpd)
 		expand_doit(fd, mainvar, sce->gpd);
 		
diff --git a/source/blender/blenloader/intern/readfile.h b/source/blender/blenloader/intern/readfile.h
index 7719aaa..4937051 100644
--- a/source/blender/blenloader/intern/readfile.h
+++ b/source/blender/blenloader/intern/readfile.h
@@ -169,6 +169,7 @@ void blo_do_versions_pre250(struct FileData *fd, struct Library *lib, struct Mai
 void blo_do_versions_250(struct FileData *fd, struct Library *lib, struct Main *main);
 void blo_do_versions_260(struct FileData *fd, struct Library *lib, struct Main *main);
 void blo_do_versions_270(struct FileData *fd, struct Library *lib, struct Main *main);
+void blo_do_versions_upbge(struct FileData *fd, struct Library *lib, struct Main *main);
 
 #endif
 
diff --git a/source/blender/blenloader/intern/versioning_250.c b/source/blender/blenloader/intern/versioning_250.c
index 1956a17..4e672c3 100644
--- a/source/blender/blenloader/intern/versioning_250.c
+++ b/source/blender/blenloader/intern/versioning_250.c
@@ -1035,15 +1035,6 @@ void blo_do_versions_250(FileData *fd, Library *lib, Main *main)
 				ts->vgroup_weight = 1.0f;
 			}
 
-			/* Game Settings */
-			/* Dome */
-			sce->gm.dome.angle = sce->r.domeangle;
-			sce->gm.dome.mode = sce->r.domemode;
-			sce->gm.dome.res = sce->r.domeres;
-			sce->gm.dome.resbuf = sce->r.domeresbuf;
-			sce->gm.dome.tilt = sce->r.dometilt;
-			sce->gm.dome.warptext = sce->r.dometext;
-
 			/* Stand Alone */
 			sce->gm.playerflag |= (sce->r.fullscreen ? GAME_PLAYER_FULLSCREEN : 0);
 			sce->gm.xplay = sce->r.xplay;
@@ -1054,15 +1045,11 @@ void blo_do_versions_250(FileData *fd, Library *lib, Main *main)
 
 			/* Stereo */
 			sce->gm.stereomode = sce->r.stereomode;
-			/* reassigning stereomode NO_STEREO and DOME to a separeted flag*/
+			/* reassigning stereomode NO_STEREO to a separeted flag*/
 			if (sce->gm.stereomode == 1) { // 1 = STEREO_NOSTEREO
 				sce->gm.stereoflag = STEREO_NOSTEREO;
 				sce->gm.stereomode = STEREO_ANAGLYPH;
 			}
-			else if (sce->gm.stereomode == 8) { // 8 = STEREO_DOME
-				sce->gm.stereoflag = STEREO_DOME;
-				sce->gm.stereomode = STEREO_ANAGLYPH;
-			}
 			else
 				sce->gm.stereoflag = STEREO_ENABLED;
 
@@ -1112,15 +1099,6 @@ void blo_do_versions_250(FileData *fd, Library *lib, Main *main)
 				sce->gm.flag |= GAME_GLSL_NO_ENV_LIGHTING;
 			if (fd->fileflags & G_FILE_IGNORE_DEPRECATION_WARNINGS)
 				sce->gm.flag |= GAME_IGNORE_DEPRECATION_WARNINGS;
-
-			if (fd->fileflags & G_FILE_GAME_MAT_GLSL)
-				sce->gm.matmode = GAME_MAT_GLSL;
-			else if (fd->fileflags & G_FILE_GAME_MAT)
-				sce->gm.matmode = GAME_MAT_MULTITEX;
-			else
-				sce->gm.matmode = GAME_MAT_TEXFACE;
-
-			sce->gm.flag |= GAME_DISPLAY_LISTS;
 		}
 
 		for (ob = main->object.first; ob; ob = ob->id.next) {
diff --git a/source/blender/blenloader/intern/versioning_260.c b/source/blender/blenloader/intern/versioning_260.c
index 907baab..3b14748 100644
--- a/source/blender/blenloader/intern/versioning_260.c
+++ b/source/blender/blenloader/intern/versioning_260.c
@@ -2509,10 +2509,6 @@ void blo_do_versions_260(FileData *fd, Library *UNUSED(lib), Main *main)
 			if (ts->sculpt)
 				ts->sculpt->flags |= SCULPT_DYNTOPO_SUBDIVIDE;
 
-			/* single texture mode removed from game engine */
-			if (scene->gm.matmode == GAME_MAT_TEXFACE)
-				scene->gm.matmode = GAME_MAT_MULTITEX;
-
 			/* 'Increment' mode disabled for nodes, use true grid snapping instead */
 			if (scene->toolsettings->snap_node_mode == SCE_SNAP_MODE_INCREMENT)
 				scene->toolsettings->snap_node_mode = SCE_SNAP_MODE_GRID;
diff --git a/source/blender/blenloader/intern/versioning_legacy.c b/source/blender/blenloader/intern/versioning_legacy.c
index f2d4284..5d282b4 100644
--- a/source/blender/blenloader/intern/versioning_legacy.c
+++ b/source/blender/blenloader/intern/versioning_legacy.c
@@ -3505,17 +3505,8 @@ void blo_do_versions_pre250(FileData *fd, Library *lib, Main *main)
 	}
 
 	if (main->versionfile < 248 || (main->versionfile == 248 && main->subversionfile < 4)) {
-		Scene *sce;
 		World *wrld;
 
-		/*  Dome (Fisheye) default parameters  */
-		for (sce = main->scene.first; sce; sce = sce->id.next) {
-			sce->r.domeangle = 180;
-			sce->r.domemode = 1;
-			sce->r.domeres = 4;
-			sce->r.domeresbuf = 1.0f;
-			sce->r.dometilt = 0;
-		}
 		/* DBVT culling by default */
 		for (wrld = main->world.first; wrld; wrld = wrld->id.next) {
 			wrld->mode |= WO_DBVT_CULLING;
diff --git a/source/blender/blenloader/intern/writefile.c b/source/blender/blenloader/intern/writefile.c
index ad1999c..e237078 100644
--- a/source/blender/blenloader/intern/writefile.c
+++ b/source/blender/blenloader/intern/writefile.c
@@ -131,6 +131,7 @@
 #include "DNA_packedFile_types.h"
 #include "DNA_particle_types.h"
 #include "DNA_property_types.h"
+#include "DNA_python_component_types.h"
 #include "DNA_rigidbody_types.h"
 #include "DNA_scene_types.h"
 #include "DNA_sdna_types.h"
@@ -1452,6 +1453,9 @@ static void write_sensors(WriteData *wd, ListBase *lb)
 			case SENS_RAY:
 				writestruct(wd, DATA, bRaySensor, 1, sens->data);
 				break;
+			case SENS_MOVEMENT:
+				writestruct(wd, DATA, bMovementSensor, 1, sens->data);
+				break;
 			case SENS_MESSAGE:
 				writestruct(wd, DATA, bMessageSensor, 1, sens->data);
 				break;
@@ -1501,7 +1505,6 @@ static void write_actuators(WriteData *wd, ListBase *lb)
 
 		switch (act->type) {
 			case ACT_ACTION:
-			case ACT_SHAPEACTION:
 				writestruct(wd, DATA, bActionActuator, 1, act->data);
 				break;
 			case ACT_SOUND:
@@ -1537,6 +1540,9 @@ static void write_actuators(WriteData *wd, ListBase *lb)
 			case ACT_GAME:
 				writestruct(wd, DATA, bGameActuator, 1, act->data);
 				break;
+			case ACT_VIBRATION:
+				writestruct(wd, DATA, bVibrationActuator, 1, act->data);
+				break;
 			case ACT_VISIBILITY:
 				writestruct(wd, DATA, bVisibilityActuator, 1, act->data);
 				break;
@@ -1566,6 +1572,36 @@ static void write_actuators(WriteData *wd, ListBase *lb)
 	}
 }
 
+static void write_component_properties(WriteData *wd, ListBase *lb)
+{
+	PythonComponentProperty *cprop;
+	cprop = lb->first;
+
+	while (cprop) {
+		LinkData *link;
+		writestruct(wd, DATA, PythonComponentProperty, 1, cprop);
+		writelist(wd, DATA, LinkData, &cprop->enumval);
+		for (link = cprop->enumval.first; link; link = link->next) {
+			writedata(wd, DATA, strlen(link->data)+1, link->data);
+		}
+		cprop = cprop->next;
+	}
+}
+
+static void write_components(WriteData *wd, ListBase *lb)
+{
+	PythonComponent *pc;
+
+	pc = lb->first;
+
+	while(pc) {
+		writestruct(wd, DATA, PythonComponent, 1, pc);
+		write_component_properties(wd, &pc->properties);
+
+		pc = pc->next;
+	}
+}
+
 static void write_motionpath(WriteData *wd, bMotionPath *mpath)
 {
 	/* sanity checks */
@@ -1856,6 +1892,7 @@ static void write_objects(WriteData *wd, ListBase *idbase)
 			write_sensors(wd, &ob->sensors);
 			write_controllers(wd, &ob->controllers);
 			write_actuators(wd, &ob->actuators);
+			write_components(wd, &ob->components);
 
 			if (ob->type == OB_ARMATURE) {
 				bArmature *arm = ob->data;
@@ -3995,10 +4032,12 @@ static void write_global(WriteData *wd, int fileflags, Main *mainvar)
 	BLI_strncpy(fg.filename, mainvar->name, sizeof(fg.filename));
 	sprintf(subvstr, "%4d", BLENDER_SUBVERSION);
 	memcpy(fg.subvstr, subvstr, 4);
-
-	fg.subversion = BLENDER_SUBVERSION;
-	fg.minversion = BLENDER_MINVERSION;
-	fg.minsubversion = BLENDER_MINSUBVERSION;
+	
+	fg.subversion= BLENDER_SUBVERSION;
+	fg.upbgeversion = UPBGE_VERSION;
+	fg.upbgesubversion = UPBGE_SUBVERSION;
+	fg.minversion= BLENDER_MINVERSION;
+	fg.minsubversion= BLENDER_MINSUBVERSION;
 #ifdef WITH_BUILDINFO
 	{
 		extern unsigned long build_commit_timestamp;
diff --git a/source/blender/editors/object/object_edit.c b/source/blender/editors/object/object_edit.c
index 111afcd..289da55 100644
--- a/source/blender/editors/object/object_edit.c
+++ b/source/blender/editors/object/object_edit.c
@@ -2165,6 +2165,13 @@ static int game_physics_copy_exec(bContext *C, wmOperator *UNUSED(op))
 			ob_iter->max_angvel = ob->max_angvel;
 			ob_iter->obstacleRad = ob->obstacleRad;
 			ob_iter->mass = ob->mass;
+			ob_iter->friction = ob->friction;
+			ob_iter->rolling_friction = ob->rolling_friction;
+			ob_iter->fh = ob->fh;
+			ob_iter->reflect = ob->reflect;
+			ob_iter->fhdist = ob->fhdist;
+			ob_iter->xyfrict = ob->xyfrict;
+			ob_iter->dynamode = ob->dynamode;
 			copy_v3_v3(ob_iter->anisotropicFriction, ob->anisotropicFriction);
 			ob_iter->collision_boundtype = ob->collision_boundtype;
 			ob_iter->margin = ob->margin;
diff --git a/source/blender/editors/render/render_opengl.c b/source/blender/editors/render/render_opengl.c
index 9097432..32cd0a1 100644
--- a/source/blender/editors/render/render_opengl.c
+++ b/source/blender/editors/render/render_opengl.c
@@ -632,7 +632,7 @@ static bool screen_opengl_render_init(bContext *C, wmOperator *op)
 	sizey = (scene->r.size * scene->r.ysch) / 100;
 
 	/* corrects render size with actual size, not every card supports non-power-of-two dimensions */
-	ofs = GPU_offscreen_create(sizex, sizey, full_samples ? 0 : samples, err_out);
+	ofs = GPU_offscreen_create(sizex, sizey, full_samples ? 0 : samples, GPU_HDR_NONE, GPU_OFFSCREEN_DEPTH_COMPARE, err_out);
 
 	if (!ofs) {
 		BKE_reportf(op->reports, RPT_ERROR, "Failed to create OpenGL off-screen buffer, %s", err_out);
diff --git a/source/blender/editors/render/render_update.c b/source/blender/editors/render/render_update.c
index f11a817..035c6b9 100644
--- a/source/blender/editors/render/render_update.c
+++ b/source/blender/editors/render/render_update.c
@@ -293,6 +293,8 @@ static void material_changed(Main *bmain, Material *ma)
 	/* glsl */
 	if (ma->gpumaterial.first)
 		GPU_material_free(&ma->gpumaterial);
+	if (ma->gpumaterialinstancing.first)
+		GPU_material_free(&ma->gpumaterialinstancing);
 
 	/* find node materials using this */
 	for (parent = bmain->mat.first; parent; parent = parent->id.next) {
@@ -307,6 +309,8 @@ static void material_changed(Main *bmain, Material *ma)
 
 		if (parent->gpumaterial.first)
 			GPU_material_free(&parent->gpumaterial);
+		if (parent->gpumaterialinstancing.first)
+			GPU_material_free(&parent->gpumaterialinstancing);
 	}
 
 	/* find if we have a scene with textured display */
@@ -350,12 +354,17 @@ static void lamp_changed(Main *bmain, Lamp *la)
 		if (ob->data == la && ob->gpulamp.first)
 			GPU_lamp_free(ob);
 
-	for (ma = bmain->mat.first; ma; ma = ma->id.next)
+	for (ma = bmain->mat.first; ma; ma = ma->id.next) {
 		if (ma->gpumaterial.first)
 			GPU_material_free(&ma->gpumaterial);
+		if (ma->gpumaterialinstancing.first)
+			GPU_material_free(&ma->gpumaterialinstancing);
+	}
 
 	if (defmaterial.gpumaterial.first)
 		GPU_material_free(&defmaterial.gpumaterial);
+	if (defmaterial.gpumaterialinstancing.first)
+		GPU_material_free(&defmaterial.gpumaterialinstancing);
 }
 
 static int material_uses_texture(Material *ma, Tex *tex)
@@ -394,6 +403,8 @@ static void texture_changed(Main *bmain, Tex *tex)
 
 		if (ma->gpumaterial.first)
 			GPU_material_free(&ma->gpumaterial);
+		if (ma->gpumaterialinstancing.first)
+			GPU_material_free(&ma->gpumaterialinstancing);
 	}
 
 	/* find lamps */
@@ -472,12 +483,17 @@ static void world_changed(Main *bmain, World *wo)
 	BKE_icon_changed(BKE_icon_id_ensure(&wo->id));
 	
 	/* glsl */
-	for (ma = bmain->mat.first; ma; ma = ma->id.next)
+	for (ma = bmain->mat.first; ma; ma = ma->id.next) {
 		if (ma->gpumaterial.first)
 			GPU_material_free(&ma->gpumaterial);
+		if (ma->gpumaterialinstancing.first)
+			GPU_material_free(&ma->gpumaterialinstancing);
+	}
 
 	if (defmaterial.gpumaterial.first)
 		GPU_material_free(&defmaterial.gpumaterial);
+	if (defmaterial.gpumaterialinstancing.first)
+		GPU_material_free(&defmaterial.gpumaterialinstancing);
 	
 	if (wo->gpumaterial.first)
 		GPU_material_free(&wo->gpumaterial);
@@ -514,9 +530,12 @@ static void scene_changed(Main *bmain, Scene *scene)
 		}
 	}
 
-	for (ma = bmain->mat.first; ma; ma = ma->id.next)
+	for (ma = bmain->mat.first; ma; ma = ma->id.next) {
 		if (ma->gpumaterial.first)
 			GPU_material_free(&ma->gpumaterial);
+		if (ma->gpumaterialinstancing.first)
+			GPU_material_free(&ma->gpumaterialinstancing);
+	}
 
 	for (wo = bmain->world.first; wo; wo = wo->id.next)
 		if (wo->gpumaterial.first)
@@ -524,6 +543,8 @@ static void scene_changed(Main *bmain, Scene *scene)
 	
 	if (defmaterial.gpumaterial.first)
 		GPU_material_free(&defmaterial.gpumaterial);
+	if (defmaterial.gpumaterialinstancing.first)
+		GPU_material_free(&defmaterial.gpumaterialinstancing);
 }
 
 void ED_render_id_flush_update(Main *bmain, ID *id)
diff --git a/source/blender/editors/space_image/image_ops.c b/source/blender/editors/space_image/image_ops.c
index 324a3cb..ea5b3a1 100644
--- a/source/blender/editors/space_image/image_ops.c
+++ b/source/blender/editors/space_image/image_ops.c
@@ -2374,6 +2374,7 @@ static int image_new_exec(bContext *C, wmOperator *op)
 	Object *obedit;
 	Image *ima;
 	Main *bmain;
+	Tex *tex;
 	PointerRNA ptr, idptr;
 	PropertyRNA *prop;
 	char _name[MAX_ID_NAME - 2];
@@ -2389,6 +2390,8 @@ static int image_new_exec(bContext *C, wmOperator *op)
 	obedit = CTX_data_edit_object(C);
 	bmain = CTX_data_main(C);
 
+	tex = CTX_data_pointer_get_type(C, "texture", &RNA_Texture).data;
+
 	prop = RNA_struct_find_property(op->ptr, "name");
 	RNA_property_string_get(op->ptr, prop, name);
 	if (!RNA_property_is_set(op->ptr, prop)) {
@@ -2407,6 +2410,19 @@ static int image_new_exec(bContext *C, wmOperator *op)
 	if (!alpha)
 		color[3] = 1.0f;
 
+	if (tex && tex->type == TEX_ENVMAP) {
+		/* Here we control that envmap width = 3 / 2 * envmap height and that
+		 * envmap height is a power of 2 to be sure to have a supported envmap resolution.
+		 */
+		if (!(width == ceil(height * 3 / 2) && ((height & (height - 1)) == 0))) {
+			int previous = pow(2, ceil(log(height) / log(2))) / 2;
+			height = previous;
+			width = previous * 3 / 2;
+
+			BKE_report(op->reports, RPT_ERROR, "Invalid image size for cube map texture user, down to a valid size");
+		}
+	}
+
 	ima = BKE_image_add_generated(bmain, width, height, name, alpha ? 32 : 24, floatbuf, gen_type, color, stereo3d);
 
 	if (!ima)
@@ -2463,12 +2479,14 @@ static int image_new_exec(bContext *C, wmOperator *op)
 		WM_event_add_notifier(C, NC_SCENE | ND_TOOLSETTINGS, NULL);		
 	}
 	else {
-		Tex *tex = CTX_data_pointer_get_type(C, "texture", &RNA_Texture).data;
-		if (tex && tex->type == TEX_IMAGE) {
+		if (tex && (tex->type == TEX_IMAGE || tex->type == TEX_ENVMAP)) {
 			if (tex->ima)
 				id_us_min(&tex->ima->id);
 			tex->ima = ima;
 			ED_area_tag_redraw(CTX_wm_area(C));
+			DAG_id_tag_update(&tex->id, 0);
+			WM_main_add_notifier(NC_TEXTURE, tex);
+			WM_main_add_notifier(NC_MATERIAL | ND_SHADING_DRAW, NULL);
 		}
 	}
 
diff --git a/source/blender/editors/space_logic/logic_ops.c b/source/blender/editors/space_logic/logic_ops.c
index 074368a..0b53a23 100644
--- a/source/blender/editors/space_logic/logic_ops.c
+++ b/source/blender/editors/space_logic/logic_ops.c
@@ -35,6 +35,7 @@
 #include "DNA_controller_types.h"
 #include "DNA_actuator_types.h"
 #include "DNA_scene_types.h"
+#include "DNA_python_component_types.h"
 
 #include "BLI_blenlib.h"
 #include "BLI_utildefines.h"
@@ -44,6 +45,7 @@
 #include "BKE_context.h"
 #include "BKE_main.h"
 #include "BKE_sca.h"
+#include "BKE_python_component.h"
 
 #include "ED_logic.h"
 #include "ED_object.h"
@@ -56,6 +58,7 @@
 #include "WM_api.h"
 #include "WM_types.h"
 
+#include "UI_interface.h"
 #include "UI_view2d.h"
 
 #include "logic_intern.h"
@@ -735,6 +738,144 @@ static void LOGIC_OT_view_all(wmOperatorType *ot)
 	ot->flag = 0;
 }
 
+/* Component operators */
+static int component_add_exec(bContext *C, wmOperator *op)
+{
+	PythonComponent *pycomp;
+	Object *ob = CTX_data_active_object(C);
+	char import[MAX_NAME];
+
+	if (!ob) {
+		return OPERATOR_CANCELLED;
+	}
+
+	RNA_string_get(op->ptr, "component_name", import);
+	pycomp = BKE_python_component_new(import, op->reports, C);
+
+	if(!pycomp) {
+		return OPERATOR_CANCELLED;
+	}
+
+	BLI_addtail(&ob->components, pycomp);
+	WM_event_add_notifier(C, NC_LOGIC, NULL);
+
+	return OPERATOR_FINISHED;
+}
+
+static int component_new_invoke(bContext *C, wmOperator *op, const wmEvent *UNUSED(event))
+{
+	/* Better for user feedback. */
+	return WM_operator_props_dialog_popup(C, op, 15 * UI_UNIT_X, UI_UNIT_Y);
+}
+
+static void LOGIC_OT_component_add(wmOperatorType *ot)
+{
+	ot->name = "Add Python Component";
+	ot->idname = "LOGIC_OT_add_python_component";
+	ot->description = "Add a python component to the selected object";
+
+	/* api callbacks */
+	ot->exec = component_add_exec;
+	ot->invoke = component_new_invoke;
+	ot->poll = ED_operator_object_active_editable;
+
+	/* flags */
+	ot->flag = OPTYPE_REGISTER | OPTYPE_UNDO;
+
+	PropertyRNA *parm;
+	parm = RNA_def_string(ot->srna, "component_name", "module.Component", 64, "Component", "The component class name with module (module.ComponentName)");
+	RNA_def_parameter_flags(parm, 0, PARM_REQUIRED);
+}
+
+static int component_remove_exec(bContext *C, wmOperator *op)
+{
+	Object *ob = CTX_data_active_object(C);
+	PythonComponent *pc = NULL;
+	int index = RNA_int_get(op->ptr, "index");
+
+	if(!ob) {
+		return OPERATOR_CANCELLED;
+	}
+
+	pc = BLI_findlink(&ob->components, index);
+
+	if(!pc) {
+		return OPERATOR_CANCELLED;
+	}
+
+	BLI_remlink(&ob->components, pc);
+	BKE_python_component_free(pc);
+
+	WM_event_add_notifier(C, NC_LOGIC, NULL);
+
+	return OPERATOR_FINISHED;
+}
+
+static void LOGIC_OT_component_remove(wmOperatorType *ot)
+{
+	/* identifiers */
+	ot->name = "Remove Component";
+	ot->description = "Remove Component";
+	ot->idname = "LOGIC_OT_component_remove";
+
+	/* api callbacks */
+	ot->exec = component_remove_exec;
+	ot->poll = ED_operator_object_active_editable;
+
+	/* flags */
+	ot->flag = OPTYPE_REGISTER | OPTYPE_UNDO;
+
+	/* properties */
+	RNA_def_int(ot->srna, "index", 0, 0, INT_MAX, "Index", "Component index to remove", 0, INT_MAX);
+}
+
+static int component_reload_exec(bContext *C, wmOperator *op)
+{
+	Object *ob = CTX_data_active_object(C);
+	PythonComponent *pc = NULL, *prev_pc = NULL;
+	int index = RNA_int_get(op->ptr, "index");
+
+	if(!ob) {
+		return OPERATOR_CANCELLED;
+	}
+
+	if (index > 0) {
+		prev_pc = BLI_findlink(&ob->components, index-1);
+		pc = prev_pc->next;
+	}
+	else {
+		/* pc is at the head */
+		pc = BLI_findlink(&ob->components, index);
+	}
+
+	if(!pc) {
+		return OPERATOR_CANCELLED;
+	}
+
+	/* Try to create a new component */
+	BKE_python_component_reload(pc, op->reports, C);
+
+	return OPERATOR_FINISHED;
+}
+
+static void LOGIC_OT_component_reload(wmOperatorType *ot)
+{
+	/* identifiers */
+	ot->name = "Reload Component";
+	ot->description = "Reload Component";
+	ot->idname = "LOGIC_OT_component_reload";
+
+	/* api callbacks */
+	ot->exec = component_reload_exec;
+	ot->poll = ED_operator_object_active_editable;
+
+	/* flags */
+	ot->flag = OPTYPE_REGISTER | OPTYPE_UNDO;
+
+	/* properties */
+	RNA_def_int(ot->srna, "index", 0, 0, INT_MAX, "Index", "Component index to reload", 0, INT_MAX);
+}
+
 /* ************************* */
 
 void ED_operatortypes_logic(void)
@@ -748,5 +889,10 @@ void ED_operatortypes_logic(void)
 	WM_operatortype_append(LOGIC_OT_actuator_remove);
 	WM_operatortype_append(LOGIC_OT_actuator_add);
 	WM_operatortype_append(LOGIC_OT_actuator_move);
+
+	WM_operatortype_append(LOGIC_OT_component_add);
+	WM_operatortype_append(LOGIC_OT_component_remove);
+	WM_operatortype_append(LOGIC_OT_component_reload);
+
 	WM_operatortype_append(LOGIC_OT_view_all);
 }
diff --git a/source/blender/editors/space_logic/logic_window.c b/source/blender/editors/space_logic/logic_window.c
index 874e54b..982dcc3 100644
--- a/source/blender/editors/space_logic/logic_window.c
+++ b/source/blender/editors/space_logic/logic_window.c
@@ -359,6 +359,8 @@ static const char *sensor_name(int type)
 		return N_("Random");
 	case SENS_RAY:
 		return N_("Ray");
+	case SENS_MOVEMENT:
+		return N_("Movement");
 	case SENS_MESSAGE:
 		return N_("Message");
 	case SENS_JOYSTICK:
@@ -393,8 +395,6 @@ static const char *controller_name(int type)
 static const char *actuator_name(int type)
 {
 	switch (type) {
-	case ACT_SHAPEACTION:
-		return N_("Shape Action");
 	case ACT_ACTION:
 		return N_("Action");
 	case ACT_OBJECT:
@@ -423,6 +423,8 @@ static const char *actuator_name(int type)
 		return N_("Message");
 	case ACT_GAME:
 		return N_("Game");
+	case ACT_VIBRATION:
+		return N_("Vibration");
 	case ACT_VISIBILITY:
 		return N_("Visibility");
 	case ACT_2DFILTER:
@@ -873,12 +875,10 @@ static void draw_sensor_header(uiLayout *layout, PointerRNA *ptr, PointerRNA *lo
 					         RNA_boolean_get(ptr, "active")));
 	uiItemR(sub, ptr, "pin", UI_ITEM_R_NO_BG, "", ICON_NONE);
 
-	if (RNA_boolean_get(ptr, "show_expanded")==0) {
-		sub = uiLayoutRow(row, true);
-		uiLayoutSetActive(sub, RNA_boolean_get(ptr, "active"));
-		uiItemEnumO(sub, "LOGIC_OT_sensor_move", "", ICON_TRIA_UP, "direction", 1); // up
-		uiItemEnumO(sub, "LOGIC_OT_sensor_move", "", ICON_TRIA_DOWN, "direction", 2); // down
-	}
+	sub = uiLayoutRow(row, true);
+	uiLayoutSetActive(sub, RNA_boolean_get(ptr, "active"));
+	uiItemEnumO(sub, "LOGIC_OT_sensor_move", "", ICON_TRIA_UP, "direction", 1); // up
+	uiItemEnumO(sub, "LOGIC_OT_sensor_move", "", ICON_TRIA_DOWN, "direction", 2); // down
 
 	sub = uiLayoutRow(row, false);
 	uiItemR(sub, ptr, "active", 0, "", ICON_NONE);
@@ -987,41 +987,39 @@ static void draw_sensor_delay(uiLayout *layout, PointerRNA *ptr)
 
 static void draw_sensor_joystick(uiLayout *layout, PointerRNA *ptr)
 {
-	uiLayout *col, *row;
+	uiLayout *col, *row, *split;
 
 	uiItemR(layout, ptr, "joystick_index", 0, NULL, ICON_NONE);
-	uiItemR(layout, ptr, "event_type", 0, NULL, ICON_NONE);
+	split = uiLayoutSplit(layout, 0.75f, false);
+	row = uiLayoutRow(split, false);
+	uiItemR(row, ptr, "event_type", 0, NULL, ICON_NONE);
 
 	switch (RNA_enum_get(ptr, "event_type")) {
 		case SENS_JOY_BUTTON:
-			uiItemR(layout, ptr, "use_all_events", 0, NULL, ICON_NONE);
+			uiItemR(split, ptr, "use_all_events", 0, NULL, ICON_NONE);
 
 			col = uiLayoutColumn(layout, false);
 			uiLayoutSetActive(col, RNA_boolean_get(ptr, "use_all_events") == false);
 			uiItemR(col, ptr, "button_number", 0, NULL, ICON_NONE);
 			break;
 		case SENS_JOY_AXIS:
-			row = uiLayoutRow(layout, false);
-			uiItemR(row, ptr, "axis_number", 0, NULL, ICON_NONE);
-			uiItemR(row, ptr, "axis_threshold", 0, NULL, ICON_NONE);
+			uiItemR(split, ptr, "use_all_events", 0, NULL, ICON_NONE);
 
-			uiItemR(layout, ptr, "use_all_events", 0, NULL, ICON_NONE);
 			col = uiLayoutColumn(layout, false);
+			uiItemR(col, ptr, "axis_number", 0, NULL, ICON_NONE);
 			uiLayoutSetActive(col, RNA_boolean_get(ptr, "use_all_events") == false);
 			uiItemR(col, ptr, "axis_direction", 0, NULL, ICON_NONE);
+			uiItemR(col, ptr, "axis_threshold", 0, NULL, ICON_NONE);
 			break;
-		case SENS_JOY_HAT:
-			uiItemR(layout, ptr, "hat_number", 0, NULL, ICON_NONE);
-			uiItemR(layout, ptr, "use_all_events", 0, NULL, ICON_NONE);
-
+		case SENS_JOY_AXIS_SINGLE:
 			col = uiLayoutColumn(layout, false);
-			uiLayoutSetActive(col, RNA_boolean_get(ptr, "use_all_events") == false);
-			uiItemR(col, ptr, "hat_direction", 0, NULL, ICON_NONE);
+			uiItemR(col, ptr, "single_axis_number", 0, NULL, ICON_NONE);
+			uiItemR(col, ptr, "axis_threshold", 0, NULL, ICON_NONE);
 			break;
-		case SENS_JOY_AXIS_SINGLE:
-			row = uiLayoutRow(layout, false);
-			uiItemR(row, ptr, "single_axis_number", 0, NULL, ICON_NONE);
-			uiItemR(row, ptr, "axis_threshold", 0, NULL, ICON_NONE);
+		case SENS_JOY_SHOULDER_TRIGGER:
+			col = uiLayoutColumn(layout, false);
+			uiItemR(col, ptr, "axis_trigger_number", 0, NULL, ICON_NONE);
+			uiItemR(col, ptr, "axis_threshold", 0, NULL, ICON_NONE);
 			break;
 	}
 }
@@ -1164,6 +1162,17 @@ static void draw_sensor_ray(uiLayout *layout, PointerRNA *ptr, bContext *C)
 	row = uiLayoutRow(split, false);
 	uiItemR(row, ptr, "range", 0, NULL, ICON_NONE);
 	uiItemR(row, ptr, "use_x_ray", UI_ITEM_R_TOGGLE, NULL, ICON_NONE);
+	split = uiLayoutSplit(layout, 0.3, false);
+	uiItemR(split, ptr, "mask", 0, NULL, ICON_NONE);
+}
+
+static void draw_sensor_movement(uiLayout *layout, PointerRNA *ptr)
+{
+	uiLayout *row;
+	uiItemR(layout, ptr, "axis", 0, NULL, ICON_NONE);
+	row = uiLayoutRow(layout, false);
+	uiItemR(row, ptr, "use_local", UI_ITEM_R_TOGGLE, NULL, ICON_NONE);
+	uiItemR(row, ptr, "threshold", 0, NULL, ICON_NONE);
 }
 
 static void draw_brick_sensor(uiLayout *layout, PointerRNA *ptr, bContext *C)
@@ -1218,6 +1227,9 @@ static void draw_brick_sensor(uiLayout *layout, PointerRNA *ptr, bContext *C)
 		case SENS_RANDOM:
 			draw_sensor_random(box, ptr);
 			break;
+		case SENS_MOVEMENT:
+			draw_sensor_movement(box, ptr);
+			break;
 		case SENS_RAY:
 			draw_sensor_ray(box, ptr, C);
 			break;
@@ -1255,12 +1267,10 @@ static void draw_controller_header(uiLayout *layout, PointerRNA *ptr, int xco, i
 	uiLayoutSetActive(sub, RNA_boolean_get(ptr, "active"));
 	uiItemR(sub, ptr, "use_priority", 0, "", ICON_NONE);
 
-	if (RNA_boolean_get(ptr, "show_expanded")==0) {
-		sub = uiLayoutRow(row, true);
-		uiLayoutSetActive(sub, RNA_boolean_get(ptr, "active"));
-		uiItemEnumO(sub, "LOGIC_OT_controller_move", "", ICON_TRIA_UP, "direction", 1); // up
-		uiItemEnumO(sub, "LOGIC_OT_controller_move", "", ICON_TRIA_DOWN, "direction", 2); // down
-	}
+	sub = uiLayoutRow(row, true);
+	uiLayoutSetActive(sub, RNA_boolean_get(ptr, "active"));
+	uiItemEnumO(sub, "LOGIC_OT_controller_move", "", ICON_TRIA_UP, "direction", 1); // up
+	uiItemEnumO(sub, "LOGIC_OT_controller_move", "", ICON_TRIA_DOWN, "direction", 2); // down
 
 	sub = uiLayoutRow(row, false);
 	uiItemR(sub, ptr, "active", 0, "", ICON_NONE);
@@ -1357,12 +1367,10 @@ static void draw_actuator_header(uiLayout *layout, PointerRNA *ptr, PointerRNA *
 	                          RNA_boolean_get(ptr, "active")));
 	uiItemR(sub, ptr, "pin", UI_ITEM_R_NO_BG, "", ICON_NONE);
 
-	if (RNA_boolean_get(ptr, "show_expanded")==0) {
-		sub = uiLayoutRow(row, true);
-		uiLayoutSetActive(sub, RNA_boolean_get(ptr, "active"));
-		uiItemEnumO(sub, "LOGIC_OT_actuator_move", "", ICON_TRIA_UP, "direction", 1); // up
-		uiItemEnumO(sub, "LOGIC_OT_actuator_move", "", ICON_TRIA_DOWN, "direction", 2); // down
-	}
+	sub = uiLayoutRow(row, true);
+	uiLayoutSetActive(sub, RNA_boolean_get(ptr, "active"));
+	uiItemEnumO(sub, "LOGIC_OT_actuator_move", "", ICON_TRIA_UP, "direction", 1); // up
+	uiItemEnumO(sub, "LOGIC_OT_actuator_move", "", ICON_TRIA_DOWN, "direction", 2); // down
 
 	sub = uiLayoutRow(row, false);
 	uiItemR(sub, ptr, "active", 0, "", ICON_NONE);
@@ -1975,45 +1983,6 @@ static void draw_actuator_scene(uiLayout *layout, PointerRNA *ptr)
 	}
 }
 
-static void draw_actuator_shape_action(uiLayout *layout, PointerRNA *ptr)
-{
-	Object *ob = (Object *)ptr->id.data;
-	PointerRNA settings_ptr;
-	uiLayout *row;
-
-	if (ob->type != OB_MESH) {
-		uiItemL(layout, IFACE_("Actuator only available for mesh objects"), ICON_NONE);
-		return;
-	}
-
-	RNA_pointer_create((ID *)ob, &RNA_GameObjectSettings, ob, &settings_ptr);
-
-	row = uiLayoutRow(layout, false);
-	uiItemR(row, ptr, "mode", 0, "", ICON_NONE);
-	uiItemR(row, ptr, "action", 0, "", ICON_NONE);
-	uiItemR(row, ptr, "use_continue_last_frame", 0, NULL, ICON_NONE);
-
-	row = uiLayoutRow(layout, false);
-	if ((RNA_enum_get(ptr, "mode") == ACT_ACTION_FROM_PROP))
-		uiItemPointerR(row, ptr, "property", &settings_ptr, "properties", NULL, ICON_NONE);
-
-	else {
-		uiItemR(row, ptr, "frame_start", 0, NULL, ICON_NONE);
-		uiItemR(row, ptr, "frame_end", 0, NULL, ICON_NONE);
-	}
-
-	row = uiLayoutRow(layout, false);
-	uiItemR(row, ptr, "frame_blend_in", 0, NULL, ICON_NONE);
-	uiItemR(row, ptr, "priority", 0, NULL, ICON_NONE);
-
-	row = uiLayoutRow(layout, false);
-	uiItemPointerR(row, ptr, "frame_property", &settings_ptr, "properties", NULL, ICON_NONE);
-
-#ifdef __NLA_ACTION_BY_MOTION_ACTUATOR
-	uiItemR(row, "stride_length", 0, NULL, ICON_NONE);
-#endif
-}
-
 static void draw_actuator_sound(uiLayout *layout, PointerRNA *ptr, bContext *C)
 {
 	uiLayout *row, *col;
@@ -2064,6 +2033,32 @@ static void draw_actuator_state(uiLayout *layout, PointerRNA *ptr)
 	uiTemplateLayers(split, ptr, "states", &settings_ptr, "used_states", 0);
 }
 
+static void draw_actuator_vibration(uiLayout *layout, PointerRNA *ptr)
+{
+	uiLayout *row;
+	row = uiLayoutRow(layout, false);
+
+	uiItemR(layout, ptr, "mode", 0, NULL, 0);
+
+	switch (RNA_enum_get(ptr, "mode")) {
+		case ACT_VIBRATION_PLAY:
+		{
+			uiItemR(row, ptr, "joy_index", 0, NULL, ICON_NONE);
+			row = uiLayoutRow(layout, false);
+			uiItemR(row, ptr, "joy_strength_left", 0, NULL, ICON_NONE);
+			uiItemR(row, ptr, "joy_strength_right", 0, NULL, ICON_NONE);
+			row = uiLayoutRow(layout, false);
+			uiItemR(row, ptr, "joy_duration", 0, NULL, ICON_NONE);
+			break;
+		}
+		case ACT_VIBRATION_STOP:
+		{
+			uiItemR(row, ptr, "joy_index", 0, NULL, ICON_NONE);
+			break;
+		}
+	}
+}
+
 static void draw_actuator_visibility(uiLayout *layout, PointerRNA *ptr)
 {
 	uiLayout *row;
@@ -2232,15 +2227,15 @@ static void draw_brick_actuator(uiLayout *layout, PointerRNA *ptr, bContext *C)
 		case ACT_SCENE:
 			draw_actuator_scene(box, ptr);
 			break;
-		case ACT_SHAPEACTION:
-			draw_actuator_shape_action(box, ptr);
-			break;
 		case ACT_SOUND:
 			draw_actuator_sound(box, ptr, C);
 			break;
 		case ACT_STATE:
 			draw_actuator_state(box, ptr);
 			break;
+		case ACT_VIBRATION:
+			draw_actuator_vibration(box, ptr);
+			break;
 		case ACT_VISIBILITY:
 			draw_actuator_visibility(box, ptr);
 			break;
diff --git a/source/blender/editors/space_text/CMakeLists.txt b/source/blender/editors/space_text/CMakeLists.txt
index de85ddc..7be6c4a 100644
--- a/source/blender/editors/space_text/CMakeLists.txt
+++ b/source/blender/editors/space_text/CMakeLists.txt
@@ -41,6 +41,7 @@ set(SRC
 	text_autocomplete.c
 	text_draw.c
 	text_format.c
+	text_format_glsl.c
 	text_format_lua.c
 	text_format_osl.c
 	text_format_py.c
diff --git a/source/blender/editors/space_text/space_text.c b/source/blender/editors/space_text/space_text.c
index 686a10f..1ad5616 100644
--- a/source/blender/editors/space_text/space_text.c
+++ b/source/blender/editors/space_text/space_text.c
@@ -636,5 +636,6 @@ void ED_spacetype_text(void)
 	ED_text_format_register_py();
 	ED_text_format_register_osl();
 	ED_text_format_register_lua();
+	ED_text_format_register_glsl();
 }
 
diff --git a/source/blender/editors/space_text/text_format.h b/source/blender/editors/space_text/text_format.h
index b901ec8..1cf2d00 100644
--- a/source/blender/editors/space_text/text_format.h
+++ b/source/blender/editors/space_text/text_format.h
@@ -102,6 +102,7 @@ void            ED_text_format_register(TextFormatType *tft);
 void ED_text_format_register_py(void);
 void ED_text_format_register_osl(void);
 void ED_text_format_register_lua(void);
+void ED_text_format_register_glsl(void);
 
 #define STR_LITERAL_STARTSWITH(str, str_literal, len_var) \
 	(strncmp(str, str_literal, len_var = (sizeof(str_literal) - 1)) == 0)
diff --git a/source/blender/editors/space_text/text_format_glsl.c b/source/blender/editors/space_text/text_format_glsl.c
new file mode 100644
index 0000000..db5f3d7
--- /dev/null
+++ b/source/blender/editors/space_text/text_format_glsl.c
@@ -0,0 +1,393 @@
+
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+/** \file blender/editors/space_text/text_format_glsl.c
+ *  \ingroup sptext
+ */
+
+#include <string.h>
+
+#include "BLI_blenlib.h"
+
+#include "DNA_text_types.h"
+#include "DNA_space_types.h"
+
+#include "BKE_text.h"
+
+#include "text_format.h"
+
+/* *** glsl Keywords (for format_line) *** */
+
+/* Checks the specified source string for a glsl keyword (minus boolean & 'nil').
+ * This name must start at the beginning of the source string and must be
+ * followed by a non-identifier (see text_check_identifier(char)) or null char.
+ *
+ * If a keyword is found, the length of the matching word is returned.
+ * Otherwise, -1 is returned.
+ *
+ */
+
+static int txtfmt_glsl_find_keyword(const char *string)
+{
+	int i, len;
+
+	if      (STR_LITERAL_STARTSWITH(string, "if",           len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "else",         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "void",         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "float",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "int",          len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "uniform",      len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "varying",      len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "location",     len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "in",           len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "out",          len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "discard",      len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "return",       len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "vec2",         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "vec3",         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "vec4",         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "mat3",         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "mat4",         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "sampler2D",    len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "sampler1D",    len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "samplerCube",  len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "const",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "uint",         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "uvec2",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "uvec3",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "uvec4",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "for",          len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "while",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "continue",     len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "break",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "inout",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "attribute",    len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "layout",       len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "centroid",     len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "flat",         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "smooth",       len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "patch",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "sample",       len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "do",           len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "switch",       len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "case",         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "default",      len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "subroutine",   len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "double",       len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "invariant",    len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "dmat2",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "dmat3",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "dmat4",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "mat2",         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "ivec2",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "ivec3",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "ivec4",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "bvec2",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "bvec3",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "bvec4",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "dvec2",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "dvec3",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "dvec4",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "precision",    len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "lowp",         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "highp",        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "mediump",      len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "sampler3D",    len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "struct",       len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "goto",         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "sizeof",       len)) i = len;
+	else i = 0;
+
+	/* If next source char is an identifier (eg. 'i' in "definate") no match */
+	if (i == 0 || text_check_identifier(string[i]))
+		return -1;
+	return i;
+}
+
+/* Checks the specified source string for a glsl special name/function. This
+ * name must start at the beginning of the source string and must be followed
+ * by a non-identifier (see text_check_identifier(char)) or null character.
+ *
+ * If a special name is found, the length of the matching name is returned.
+ * Otherwise, -1 is returned.
+ *
+ */
+
+static int txtfmt_glsl_find_specialvar(const char *string)
+{
+	int i, len;
+
+	if      (STR_LITERAL_STARTSWITH(string, "gl_Position;",                          len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_VertexID;",                          len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_InstanceID;",                        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_PointSize;",                         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_ClipDistance",                       len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_PerVertex",                          len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "getmetatable",                          len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_ViewportIndex",                      len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_Layer",                              len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_ViewportIndex",                      len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_TessLevelOuter",                     len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_TessLevelInner",                     len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_FragCoord",                          len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_FrontFacing",                        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_PointCoord",                         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_PrimitiveID",                        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_SampleID",                           len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_SamplePosition",                     len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_FragColor",                          len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_FragData",                           len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_MaxDrawBuffers",                     len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_FragDepth",                          len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_SampleMask",                         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_ClipVertex",                         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_FrontColor",                         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_BackColor",                          len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_TexCoord",                           len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_FogFragCoord",                       len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_Color",                              len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_Normal",                             len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_MultiTexCoord0",                     len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_MultiTexCoord1",                     len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_MultiTexCoord2",                     len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_MultiTexCoord3",                     len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_MultiTexCoord4",                     len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_MultiTexCoord5",                     len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_MultiTexCoord6",                     len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_MultiTexCoord7",                     len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_FogCoord",                           len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_NormalMatrix",                       len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_ModelViewMatrix",                    len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_ProjectionMatrix",                   len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_ModelViewProjectionMatrix",          len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "ftransform",                            len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_TextureMatrix",                      len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_MaxTextureCoords",                   len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_ModelViewMatrixInverse",             len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_ProjectionMatrixInverse",            len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_ModelViewProjectionMatrixInverse",   len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_ModelViewMatrixTranspose",           len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_ProjectionMatrixTranspose",          len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_ModelViewProjectionMatrixTranspose", len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_ClipPlane",                          len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_LightSource",                        len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_MaxLights",                          len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_LightModel",                         len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_Fog",                                len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_FrontMaterial",                      len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_BackMaterial",                       len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_Point",                              len)) i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "gl_NormalScale",                        len)) i = len;
+	else i = 0;
+
+	/* If next source char is an identifier (eg. 'i' in "definate") no match */
+	if (i == 0 || text_check_identifier(string[i]))
+		return -1;
+	return i;
+}
+
+static int txtfmt_glsl_find_bool(const char *string)
+{
+	int i, len;
+
+	if      (STR_LITERAL_STARTSWITH(string, "null",  len))  i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "true",  len))  i = len;
+	else if (STR_LITERAL_STARTSWITH(string, "false", len))  i = len;
+	else i = 0;
+
+	/* If next source char is an identifier (eg. 'i' in "Nonetheless") no match */
+	if (i == 0 || text_check_identifier(string[i]))
+		return -1;
+	return i;
+}
+
+static char txtfmt_glsl_format_identifier(const char *str)
+{
+	char fmt;
+	if	((txtfmt_glsl_find_specialvar(str))	!= -1) fmt = FMT_TYPE_SPECIAL;
+	else if ((txtfmt_glsl_find_keyword(str))	!= -1) fmt = FMT_TYPE_KEYWORD;
+	else fmt = FMT_TYPE_DEFAULT;
+	return fmt;
+}
+
+static void txtfmt_glsl_format_line(SpaceText *st, TextLine *line, const bool do_next)
+{
+	FlattenString fs;
+	const char *str;
+	char *fmt;
+	char cont_orig, cont, find, prev = ' ';
+	int len, i;
+
+	/* Get continuation from previous line */
+	if (line->prev && line->prev->format != NULL) {
+		fmt = line->prev->format;
+		cont = fmt[strlen(fmt) + 1]; /* Just after the null-terminator */
+		BLI_assert((FMT_CONT_ALL & cont) == cont);
+	}
+	else {
+		cont = FMT_CONT_NOP;
+	}
+
+	/* Get original continuation from this line */
+	if (line->format != NULL) {
+		fmt = line->format;
+		cont_orig = fmt[strlen(fmt) + 1]; /* Just after the null-terminator */
+		BLI_assert((FMT_CONT_ALL & cont_orig) == cont_orig);
+	}
+	else {
+		cont_orig = 0xFF;
+	}
+
+	len = flatten_string(st, &fs, line->line);
+	str = fs.buf;
+	if (!text_check_format_len(line, len)) {
+		flatten_string_free(&fs);
+		return;
+	}
+	fmt = line->format;
+
+	while (*str) {
+		/* Handle escape sequences by skipping both \ and next char */
+		if (*str == '\\') {
+			*fmt = prev; fmt++; str++;
+			if (*str == '\0') break;
+			*fmt = prev; fmt++; str += BLI_str_utf8_size_safe(str);
+			continue;
+		}
+		/* Handle continuations */
+		else if (cont) {
+			/* Multi-line comments */
+			if (cont & FMT_CONT_COMMENT_C) {
+				if (*str == '*' && *(str + 1) == '/') {
+					*fmt = FMT_TYPE_COMMENT; fmt++; str++;
+					*fmt = FMT_TYPE_COMMENT;
+					cont = FMT_CONT_NOP;
+				}
+				else {
+					*fmt = FMT_TYPE_COMMENT;
+				}
+				/* Handle other comments */
+			}
+			else {
+				find = (cont & FMT_CONT_QUOTEDOUBLE) ? '"' : '\'';
+				if (*str == find) cont = 0;
+				*fmt = FMT_TYPE_STRING;
+			}
+
+			str += BLI_str_utf8_size_safe(str) - 1;
+		}
+		/* Not in a string... */
+		else {
+			/* Multi-line comments */
+			if (*str == '/'	   && *(str + 1) == '*')
+			{
+				cont = FMT_CONT_COMMENT_C;
+				*fmt = FMT_TYPE_COMMENT; fmt++; str++;
+				*fmt = FMT_TYPE_COMMENT; fmt++; str++;
+				*fmt = FMT_TYPE_COMMENT; fmt++; str++;
+				*fmt = FMT_TYPE_COMMENT;
+			}
+			/* Single line comment */
+			else if (*str == '/' && *(str + 1) == '/') {
+				text_format_fill(&str, &fmt, FMT_TYPE_COMMENT, len - (int)(fmt - line->format));
+			}
+			else if (*str == '"' || *str == '\'') {
+				/* Strings */
+				find = *str;
+				cont = (*str == '"') ? FMT_CONT_QUOTEDOUBLE : FMT_CONT_QUOTESINGLE;
+				*fmt = FMT_TYPE_STRING;
+			}
+			/* Whitespace (all ws. has been converted to spaces) */
+			else if (*str == ' ') {
+				*fmt = FMT_TYPE_WHITESPACE;
+			}
+			/* Numbers (digits not part of an identifier and periods followed by digits) */
+			else if ((prev != FMT_TYPE_DEFAULT && text_check_digit(*str)) ||
+					 (*str == '.' && text_check_digit(*(str + 1))))
+			{
+				*fmt = FMT_TYPE_NUMERAL;
+			}
+			/* Booleans */
+			else if (prev != FMT_TYPE_DEFAULT && (i = txtfmt_glsl_find_bool(str)) != -1) {
+				if (i > 0) {
+					text_format_fill_ascii(&str, &fmt, FMT_TYPE_NUMERAL, i);
+				}
+				else {
+					str += BLI_str_utf8_size_safe(str) - 1;
+					*fmt = FMT_TYPE_DEFAULT;
+				}
+			}
+			/* Punctuation */
+			else if ((*str != '#') && text_check_delim(*str)) {
+				*fmt = FMT_TYPE_SYMBOL;
+			}
+
+			/* Preprocessor */
+			else if ((*str == '#')) {
+				text_format_fill(&str, &fmt, FMT_TYPE_DIRECTIVE, len - (int)(fmt - line->format));
+			}
+
+			/* Identifiers and other text (no previous ws. or delims. so text continues) */
+			else if (prev == FMT_TYPE_DEFAULT) {
+				str += BLI_str_utf8_size_safe(str) - 1;
+				*fmt = FMT_TYPE_DEFAULT;
+			}
+			/* Not ws, a digit, punct, or continuing text. Must be new, check for special words */
+			else {
+				/* Special vars(v) or built-in keywords(b) */
+				/* keep in sync with 'txtfmt_osl_format_identifier()' */
+				if	  ((i = txtfmt_glsl_find_specialvar(str))   != -1) prev = FMT_TYPE_SPECIAL;
+				else if ((i = txtfmt_glsl_find_keyword(str))	  != -1) prev = FMT_TYPE_KEYWORD;
+
+				if (i > 0) {
+					text_format_fill_ascii(&str, &fmt, prev, i);
+				}
+				else {
+					str += BLI_str_utf8_size_safe(str) - 1;
+					*fmt = FMT_TYPE_DEFAULT;
+				}
+			}
+		}
+		prev = *fmt; fmt++; str++;
+	}
+
+	/* Terminate and add continuation char */
+	*fmt = '\0'; fmt++;
+	*fmt = cont;
+
+	/* If continuation has changed and we're allowed, process the next line */
+	if (cont != cont_orig && do_next && line->next) {
+		txtfmt_glsl_format_line(st, line->next, do_next);
+	}
+
+	flatten_string_free(&fs);
+}
+
+void ED_text_format_register_glsl(void)
+{
+	static TextFormatType tft = {NULL};
+	static const char *ext[] = {"glsl", "frag", "vert", "fx", "fs", "vs", NULL};
+
+	tft.format_identifier 	= txtfmt_glsl_format_identifier;
+	tft.format_line	   	= txtfmt_glsl_format_line;
+	tft.ext = ext;
+
+	ED_text_format_register(&tft);
+}
diff --git a/source/blender/editors/space_view3d/CMakeLists.txt b/source/blender/editors/space_view3d/CMakeLists.txt
index a5c6024..33b50c2 100644
--- a/source/blender/editors/space_view3d/CMakeLists.txt
+++ b/source/blender/editors/space_view3d/CMakeLists.txt
@@ -75,7 +75,7 @@ endif()
 
 if(WITH_GAMEENGINE)
 	list(APPEND INC
-		../../../gameengine/BlenderRoutines
+		../../../gameengine/Launcher
 	)
 	add_definitions(-DWITH_GAMEENGINE)
 endif()
diff --git a/source/blender/editors/space_view3d/drawmesh.c b/source/blender/editors/space_view3d/drawmesh.c
index ecbfd5c..ad2e9b8 100644
--- a/source/blender/editors/space_view3d/drawmesh.c
+++ b/source/blender/editors/space_view3d/drawmesh.c
@@ -777,149 +777,6 @@ static DMDrawOption wpaint__setSolidDrawOptions_facemask(void *userData, int ind
 	return DM_DRAW_OPTION_NORMAL;
 }
 
-static void draw_mesh_text(Scene *scene, Object *ob, int glsl)
-{
-	Mesh *me = ob->data;
-	DerivedMesh *ddm;
-	MPoly *mp, *mface  = me->mpoly;
-	MTexPoly *mtpoly   = me->mtpoly;
-	MLoopUV *mloopuv   = me->mloopuv;
-	MLoopUV *luv;
-	MLoopCol *mloopcol = me->mloopcol;  /* why does mcol exist? */
-	MLoopCol *lcol;
-
-	bProperty *prop = BKE_bproperty_object_get(ob, "Text");
-	GPUVertexAttribs gattribs;
-	int a, totpoly = me->totpoly;
-
-	/* fake values to pass to GPU_render_text() */
-	MCol  tmp_mcol[4]  = {{0}};
-	MCol *tmp_mcol_pt  = mloopcol ? tmp_mcol : NULL;
-
-	/* don't draw without tfaces */
-	if (!mtpoly || !mloopuv)
-		return;
-
-	/* don't draw when editing */
-	if (ob->mode & OB_MODE_EDIT)
-		return;
-	else if (ob == OBACT)
-		if (BKE_paint_select_elem_test(ob))
-			return;
-
-	ddm = mesh_get_derived_deform(scene, ob, CD_MASK_BAREMESH);
-
-	for (a = 0, mp = mface; a < totpoly; a++, mtpoly++, mp++) {
-		short matnr = mp->mat_nr;
-		const bool mf_smooth = (mp->flag & ME_SMOOTH) != 0;
-		Material *mat = (me->mat) ? me->mat[matnr] : NULL;
-		int mode = mat ? mat->game.flag : GEMAT_INVISIBLE;
-
-
-		if (!(mode & GEMAT_INVISIBLE) && (mode & GEMAT_TEXT) && mp->totloop >= 3) {
-			/* get the polygon as a tri/quad */
-			int mp_vi[4];
-			float   v_quad_data[4][3];
-			const float  *v_quad[4];
-			const float *uv_quad[4];
-			char string[MAX_PROPSTRING];
-			int characters, i, glattrib = -1, badtex = 0;
-
-
-			/* TEXFACE */
-			if (glsl) {
-				GPU_object_material_bind(matnr + 1, &gattribs);
-
-				for (i = 0; i < gattribs.totlayer; i++) {
-					if (gattribs.layer[i].type == CD_MTFACE) {
-						glattrib = gattribs.layer[i].glindex;
-						break;
-					}
-				}
-			}
-			else {
-				badtex = set_draw_settings_cached(0, mtpoly, mat, &Gtexdraw);
-				if (badtex) {
-					continue;
-				}
-			}
-
-			mp_vi[0] = me->mloop[mp->loopstart + 0].v;
-			mp_vi[1] = me->mloop[mp->loopstart + 1].v;
-			mp_vi[2] = me->mloop[mp->loopstart + 2].v;
-			mp_vi[3] = (mp->totloop >= 4) ? me->mloop[mp->loopstart + 3].v : 0;
-
-			/* UV */
-			luv = &mloopuv[mp->loopstart];
-			uv_quad[0] = luv->uv; luv++;
-			uv_quad[1] = luv->uv; luv++;
-			uv_quad[2] = luv->uv; luv++;
-			if (mp->totloop >= 4) {
-				uv_quad[3] = luv->uv;
-			}
-			else {
-				uv_quad[3] = NULL;
-			}
-
-
-			/* COLOR */
-			if (mloopcol) {
-				unsigned int totloop_clamp = min_ii(4, mp->totloop);
-				unsigned int j;
-				lcol = &mloopcol[mp->loopstart];
-
-				for (j = 0; j < totloop_clamp; j++, lcol++) {
-					MESH_MLOOPCOL_TO_MCOL(lcol, &tmp_mcol[j]);
-				}
-			}
-
-			/* LOCATION */
-			ddm->getVertCo(ddm, mp_vi[0], v_quad_data[0]);
-			ddm->getVertCo(ddm, mp_vi[1], v_quad_data[1]);
-			ddm->getVertCo(ddm, mp_vi[2], v_quad_data[2]);
-			if (mp->totloop >= 4) {
-				ddm->getVertCo(ddm, mp_vi[3], v_quad_data[3]);
-			}
-
-			v_quad[0] = v_quad_data[0];
-			v_quad[1] = v_quad_data[1];
-			v_quad[2] = v_quad_data[2];
-			if (mp->totloop >= 4) {
-				v_quad[3] = v_quad_data[2];
-			}
-			else {
-				v_quad[3] = NULL;
-			}
-
-
-			/* The BM_FONT handling is in the gpu module, shared with the
-			 * game engine, was duplicated previously */
-
-			BKE_bproperty_set_valstr(prop, string);
-			characters = strlen(string);
-			
-			if (!BKE_image_has_ibuf(mtpoly->tpage, NULL))
-				characters = 0;
-
-			if (!mf_smooth) {
-				float nor[3];
-
-				normal_tri_v3(nor, v_quad[0], v_quad[1], v_quad[2]);
-
-				glNormal3fv(nor);
-			}
-
-			GPU_render_text(
-			        mtpoly, mode, string, characters,
-			        (unsigned int *)tmp_mcol_pt,
-			        v_quad, uv_quad,
-			        glattrib);
-		}
-	}
-
-	ddm->release(ddm);
-}
-
 static int compareDrawOptions(void *userData, int cur_index, int next_index)
 {
 	drawTFace_userData *data = userData;
@@ -1037,13 +894,6 @@ static void draw_mesh_textured_old(Scene *scene, View3D *v3d, RegionView3D *rv3d
 		}
 	}
 
-	/* draw game engine text hack */
-	if (rv3d->rflag & RV3D_IS_GAME_ENGINE) {
-		if (BKE_bproperty_object_get(ob, "Text")) {
-			draw_mesh_text(scene, ob, 0);
-		}
-	}
-
 	draw_textured_end();
 	
 	/* draw edges and selected faces over textured mesh */
diff --git a/source/blender/editors/space_view3d/drawobject.c b/source/blender/editors/space_view3d/drawobject.c
index 90d33dc..ebe7984 100644
--- a/source/blender/editors/space_view3d/drawobject.c
+++ b/source/blender/editors/space_view3d/drawobject.c
@@ -309,7 +309,7 @@ bool draw_glsl_material(Scene *scene, Object *ob, View3D *v3d, const char dt)
 		return true;
 
 	if (v3d->drawtype == OB_TEXTURE)
-		return (scene->gm.matmode == GAME_MAT_GLSL && !BKE_scene_use_new_shading_nodes(scene));
+		return (!BKE_scene_use_new_shading_nodes(scene));
 	else if (v3d->drawtype == OB_MATERIAL && dt > OB_SOLID)
 		return true;
 	else
@@ -4061,10 +4061,6 @@ static void draw_mesh_fancy(Scene *scene, ARegion *ar, View3D *v3d, RegionView3D
 			else
 				dm->drawFacesGLSL(dm, GPU_object_material_bind);
 
-#if 0 /* XXX */
-			if (BKE_bproperty_object_get(ob, "Text"))
-				draw_mesh_text(ob, 1);
-#endif
 			GPU_object_material_unbind();
 
 			glFrontFace(GL_CCW);
diff --git a/source/blender/editors/space_view3d/space_view3d.c b/source/blender/editors/space_view3d/space_view3d.c
index 075b1fa..5374169 100644
--- a/source/blender/editors/space_view3d/space_view3d.c
+++ b/source/blender/editors/space_view3d/space_view3d.c
@@ -932,9 +932,7 @@ static void view3d_main_region_listener(bScreen *sc, ScrArea *sa, ARegion *ar, w
 					Object *ob = OBACT;
 					if ((v3d->drawtype == OB_MATERIAL) ||
 					    (ob && (ob->mode == OB_MODE_TEXTURE_PAINT)) ||
-					    (v3d->drawtype == OB_TEXTURE &&
-					     (scene->gm.matmode == GAME_MAT_GLSL ||
-					      BKE_scene_use_new_shading_nodes(scene))) ||
+					    (v3d->drawtype == OB_TEXTURE) ||
 					    !DEG_depsgraph_use_legacy())
 #endif
 					{
@@ -959,7 +957,7 @@ static void view3d_main_region_listener(bScreen *sc, ScrArea *sa, ARegion *ar, w
 			switch (wmn->data) {
 				case ND_LIGHTING:
 					if ((v3d->drawtype == OB_MATERIAL) ||
-					    (v3d->drawtype == OB_TEXTURE && (scene->gm.matmode == GAME_MAT_GLSL)) ||
+					    (v3d->drawtype == OB_TEXTURE) ||
 					    !DEG_depsgraph_use_legacy())
 					{
 						ED_region_tag_redraw(ar);
diff --git a/source/blender/editors/space_view3d/view3d_draw.c b/source/blender/editors/space_view3d/view3d_draw.c
index f23e587..116f4cd 100644
--- a/source/blender/editors/space_view3d/view3d_draw.c
+++ b/source/blender/editors/space_view3d/view3d_draw.c
@@ -97,6 +97,7 @@
 
 #include "GPU_draw.h"
 #include "GPU_framebuffer.h"
+#include "GPU_shader.h"
 #include "GPU_material.h"
 #include "GPU_compositing.h"
 #include "GPU_extensions.h"
@@ -1389,7 +1390,7 @@ static void backdrawview3d(Scene *scene, wmWindow *win, ARegion *ar, View3D *v3d
 		}
 
 		if (!rv3d->gpuoffscreen) {
-			rv3d->gpuoffscreen = GPU_offscreen_create(w, h, 0, error);
+			rv3d->gpuoffscreen = GPU_offscreen_create(w, h, 0, GPU_HDR_NONE, GPU_OFFSCREEN_DEPTH_COMPARE, error);
 
 			if (!rv3d->gpuoffscreen)
 				fprintf(stderr, "Failed to create offscreen selection buffer for multisample: %s\n", error);
@@ -2563,6 +2564,7 @@ static void gpu_update_lamps_shadows_world(Scene *scene, View3D *v3d)
 		int drawtype, lay, winsize, flag2 = v3d->flag2;
 		ARegion ar = {NULL};
 		RegionView3D rv3d = {{{0}}};
+		bool vsm = GPU_lamp_shadow_buffer_type(shadow->lamp) == LA_SHADMAP_VARIANCE;
 		
 		drawtype = v3d->drawtype;
 		lay = v3d->lay;
@@ -2571,7 +2573,10 @@ static void gpu_update_lamps_shadows_world(Scene *scene, View3D *v3d)
 		v3d->lay &= GPU_lamp_shadow_layer(shadow->lamp);
 		v3d->flag2 &= ~(V3D_SOLID_TEX | V3D_SHOW_SOLID_MATCAP);
 		v3d->flag2 |= V3D_RENDER_OVERRIDE | V3D_RENDER_SHADOW;
-		
+
+		if (vsm) {
+			GPU_shader_bind(GPU_shader_get_builtin_shader(GPU_SHADER_VSM_STORE));
+		}
 		GPU_lamp_shadow_buffer_bind(shadow->lamp, viewmat, &winsize, winmat);
 
 		ar.regiondata = &rv3d;
@@ -2588,6 +2593,10 @@ static void gpu_update_lamps_shadows_world(Scene *scene, View3D *v3d)
 		            scene, v3d, &ar, winsize, winsize, viewmat, winmat,
 		            false, false, true,
 		            NULL, NULL, NULL, NULL);
+
+		if (vsm) {
+			GPU_shader_unbind();
+		}
 		GPU_lamp_shadow_buffer_unbind(shadow->lamp);
 		
 		v3d->drawtype = drawtype;
@@ -2604,6 +2613,7 @@ static void gpu_update_lamps_shadows_world(Scene *scene, View3D *v3d)
 		GPU_horizon_update_color(&world->horr);
 		GPU_ambient_update_color(&world->ambr);
 		GPU_zenith_update_color(&world->zenr);
+		GPU_update_exposure_range(world->exp, world->range);
 	}
 }
 
@@ -2624,7 +2634,7 @@ CustomDataMask ED_view3d_datamask(const Scene *scene, const View3D *v3d)
 				mask |= CD_MASK_ORCO;
 		}
 		else {
-			if ((scene->gm.matmode == GAME_MAT_GLSL && drawtype == OB_TEXTURE) || 
+			if ((drawtype == OB_TEXTURE) || 
 			    (drawtype == OB_MATERIAL))
 			{
 				mask |= CD_MASK_ORCO;
@@ -2996,9 +3006,9 @@ static void view3d_main_region_clear(Scene *scene, View3D *v3d, ARegion *ar)
 		RegionView3D *rv3d = ar->regiondata;
 		GPUMaterial *gpumat = GPU_material_world(scene, scene->world);
 
-		/* calculate full shader for background */
-		GPU_material_bind(gpumat, 1, 1, 1.0, false, rv3d->viewmat, rv3d->viewinv, rv3d->viewcamtexcofac, (v3d->scenelock != 0));
-		
+			/* calculate full shader for background */
+		GPU_material_bind(gpumat, 1, 1, 1.0, true, rv3d->viewmat, rv3d->viewinv, rv3d->viewcamtexcofac, (v3d->scenelock != 0));
+
 		bool material_not_bound = !GPU_material_bound(gpumat);
 
 		if (material_not_bound) {
@@ -3207,7 +3217,7 @@ ImBuf *ED_view3d_draw_offscreen_imbuf(
 
 	if (own_ofs) {
 		/* bind */
-		ofs = GPU_offscreen_create(sizex, sizey, full_samples ? 0 : samples, err_out);
+		ofs = GPU_offscreen_create(sizex, sizey, full_samples ? 0 : samples, GPU_HDR_NONE, GPU_OFFSCREEN_DEPTH_COMPARE, err_out);
 		if (ofs == NULL) {
 			return NULL;
 		}
diff --git a/source/blender/editors/space_view3d/view3d_view.c b/source/blender/editors/space_view3d/view3d_view.c
index 8582952..2068f14 100644
--- a/source/blender/editors/space_view3d/view3d_view.c
+++ b/source/blender/editors/space_view3d/view3d_view.c
@@ -69,7 +69,7 @@
 
 #  include "GPU_draw.h"
 
-#  include "BL_System.h"
+#  include "LA_SystemCommandLine.h"
 #endif
 
 
@@ -1645,20 +1645,13 @@ static void game_set_commmandline_options(GameData *gm)
 		test = (gm->flag & GAME_ENABLE_ALL_FRAMES);
 		SYS_WriteCommandLineInt(syshandle, "fixedtime", test);
 
-		test = (gm->flag & GAME_ENABLE_ANIMATION_RECORD);
-		SYS_WriteCommandLineInt(syshandle, "animation_record", test);
-
 		test = (gm->flag & GAME_IGNORE_DEPRECATION_WARNINGS);
 		SYS_WriteCommandLineInt(syshandle, "ignore_deprecation_warnings", test);
 
-		test = (gm->matmode == GAME_MAT_MULTITEX);
-		SYS_WriteCommandLineInt(syshandle, "blender_material", test);
-		test = (gm->matmode == GAME_MAT_GLSL);
-		SYS_WriteCommandLineInt(syshandle, "blender_glsl_material", test);
-		test = (gm->flag & GAME_DISPLAY_LISTS);
-		SYS_WriteCommandLineInt(syshandle, "displaylists", test);
-
-
+		test = (gm->flag & GAME_SHOW_BOUNDING_BOX);
+		SYS_WriteCommandLineInt(syshandle, "show_bounding_box", test);
+		test = (gm->flag & GAME_SHOW_ARMATURES);
+		SYS_WriteCommandLineInt(syshandle, "show_armatures", test);
 	}
 }
 
@@ -1743,8 +1736,7 @@ static int game_engine_exec(bContext *C, wmOperator *op)
 	game_set_commmandline_options(&startscene->gm);
 
 	if ((rv3d->persp == RV3D_CAMOB) &&
-	    (startscene->gm.framing.type == SCE_GAMEFRAMING_BARS) &&
-	    (startscene->gm.stereoflag != STEREO_DOME))
+	    (startscene->gm.framing.type == SCE_GAMEFRAMING_BARS))
 	{
 		/* Letterbox */
 		rctf cam_framef;
diff --git a/source/blender/gpu/CMakeLists.txt b/source/blender/gpu/CMakeLists.txt
index 8885209..2c4d8b6 100644
--- a/source/blender/gpu/CMakeLists.txt
+++ b/source/blender/gpu/CMakeLists.txt
@@ -72,6 +72,8 @@ set(SRC
 	shaders/gpu_shader_sep_gaussian_blur_frag.glsl
 	shaders/gpu_shader_sep_gaussian_blur_vert.glsl
 	shaders/gpu_shader_basic_frag.glsl
+	shaders/gpu_shader_basic_instancing_frag.glsl
+	shaders/gpu_shader_basic_instancing_vert.glsl
 	shaders/gpu_shader_basic_vert.glsl
 	shaders/gpu_shader_basic_geom.glsl
 	shaders/gpu_shader_vertex.glsl
@@ -107,8 +109,12 @@ data_to_c_simple(shaders/gpu_shader_material.glsl SRC)
 data_to_c_simple(shaders/gpu_shader_sep_gaussian_blur_frag.glsl SRC)
 data_to_c_simple(shaders/gpu_shader_sep_gaussian_blur_vert.glsl SRC)
 data_to_c_simple(shaders/gpu_shader_basic_frag.glsl SRC)
+data_to_c_simple(shaders/gpu_shader_basic_instancing_frag.glsl SRC)
+data_to_c_simple(shaders/gpu_shader_basic_instancing_vert.glsl SRC)
 data_to_c_simple(shaders/gpu_shader_basic_vert.glsl SRC)
 data_to_c_simple(shaders/gpu_shader_basic_geom.glsl SRC)
+data_to_c_simple(shaders/gpu_shader_frame_buffer_frag.glsl SRC)
+data_to_c_simple(shaders/gpu_shader_frame_buffer_vert.glsl SRC)
 data_to_c_simple(shaders/gpu_shader_vertex.glsl SRC)
 data_to_c_simple(shaders/gpu_shader_vertex_world.glsl SRC)
 data_to_c_simple(shaders/gpu_shader_vsm_store_frag.glsl SRC)
@@ -122,6 +128,7 @@ data_to_c_simple(shaders/gpu_shader_fx_dof_hq_vert.glsl SRC)
 data_to_c_simple(shaders/gpu_shader_fx_dof_hq_geo.glsl SRC)
 data_to_c_simple(shaders/gpu_shader_fx_depth_resolve.glsl SRC)
 data_to_c_simple(shaders/gpu_shader_fx_lib.glsl SRC)
+data_to_c_simple(shaders/gpu_shader_lib.glsl SRC)
 
 if(WITH_GAMEENGINE)
 	add_definitions(-DWITH_GAMEENGINE)
diff --git a/source/blender/gpu/GPU_draw.h b/source/blender/gpu/GPU_draw.h
index 90b65af..97beca9 100644
--- a/source/blender/gpu/GPU_draw.h
+++ b/source/blender/gpu/GPU_draw.h
@@ -101,15 +101,6 @@ int GPU_scene_object_lights(
         struct Scene *scene, struct Object *ob,
         int lay, float viewmat[4][4], int ortho);
 
-/* Text render
- * - based on moving uv coordinates */
-
-void GPU_render_text(
-        struct MTexPoly *mtexpoly, int mode,
-        const char *textstr, int textlen, unsigned int *col,
-        const float *v_quad[4], const float *uv_quad[4],
-        int glattrib);
-
 /* Mipmap settings
  * - these will free textures on changes */
 
diff --git a/source/blender/gpu/GPU_framebuffer.h b/source/blender/gpu/GPU_framebuffer.h
index 2719b8f..5da4adb 100644
--- a/source/blender/gpu/GPU_framebuffer.h
+++ b/source/blender/gpu/GPU_framebuffer.h
@@ -36,9 +36,11 @@
 extern "C" {
 #endif
 
+#include "GPU_texture.h"
+
 typedef struct GPUFrameBuffer GPUFrameBuffer;
+typedef struct GPURenderBuffer GPURenderBuffer;
 typedef struct GPUOffScreen GPUOffScreen;
-struct GPUTexture;
 
 /* GPU Framebuffer
  * - this is a wrapper for an OpenGL framebuffer object (FBO). in practice
@@ -51,33 +53,67 @@ void GPU_texture_bind_as_framebuffer(struct GPUTexture *tex);
 
 GPUFrameBuffer *GPU_framebuffer_create(void);
 int GPU_framebuffer_texture_attach(GPUFrameBuffer *fb, struct GPUTexture *tex, int slot, char err_out[256]);
+int GPU_framebuffer_texture_attach_target(GPUFrameBuffer *fb, struct GPUTexture *tex, int target, int slot, char err_out[256]);
 void GPU_framebuffer_texture_detach(struct GPUTexture *tex);
+void GPU_framebuffer_texture_detach_target(GPUTexture *tex, int target);
 void GPU_framebuffer_slots_bind(GPUFrameBuffer *fb, int slot);
 void GPU_framebuffer_texture_unbind(GPUFrameBuffer *fb, struct GPUTexture *tex);
 void GPU_framebuffer_free(GPUFrameBuffer *fb);
 bool GPU_framebuffer_check_valid(GPUFrameBuffer *fb, char err_out[256]);
 
+int GPU_framebuffer_renderbuffer_attach(GPUFrameBuffer *fb, GPURenderBuffer *rb, int slot, char err_out[256]);
+void GPU_framebuffer_renderbuffer_detach(GPURenderBuffer *rb);
+
 void GPU_framebuffer_bind_no_save(GPUFrameBuffer *fb, int slot);
+void GPU_framebuffer_bind_simple(GPUFrameBuffer *fb);
 
 bool GPU_framebuffer_bound(GPUFrameBuffer *fb);
 
 void GPU_framebuffer_restore(void);
 void GPU_framebuffer_blur(
         GPUFrameBuffer *fb, struct GPUTexture *tex,
-        GPUFrameBuffer *blurfb, struct GPUTexture *blurtex);
+        GPUFrameBuffer *blurfb, struct GPUTexture *blurtex, float sharpness);
+
+typedef enum GPURenderBufferType {
+	GPU_RENDERBUFFER_COLOR = 0,
+	GPU_RENDERBUFFER_DEPTH = 1,
+} GPURenderBufferType;
+
+GPURenderBuffer *GPU_renderbuffer_create(int width, int height, int samples, GPUHDRType hdrtype, GPURenderBufferType type, char err_out[256]);
+void GPU_renderbuffer_free(GPURenderBuffer *rb);
+GPUFrameBuffer *GPU_renderbuffer_framebuffer(GPURenderBuffer *rb);
+int GPU_renderbuffer_framebuffer_attachment(GPURenderBuffer *rb);
+void GPU_renderbuffer_framebuffer_set(GPURenderBuffer *rb, GPUFrameBuffer *fb, int attachement);
+int GPU_renderbuffer_bindcode(const GPURenderBuffer *rb);
+bool GPU_renderbuffer_depth(const GPURenderBuffer *rb);
+int GPU_renderbuffer_width(const GPURenderBuffer *rb);
+int GPU_renderbuffer_height(const GPURenderBuffer *rb);
+
 
 /* GPU OffScreen
  * - wrapper around framebuffer and texture for simple offscreen drawing
  * - changes size if graphics card can't support it */
 
-GPUOffScreen *GPU_offscreen_create(int width, int height, int samples, char err_out[256]);
+typedef enum GPUOffScreenMode {
+	GPU_OFFSCREEN_MODE_NONE = 0,
+	GPU_OFFSCREEN_RENDERBUFFER_COLOR = 1 << 0,
+	GPU_OFFSCREEN_RENDERBUFFER_DEPTH = 1 << 1,
+	GPU_OFFSCREEN_DEPTH_COMPARE = 1 << 2,
+} GPUOffScreenMode;
+
+GPUOffScreen *GPU_offscreen_create(int width, int height, int samples, GPUHDRType hdrtype, int mode, char err_out[256]);
 void GPU_offscreen_free(GPUOffScreen *ofs);
 void GPU_offscreen_bind(GPUOffScreen *ofs, bool save);
+void GPU_offscreen_bind_simple(GPUOffScreen *ofs);
 void GPU_offscreen_unbind(GPUOffScreen *ofs, bool restore);
 void GPU_offscreen_read_pixels(GPUOffScreen *ofs, int type, void *pixels);
+void GPU_offscreen_blit(GPUOffScreen *srcofs, GPUOffScreen *dstofs, bool color, bool depth);
 int GPU_offscreen_width(const GPUOffScreen *ofs);
 int GPU_offscreen_height(const GPUOffScreen *ofs);
+int GPU_offscreen_samples(const GPUOffScreen *ofs);
 int GPU_offscreen_color_texture(const GPUOffScreen *ofs);
+GPUTexture *GPU_offscreen_texture(const GPUOffScreen *ofs);
+GPUTexture *GPU_offscreen_depth_texture(const GPUOffScreen *ofs);
 
 #ifdef __cplusplus
 }
diff --git a/source/blender/gpu/GPU_material.h b/source/blender/gpu/GPU_material.h
index 0d92d22..340399c 100644
--- a/source/blender/gpu/GPU_material.h
+++ b/source/blender/gpu/GPU_material.h
@@ -98,6 +98,14 @@ typedef enum GPUBuiltin {
 	GPU_PARTICLE_ANG_VELOCITY = (1 << 12),
 	GPU_LOC_TO_VIEW_MATRIX =    (1 << 13),
 	GPU_INVERSE_LOC_TO_VIEW_MATRIX = (1 << 14),
+	GPU_INSTANCING_MATRIX                     = (1 << 15),
+	GPU_INSTANCING_INVERSE_MATRIX             = (1 << 16),
+	GPU_INSTANCING_LOC_TO_VIEW_MATRIX         = (1 << 17),
+	GPU_INSTANCING_INVERSE_LOC_TO_VIEW_MATRIX = (1 << 18),
+	GPU_INSTANCING_COLOR           = (1 << 19),
+	GPU_INSTANCING_COLOR_ATTRIB    = (1 << 20),
+	GPU_INSTANCING_MATRIX_ATTRIB   = (1 << 21),
+	GPU_INSTANCING_POSITION_ATTRIB = (1 << 22),
 } GPUBuiltin;
 
 typedef enum GPUOpenGLBuiltin {
@@ -140,6 +148,8 @@ typedef struct GPUNodeStack {
 #define GPU_DYNAMIC_GROUP_MIST     0x00050000
 #define GPU_DYNAMIC_GROUP_WORLD    0x00060000
 #define GPU_DYNAMIC_GROUP_MAT      0x00070000
+#define GPU_DYNAMIC_GROUP_TEX      0x00080000
+#define GPU_DYNAMIC_GROUP_TEX_UV   0x00090000
 
 typedef enum GPUDynamicType {
 
@@ -160,12 +170,12 @@ typedef enum GPUDynamicType {
 	GPU_DYNAMIC_LAMP_DYNPERSMAT      = 4  | GPU_DYNAMIC_GROUP_LAMP,
 	GPU_DYNAMIC_LAMP_DYNENERGY       = 5  | GPU_DYNAMIC_GROUP_LAMP,
 	GPU_DYNAMIC_LAMP_DYNCOL          = 6  | GPU_DYNAMIC_GROUP_LAMP,
-	GPU_DYNAMIC_LAMP_DISTANCE        = 7  | GPU_DYNAMIC_GROUP_LAMP,
-	GPU_DYNAMIC_LAMP_ATT1            = 8  | GPU_DYNAMIC_GROUP_LAMP,
-	GPU_DYNAMIC_LAMP_ATT2            = 9  | GPU_DYNAMIC_GROUP_LAMP,
-	GPU_DYNAMIC_LAMP_SPOTSIZE        = 10 | GPU_DYNAMIC_GROUP_LAMP,
-	GPU_DYNAMIC_LAMP_SPOTBLEND       = 11 | GPU_DYNAMIC_GROUP_LAMP,
-	GPU_DYNAMIC_LAMP_SPOTSCALE       = 12 | GPU_DYNAMIC_GROUP_LAMP,
+	GPU_DYNAMIC_LAMP_DYNSPOTSCALE    = 7  | GPU_DYNAMIC_GROUP_LAMP,
+	GPU_DYNAMIC_LAMP_DISTANCE        = 8  | GPU_DYNAMIC_GROUP_LAMP,
+	GPU_DYNAMIC_LAMP_ATT1            = 9  | GPU_DYNAMIC_GROUP_LAMP,
+	GPU_DYNAMIC_LAMP_ATT2            = 10 | GPU_DYNAMIC_GROUP_LAMP,
+	GPU_DYNAMIC_LAMP_SPOTSIZE        = 11 | GPU_DYNAMIC_GROUP_LAMP,
+	GPU_DYNAMIC_LAMP_SPOTBLEND       = 12 | GPU_DYNAMIC_GROUP_LAMP,
 	GPU_DYNAMIC_LAMP_COEFFCONST      = 13 | GPU_DYNAMIC_GROUP_LAMP,
 	GPU_DYNAMIC_LAMP_COEFFLIN        = 14 | GPU_DYNAMIC_GROUP_LAMP,
 	GPU_DYNAMIC_LAMP_COEFFQUAD       = 15 | GPU_DYNAMIC_GROUP_LAMP,
@@ -184,6 +194,8 @@ typedef enum GPUDynamicType {
 	GPU_DYNAMIC_HORIZON_COLOR        = 1  | GPU_DYNAMIC_GROUP_WORLD,
 	GPU_DYNAMIC_AMBIENT_COLOR        = 2  | GPU_DYNAMIC_GROUP_WORLD,
 	GPU_DYNAMIC_ZENITH_COLOR         = 3  | GPU_DYNAMIC_GROUP_WORLD,
+	GPU_DYNAMIC_WORLD_LINFAC         = 4  | GPU_DYNAMIC_GROUP_WORLD,
+	GPU_DYNAMIC_WORLD_LOGFAC         = 5  | GPU_DYNAMIC_GROUP_WORLD,
 
 	GPU_DYNAMIC_MAT_DIFFRGB          = 1  | GPU_DYNAMIC_GROUP_MAT,
 	GPU_DYNAMIC_MAT_REF              = 2  | GPU_DYNAMIC_GROUP_MAT,
@@ -193,17 +205,39 @@ typedef enum GPUDynamicType {
 	GPU_DYNAMIC_MAT_EMIT             = 6  | GPU_DYNAMIC_GROUP_MAT,
 	GPU_DYNAMIC_MAT_AMB              = 7  | GPU_DYNAMIC_GROUP_MAT,
 	GPU_DYNAMIC_MAT_ALPHA            = 8  | GPU_DYNAMIC_GROUP_MAT,
-	GPU_DYNAMIC_MAT_MIR              = 9  | GPU_DYNAMIC_GROUP_MAT
+	GPU_DYNAMIC_MAT_MIR              = 9  | GPU_DYNAMIC_GROUP_MAT,
+	GPU_DYNAMIC_MAT_SPECTRA          = 10 | GPU_DYNAMIC_GROUP_MAT,
+
+	GPU_DYNAMIC_TEX_COLINTENS        = 1  | GPU_DYNAMIC_GROUP_TEX,
+	GPU_DYNAMIC_TEX_COLFAC           = 2  | GPU_DYNAMIC_GROUP_TEX,
+	GPU_DYNAMIC_TEX_ALPHA            = 3  | GPU_DYNAMIC_GROUP_TEX,
+	GPU_DYNAMIC_TEX_SPECINTENS       = 4  | GPU_DYNAMIC_GROUP_TEX,
+	GPU_DYNAMIC_TEX_SPECFAC          = 5  | GPU_DYNAMIC_GROUP_TEX,
+	GPU_DYNAMIC_TEX_HARDNESS         = 6  | GPU_DYNAMIC_GROUP_TEX,
+	GPU_DYNAMIC_TEX_EMIT             = 7  | GPU_DYNAMIC_GROUP_TEX,
+	GPU_DYNAMIC_TEX_MIRROR           = 8  | GPU_DYNAMIC_GROUP_TEX,
+	GPU_DYNAMIC_TEX_NORMAL           = 9  | GPU_DYNAMIC_GROUP_TEX,
+	GPU_DYNAMIC_TEX_PARALLAXBUMP     = 10 | GPU_DYNAMIC_GROUP_TEX,
+	GPU_DYNAMIC_TEX_PARALLAXSTEP     = 11 | GPU_DYNAMIC_GROUP_TEX,
+	GPU_DYNAMIC_TEX_LODBIAS          = 12 | GPU_DYNAMIC_GROUP_TEX,
+	GPU_DYNAMIC_TEX_IOR              = 13 | GPU_DYNAMIC_GROUP_TEX,
+	GPU_DYNAMIC_TEX_REFRRATIO        = 14 | GPU_DYNAMIC_GROUP_TEX,
+
+	GPU_DYNAMIC_TEX_UVOFFSET         = 1  | GPU_DYNAMIC_GROUP_TEX_UV,
+	GPU_DYNAMIC_TEX_UVSIZE           = 2  | GPU_DYNAMIC_GROUP_TEX_UV,
+	GPU_DYNAMIC_TEX_UVROTATION       = 3  | GPU_DYNAMIC_GROUP_TEX_UV
 } GPUDynamicType;
 
 GPUNodeLink *GPU_attribute(CustomDataType type, const char *name);
 GPUNodeLink *GPU_uniform(float *num);
 GPUNodeLink *GPU_dynamic_uniform(float *num, GPUDynamicType dynamictype, void *data);
+GPUNodeLink *GPU_select_uniform(float *num, GPUDynamicType dynamictype, void *data, struct Material *material);
 GPUNodeLink *GPU_image(struct Image *ima, struct ImageUser *iuser, bool is_data);
 GPUNodeLink *GPU_cube_map(struct Image *ima, struct ImageUser *iuser, bool is_data);
 GPUNodeLink *GPU_image_preview(struct PreviewImage *prv);
 GPUNodeLink *GPU_texture(int size, float *pixels);
 GPUNodeLink *GPU_dynamic_texture(struct GPUTexture *tex, GPUDynamicType dynamictype, void *data);
+GPUNodeLink *GPU_dynamic_texture_ptr(struct GPUTexture **tex, GPUDynamicType dynamictype, void *data);
 GPUNodeLink *GPU_builtin(GPUBuiltin builtin);
 GPUNodeLink *GPU_opengl_builtin(GPUOpenGLBuiltin builtin);
 void GPU_node_link_set_type(GPUNodeLink *link, GPUType type);
@@ -218,7 +252,7 @@ GPUBlendMode GPU_material_alpha_blend(GPUMaterial *material, float obcol[4]);
 /* High level functions to create and use GPU materials */
 GPUMaterial *GPU_material_world(struct Scene *scene, struct World *wo);
 
-GPUMaterial *GPU_material_from_blender(struct Scene *scene, struct Material *ma, bool use_opensubdiv);
+GPUMaterial *GPU_material_from_blender(struct Scene *scene, struct Material *ma, bool use_opensubdiv, bool is_instancing);
 GPUMaterial *GPU_material_matcap(struct Scene *scene, struct Material *ma, bool use_opensubdiv);
 void GPU_material_free(struct ListBase *gpumaterial);
 
@@ -338,6 +372,7 @@ void GPU_mist_update_values(int type, float start, float dist, float inten, floa
 void GPU_horizon_update_color(float color[3]);
 void GPU_ambient_update_color(float color[3]);
 void GPU_zenith_update_color(float color[3]);
+void GPU_update_exposure_range(float exp, float range);
 
 struct GPUParticleInfo
 {
@@ -353,6 +388,10 @@ void GPU_material_update_fvar_offset(GPUMaterial *gpu_material,
                                      struct DerivedMesh *dm);
 #endif
 
+/* Instancing material */
+void GPU_material_bind_instancing_attrib(GPUMaterial *material, void *matrixoffset, void *positionoffset, void *coloroffset, unsigned int stride);
+void GPU_material_unbind_instancing_attrib(GPUMaterial *material);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/source/blender/gpu/GPU_shader.h b/source/blender/gpu/GPU_shader.h
index 5b94db6..34723ba 100644
--- a/source/blender/gpu/GPU_shader.h
+++ b/source/blender/gpu/GPU_shader.h
@@ -47,6 +47,8 @@ enum {
 	GPU_SHADER_FLAGS_NONE = 0,
 	GPU_SHADER_FLAGS_SPECIAL_OPENSUBDIV = (1 << 0),
 	GPU_SHADER_FLAGS_NEW_SHADING        = (1 << 1),
+	GPU_SHADER_FLAGS_SPECIAL_INSTANCING = (1 << 2),
+	GPU_SHADER_FLAGS_SPECIAL_RESET_LINE = (1 << 3),
 };
 
 GPUShader *GPU_shader_create(
@@ -64,11 +66,14 @@ GPUShader *GPU_shader_create_ex(
         const char *defines,
         int input, int output, int number,
         const int flags);
+char *GPU_shader_validate(GPUShader *shader);
 void GPU_shader_free(GPUShader *shader);
 
 void GPU_shader_bind(GPUShader *shader);
 void GPU_shader_unbind(void);
 
+int GPU_shader_program(GPUShader *shader);
+
 void *GPU_shader_get_interface(GPUShader *shader);
 void GPU_shader_set_interface(GPUShader *shader, void *interface);
 int GPU_shader_get_uniform(GPUShader *shader, const char *name);
@@ -79,17 +84,27 @@ void GPU_shader_uniform_vector_int(GPUShader *shader, int location, int length,
 
 void GPU_shader_uniform_texture(GPUShader *shader, int location, struct GPUTexture *tex);
 void GPU_shader_uniform_int(GPUShader *shader, int location, int value);
+void GPU_shader_uniform_float(GPUShader *shader, int location, float value);
 void GPU_shader_geometry_stage_primitive_io(GPUShader *shader, int input, int output, int number);
 
 int GPU_shader_get_attribute(GPUShader *shader, const char *name);
+void GPU_shader_bind_attribute(GPUShader *shader, int location, const char *name);
+
+void GPU_shader_bind_instancing_attrib(GPUShader *shader, void *matrixoffset, void *positionoffset, unsigned int stride);
+void GPU_shader_unbind_instancing_attrib(GPUShader *shader);
 
 /* Builtin/Non-generated shaders */
 typedef enum GPUBuiltinShader {
-	GPU_SHADER_VSM_STORE         = 0,
-	GPU_SHADER_SEP_GAUSSIAN_BLUR = 1,
-	GPU_SHADER_SMOKE             = 2,
-	GPU_SHADER_SMOKE_FIRE        = 3,
-	GPU_SHADER_SMOKE_COBA        = 4,
+	GPU_SHADER_VSM_STORE            = 0,
+	GPU_SHADER_VSM_STORE_INSTANCING = 1,
+	GPU_SHADER_SEP_GAUSSIAN_BLUR    = 2,
+	GPU_SHADER_SMOKE                = 3,
+	GPU_SHADER_SMOKE_FIRE           = 4,
+	GPU_SHADER_SMOKE_COBA           = 5,
+	GPU_SHADER_INSTANCING           = 6,
+	GPU_SHADER_DRAW_FRAME_BUFFER	= 7,
+	GPU_SHADER_STEREO_STIPPLE       = 8,
+	GPU_SHADER_STEREO_ANAGLYPH      = 9,
 } GPUBuiltinShader;
 
 GPUShader *GPU_shader_get_builtin_shader(GPUBuiltinShader shader);
diff --git a/source/blender/gpu/GPU_texture.h b/source/blender/gpu/GPU_texture.h
index 756fe79..8652331 100644
--- a/source/blender/gpu/GPU_texture.h
+++ b/source/blender/gpu/GPU_texture.h
@@ -61,19 +61,27 @@ typedef enum GPUHDRType {
 	GPU_HDR_FULL_FLOAT = (1 << 1),
 } GPUHDRType;
 
+typedef enum GPUTextureMode {
+	GPU_TEXTURE_MODE_NONE = 0,
+	GPU_TEXTURE_DEPTH = 1 << 0,
+	GPU_TEXTURE_DEPTH_COMPARE = 1 << 1,
+} GPUTextureMode;
+
 GPUTexture *GPU_texture_create_1D(int w, const float *pixels, char err_out[256]);
 GPUTexture *GPU_texture_create_2D(int w, int h, const float *pixels, GPUHDRType hdr, char err_out[256]);
 GPUTexture *GPU_texture_create_3D(int w, int h, int depth, int channels, const float *fpixels);
-GPUTexture *GPU_texture_create_depth(int w, int h, char err_out[256]);
+GPUTexture *GPU_texture_create_depth(int w, int h, bool compare, char err_out[256]);
 GPUTexture *GPU_texture_create_vsm_shadow_map(int size, char err_out[256]);
 GPUTexture *GPU_texture_create_2D_procedural(int w, int h, const float *pixels, bool repeat, char err_out[256]);
 GPUTexture *GPU_texture_create_1D_procedural(int w, const float *pixels, char err_out[256]);
 GPUTexture *GPU_texture_create_2D_multisample(
         int w, int h, const float *pixels, GPUHDRType hdr, int samples, char err_out[256]);
-GPUTexture *GPU_texture_create_depth_multisample(int w, int h, int samples, char err_out[256]);
+GPUTexture *GPU_texture_create_depth_multisample(int w, int h, int samples, bool compare, char err_out[256]);
 GPUTexture *GPU_texture_from_blender(
         struct Image *ima, struct ImageUser *iuser, int textarget, bool is_data, double time, int mipmap);
 GPUTexture *GPU_texture_from_preview(struct PreviewImage *prv, int mipmap);
+GPUTexture **GPU_texture_global_depth_ptr(void);
+void GPU_texture_set_global_depth(GPUTexture *depthtex);
 void GPU_invalid_tex_init(void);
 void GPU_invalid_tex_bind(int mode);
 void GPU_invalid_tex_free(void);
@@ -81,12 +89,14 @@ void GPU_invalid_tex_free(void);
 void GPU_texture_free(GPUTexture *tex);
 
 void GPU_texture_ref(GPUTexture *tex);
+int GPU_texture_ref_count(GPUTexture *tex);
 
 void GPU_texture_bind(GPUTexture *tex, int number);
 void GPU_texture_unbind(GPUTexture *tex);
 int GPU_texture_bound_number(GPUTexture *tex);
 
-void GPU_texture_filter_mode(GPUTexture *tex, bool compare, bool use_filter);
+void GPU_texture_filter_mode(GPUTexture *tex, bool compare, bool use_filter, bool mipmap);
+void GPU_texture_generate_mipmap(GPUTexture *tex);
 
 struct GPUFrameBuffer *GPU_texture_framebuffer(GPUTexture *tex);
 int GPU_texture_framebuffer_attachment(GPUTexture *tex);
@@ -98,6 +108,9 @@ int GPU_texture_height(const GPUTexture *tex);
 int GPU_texture_depth(const GPUTexture *tex);
 int GPU_texture_opengl_bindcode(const GPUTexture *tex);
 
+void GPU_texture_set_opengl_bindcode(GPUTexture *tex, int bindcode);
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/source/blender/gpu/intern/gpu_codegen.c b/source/blender/gpu/intern/gpu_codegen.c
index 211394e..74e3c6e 100644
--- a/source/blender/gpu/intern/gpu_codegen.c
+++ b/source/blender/gpu/intern/gpu_codegen.c
@@ -375,7 +375,7 @@ static int codegen_input_has_texture(GPUInput *input)
 	else if (input->ima || input->prv)
 		return 1;
 	else
-		return input->tex != NULL;
+		return (input->tex != NULL || input->texptr != NULL);
 }
 
 const char *GPU_builtin_name(GPUBuiltin builtin)
@@ -410,6 +410,22 @@ const char *GPU_builtin_name(GPUBuiltin builtin)
 		return "unfparticlevel";
 	else if (builtin == GPU_PARTICLE_ANG_VELOCITY)
 		return "unfparticleangvel";
+	else if (builtin == GPU_INSTANCING_MATRIX)
+		return "varinstmat";
+	else if (builtin == GPU_INSTANCING_INVERSE_MATRIX)
+		return "varinstinvmat";
+	else if (builtin == GPU_INSTANCING_LOC_TO_VIEW_MATRIX)
+		return "varinstlocaltoviewmat";
+	else if (builtin == GPU_INSTANCING_INVERSE_LOC_TO_VIEW_MATRIX)
+		return "varinstinvlocaltoviewmat";
+	else if (builtin == GPU_INSTANCING_COLOR)
+		return "varinstcolor";
+	else if (builtin == GPU_INSTANCING_COLOR_ATTRIB)
+		return "ininstcolor";
+	else if (builtin == GPU_INSTANCING_MATRIX_ATTRIB)
+		return "ininstmatrix";
+	else if (builtin == GPU_INSTANCING_POSITION_ATTRIB)
+		return "ininstposition";
 	else
 		return "";
 }
@@ -470,6 +486,10 @@ static void codegen_set_unique_ids(ListBase *nodes)
 					/* input is user created texture, check tex pointer */
 					codegen_set_texid(bindhash, input, &texid, input->tex);
 				}
+				else if (input->texptr) {
+					/* input is user created texture, check tex pointer */
+					codegen_set_texid(bindhash, input, &texid, input->texptr);
+				}
 
 				/* make sure this pixel is defined exactly once */
 				if (input->source == GPU_SOURCE_TEX_PIXEL) {
@@ -731,7 +751,7 @@ static char *code_generate_fragment(ListBase *nodes, GPUOutput *output)
 	return code;
 }
 
-static char *code_generate_vertex(ListBase *nodes, const GPUMatType type)
+static char *code_generate_vertex(ListBase *nodes, const GPUMatType type, bool use_instancing)
 {
 	DynStr *ds = BLI_dynstr_new();
 	GPUNode *node;
@@ -787,9 +807,16 @@ static char *code_generate_vertex(ListBase *nodes, const GPUMatType type)
 #ifdef WITH_OPENSUBDIV
 					BLI_dynstr_appendf(ds, "#ifndef USE_OPENSUBDIV\n");
 #endif
-					BLI_dynstr_appendf(
-					        ds, "\tvar%d.xyz = normalize(gl_NormalMatrix * att%d.xyz);\n",
-					        input->attribid, input->attribid);
+					if (use_instancing) {
+						BLI_dynstr_appendf(
+							ds, "\tvar%d.xyz = normalize(gl_NormalMatrix * (att%d.xyz * %s));\n",
+							input->attribid, input->attribid, GPU_builtin_name(GPU_INSTANCING_MATRIX_ATTRIB));
+					}
+					else {
+						BLI_dynstr_appendf(
+							ds, "\tvar%d.xyz = normalize(gl_NormalMatrix * att%d.xyz);\n",
+							input->attribid, input->attribid);
+					}
 					BLI_dynstr_appendf(
 					        ds, "\tvar%d.w = att%d.w;\n",
 					        input->attribid, input->attribid);
@@ -975,15 +1002,16 @@ static void gpu_nodes_extract_dynamic_inputs(GPUPass *pass, ListBase *nodes)
 				continue;
 			}
 
-			if (input->ima || input->tex || input->prv)
+			if (input->ima || input->tex || input->prv || input->texptr) {
 				BLI_snprintf(input->shadername, sizeof(input->shadername), "samp%d", input->texid);
+			}
 			else
 				BLI_snprintf(input->shadername, sizeof(input->shadername), "unf%d", input->id);
 
 			/* pass non-dynamic uniforms to opengl */
 			extract = 0;
 
-			if (input->ima || input->tex || input->prv) {
+			if (input->ima || input->tex || input->prv || input->texptr) {
 				if (input->bindtex)
 					extract = 1;
 			}
@@ -1038,6 +1066,10 @@ void GPU_pass_bind(GPUPass *pass, double time, int mipmap)
 			GPU_texture_bind(input->tex, input->texid);
 			GPU_shader_uniform_texture(shader, input->shaderloc, input->tex);
 		}
+		else if (input->texptr && *input->texptr && input->bindtex) {
+			GPU_texture_bind(*input->texptr, input->texid);
+			GPU_shader_uniform_texture(shader, input->shaderloc, *input->texptr);
+		}
 	}
 }
 
@@ -1052,16 +1084,9 @@ void GPU_pass_update_uniforms(GPUPass *pass)
 
 	/* pass dynamic inputs to opengl, others were removed */
 	for (input = inputs->first; input; input = input->next) {
-		if (!(input->ima || input->tex || input->prv)) {
-			if (input->dynamictype == GPU_DYNAMIC_MAT_HARD) {
-				// The hardness is actually a short pointer, so we convert it here
-				float val = (float)(*(short *)input->dynamicvec);
-				GPU_shader_uniform_vector(shader, input->shaderloc, 1, 1, &val);
-			}
-			else {
-				GPU_shader_uniform_vector(shader, input->shaderloc, input->type, 1,
-					input->dynamicvec);
-			}
+		if (!(input->ima || input->tex || input->prv || input->texptr)) {
+			GPU_shader_uniform_vector(shader, input->shaderloc, input->type, 1,
+				input->dynamicvec);
 		}
 	}
 }
@@ -1078,6 +1103,9 @@ void GPU_pass_unbind(GPUPass *pass)
 	for (input = inputs->first; input; input = input->next) {
 		if (input->tex && input->bindtex)
 			GPU_texture_unbind(input->tex);
+		if (input->texptr && *input->texptr && input->bindtex) {
+			GPU_texture_unbind(*input->texptr);
+		}
 
 		if (input->ima || input->prv)
 			input->tex = NULL;
@@ -1183,6 +1211,18 @@ static void gpu_node_input_link(GPUNode *node, GPUNodeLink *link, const GPUType
 		input->dynamicdata = link->ptr2;
 		MEM_freeN(link);
 	}
+	else if (link->dynamictexptr) {
+		/* dynamic texture, GPUTexture is updated/deleted externally */
+		input->type = type;
+		input->source = GPU_SOURCE_TEX;
+
+		input->texptr = link->dynamictexptr;
+		input->textarget = GL_TEXTURE_2D;
+		input->textype = type;
+		input->dynamictex = true;
+		input->dynamicdata = link->ptr2;
+		MEM_freeN(link);
+	}
 	else if (link->texture) {
 		/* small texture created on the fly, like for colorbands */
 		input->type = GPU_VEC4;
@@ -1414,6 +1454,36 @@ GPUNodeLink *GPU_dynamic_uniform(float *num, GPUDynamicType dynamictype, void *d
 	return link;
 }
 
+GPUNodeLink *GPU_select_uniform(float *num, GPUDynamicType dynamictype, void *data, Material *material)
+{
+	bool dynamic = false;
+	if (GPU_DYNAMIC_GROUP_FROM_TYPE(dynamictype) == GPU_DYNAMIC_GROUP_MAT) {
+		dynamic = !(material->constflag & MA_CONSTANT_MATERIAL);
+	}
+	else if (GPU_DYNAMIC_GROUP_FROM_TYPE(dynamictype) == GPU_DYNAMIC_GROUP_LAMP) {
+		dynamic = !(material->constflag & MA_CONSTANT_LAMP);
+	}
+	else if (GPU_DYNAMIC_GROUP_FROM_TYPE(dynamictype) == GPU_DYNAMIC_GROUP_TEX) {
+		dynamic = !(material->constflag & MA_CONSTANT_TEXTURE);
+	}
+	else if (GPU_DYNAMIC_GROUP_FROM_TYPE(dynamictype) == GPU_DYNAMIC_GROUP_TEX_UV) {
+		dynamic = !(material->constflag & MA_CONSTANT_TEXTURE_UV);
+	}
+	else if (GPU_DYNAMIC_GROUP_FROM_TYPE(dynamictype) == GPU_DYNAMIC_GROUP_WORLD) {
+		dynamic = !(material->constflag & MA_CONSTANT_WORLD);
+	}
+	else if (GPU_DYNAMIC_GROUP_FROM_TYPE(dynamictype) == GPU_DYNAMIC_GROUP_MIST) {
+		dynamic = !(material->constflag & MA_CONSTANT_MIST);
+	}
+
+	if (dynamic) {
+		return GPU_dynamic_uniform(num, dynamictype, data);
+	}
+	else {
+		return GPU_uniform(num);
+	}
+}
+
 GPUNodeLink *GPU_image(Image *ima, ImageUser *iuser, bool is_data)
 {
 	GPUNodeLink *link = GPU_node_link_create();
@@ -1472,6 +1542,18 @@ GPUNodeLink *GPU_dynamic_texture(GPUTexture *tex, GPUDynamicType dynamictype, vo
 	return link;
 }
 
+GPUNodeLink *GPU_dynamic_texture_ptr(GPUTexture **tex, GPUDynamicType dynamictype, void *data)
+{
+	GPUNodeLink *link = GPU_node_link_create();
+
+	link->dynamic = true;
+	link->dynamictexptr = tex;
+	link->dynamictype = dynamictype;
+	link->ptr2 = data;
+
+	return link;
+}
+
 GPUNodeLink *GPU_builtin(GPUBuiltin builtin)
 {
 	GPUNodeLink *link = GPU_node_link_create();
@@ -1650,6 +1732,7 @@ GPUPass *GPU_generate_pass(
         GPUVertexAttribs *attribs, int *builtins,
         const GPUMatType type, const char *UNUSED(name),
         const bool use_opensubdiv,
+		const bool use_instancing,
         const bool use_new_shading)
 {
 	GPUShader *shader;
@@ -1671,7 +1754,7 @@ GPUPass *GPU_generate_pass(
 
 	/* generate code and compile with opengl */
 	fragmentcode = code_generate_fragment(nodes, outlink->output);
-	vertexcode = code_generate_vertex(nodes, type);
+	vertexcode = code_generate_vertex(nodes, type, use_instancing);
 	geometrycode = code_generate_geometry(nodes, use_opensubdiv);
 
 	int flags = GPU_SHADER_FLAGS_NONE;
@@ -1681,6 +1764,9 @@ GPUPass *GPU_generate_pass(
 	if (use_new_shading) {
 		flags |= GPU_SHADER_FLAGS_NEW_SHADING;
 	}
+	if (use_instancing) {
+		flags |= GPU_SHADER_FLAGS_SPECIAL_INSTANCING;
+	}
 	shader = GPU_shader_create_ex(vertexcode,
 	                              fragmentcode,
 	                              geometrycode,
diff --git a/source/blender/gpu/intern/gpu_codegen.h b/source/blender/gpu/intern/gpu_codegen.h
index 7af17f9..6268e88 100644
--- a/source/blender/gpu/intern/gpu_codegen.h
+++ b/source/blender/gpu/intern/gpu_codegen.h
@@ -102,6 +102,7 @@ struct GPUNodeLink {
 	int users;
 
 	struct GPUTexture *dynamictex;
+	struct GPUTexture **dynamictexptr;
 
 	GPUBuiltin builtin;
 	GPUOpenGLBuiltin oglbuiltin;
@@ -142,6 +143,7 @@ typedef struct GPUInput {
 	GPUDynamicType dynamictype;  /* origin of the dynamic uniform */
 	void *dynamicdata;           /* data source of the dynamic uniform */
 	struct GPUTexture *tex;      /* input texture, only set at runtime */
+	struct GPUTexture **texptr;
 	int shaderloc;               /* id from opengl */
 	char shadername[32];         /* name in shader */
 
@@ -174,6 +176,7 @@ GPUPass *GPU_generate_pass(ListBase *nodes, struct GPUNodeLink *outlink,
                            struct GPUVertexAttribs *attribs, int *builtin,
                            const GPUMatType type, const char *name,
                            const bool use_opensubdiv,
+						   const bool use_instancing,
                            const bool use_new_shading);
 
 struct GPUShader *GPU_pass_shader(GPUPass *pass);
diff --git a/source/blender/gpu/intern/gpu_compositing.c b/source/blender/gpu/intern/gpu_compositing.c
index 964c2b5..b35cbf9 100644
--- a/source/blender/gpu/intern/gpu_compositing.c
+++ b/source/blender/gpu/intern/gpu_compositing.c
@@ -442,7 +442,7 @@ bool GPU_fx_compositor_initialize_passes(
 			return false;
 		}
 
-		if (!(fx->depth_buffer = GPU_texture_create_depth(w, h, err_out))) {
+		if (!(fx->depth_buffer = GPU_texture_create_depth(w, h, true, err_out))) {
 			printf("%.256s\n", err_out);
 			cleanup_fx_gl_data(fx, true);
 			return false;
@@ -644,7 +644,7 @@ void GPU_fx_compositor_setup_XRay_pass(GPUFX *fx, bool do_xray)
 
 	if (do_xray) {
 		if (!fx->depth_buffer_xray &&
-		    !(fx->depth_buffer_xray = GPU_texture_create_depth(fx->gbuffer_dim[0], fx->gbuffer_dim[1], err_out)))
+		    !(fx->depth_buffer_xray = GPU_texture_create_depth(fx->gbuffer_dim[0], fx->gbuffer_dim[1], true, err_out)))
 		{
 			printf("%.256s\n", err_out);
 			cleanup_fx_gl_data(fx, true);
@@ -699,14 +699,14 @@ void GPU_fx_compositor_XRay_resolve(GPUFX *fx)
 		GPU_shader_bind(depth_resolve_shader);
 
 		GPU_texture_bind(fx->depth_buffer_xray, 0);
-		GPU_texture_filter_mode(fx->depth_buffer_xray, false, true);
+		GPU_texture_filter_mode(fx->depth_buffer_xray, false, true, false);
 		GPU_shader_uniform_texture(depth_resolve_shader, interface->depth_uniform, fx->depth_buffer_xray);
 
 		/* draw */
 		glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
 
 		/* disable bindings */
-		GPU_texture_filter_mode(fx->depth_buffer_xray, true, false);
+		GPU_texture_filter_mode(fx->depth_buffer_xray, true, false, false);
 		GPU_texture_unbind(fx->depth_buffer_xray);
 
 		GPU_shader_unbind();
@@ -821,7 +821,7 @@ bool GPU_fx_do_composite_pass(
 			GPU_shader_uniform_texture(ssao_shader, interface->color_uniform, src);
 
 			GPU_texture_bind(fx->depth_buffer, numslots++);
-			GPU_texture_filter_mode(fx->depth_buffer, false, true);
+			GPU_texture_filter_mode(fx->depth_buffer, false, true, false);
 			GPU_shader_uniform_texture(ssao_shader, interface->depth_uniform, fx->depth_buffer);
 
 			GPU_texture_bind(fx->jitter_buffer, numslots++);
@@ -837,7 +837,7 @@ bool GPU_fx_do_composite_pass(
 
 			/* disable bindings */
 			GPU_texture_unbind(src);
-			GPU_texture_filter_mode(fx->depth_buffer, true, false);
+			GPU_texture_filter_mode(fx->depth_buffer, true, false, false);
 			GPU_texture_unbind(fx->depth_buffer);
 			GPU_texture_unbind(fx->jitter_buffer);
 			GPU_texture_unbind(fx->ssao_spiral_samples_tex);
@@ -913,12 +913,12 @@ bool GPU_fx_do_composite_pass(
 				GPU_shader_uniform_vector(dof_shader_pass1, interface->invrendertargetdim_uniform, 2, 1, invrendertargetdim);
 
 				GPU_texture_bind(fx->depth_buffer, numslots++);
-				GPU_texture_filter_mode(fx->depth_buffer, false, false);
+				GPU_texture_filter_mode(fx->depth_buffer, false, false, false);
 				GPU_shader_uniform_texture(dof_shader_pass1, interface->depth_uniform, fx->depth_buffer);
 
 				GPU_texture_bind(src, numslots++);
 				/* disable filtering for the texture so custom downsample can do the right thing */
-				GPU_texture_filter_mode(src, false, false);
+				GPU_texture_filter_mode(src, false, false, false);
 				GPU_shader_uniform_texture(dof_shader_pass2, interface->color_uniform, src);
 
 				/* target is the downsampled coc buffer */
@@ -932,9 +932,9 @@ bool GPU_fx_do_composite_pass(
 
 				glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
 				/* disable bindings */
-				GPU_texture_filter_mode(src, false, true);
+				GPU_texture_filter_mode(src, false, true, false);
 				GPU_texture_unbind(src);
-				GPU_texture_filter_mode(fx->depth_buffer, true, false);
+				GPU_texture_filter_mode(fx->depth_buffer, true, false, false);
 				GPU_texture_unbind(fx->depth_buffer);
 
 				GPU_framebuffer_texture_detach(fx->dof_half_downsampled_near);
@@ -965,7 +965,7 @@ bool GPU_fx_do_composite_pass(
 				GPU_texture_bind(fx->dof_half_downsampled_far, numslots++);
 				GPU_texture_bind(fx->dof_half_downsampled_near, numslots++);
 				GPU_shader_uniform_texture(dof_shader_pass2, interface->color_uniform, fx->dof_half_downsampled_far);
-				GPU_texture_filter_mode(fx->dof_half_downsampled_far, false, false);
+				GPU_texture_filter_mode(fx->dof_half_downsampled_far, false, false, false);
 
 				/* target is the downsampled coc buffer */
 				GPU_framebuffer_texture_attach(fx->gbuffer, fx->dof_far_blur, 0, NULL);
@@ -985,7 +985,7 @@ bool GPU_fx_do_composite_pass(
 				GPU_framebuffer_texture_detach(fx->dof_far_blur);
 
 				GPU_shader_uniform_texture(dof_shader_pass2, interface->color_uniform, fx->dof_half_downsampled_near);
-				GPU_texture_filter_mode(fx->dof_half_downsampled_near, false, false);
+				GPU_texture_filter_mode(fx->dof_half_downsampled_near, false, false, false);
 
 				selection[0] = 1.0f;
 				selection[1] = 0.0f;
@@ -1025,14 +1025,14 @@ bool GPU_fx_do_composite_pass(
 
 				GPU_texture_bind(fx->dof_near_blur, numslots++);
 				GPU_shader_uniform_texture(dof_shader_pass3, interface->near_uniform, fx->dof_near_blur);
-				GPU_texture_filter_mode(fx->dof_near_blur, false, true);
+				GPU_texture_filter_mode(fx->dof_near_blur, false, true, false);
 
 				GPU_texture_bind(fx->dof_far_blur, numslots++);
 				GPU_shader_uniform_texture(dof_shader_pass3, interface->far_uniform, fx->dof_far_blur);
-				GPU_texture_filter_mode(fx->dof_far_blur, false, true);
+				GPU_texture_filter_mode(fx->dof_far_blur, false, true, false);
 
 				GPU_texture_bind(fx->depth_buffer, numslots++);
-				GPU_texture_filter_mode(fx->depth_buffer, false, false);
+				GPU_texture_filter_mode(fx->depth_buffer, false, false, false);
 				GPU_shader_uniform_texture(dof_shader_pass3, interface->depth_uniform, fx->depth_buffer);
 
 				GPU_texture_bind(src, numslots++);
@@ -1047,7 +1047,7 @@ bool GPU_fx_do_composite_pass(
 				GPU_texture_unbind(fx->dof_near_blur);
 				GPU_texture_unbind(fx->dof_far_blur);
 				GPU_texture_unbind(src);
-				GPU_texture_filter_mode(fx->depth_buffer, true, false);
+				GPU_texture_filter_mode(fx->depth_buffer, true, false, false);
 				GPU_texture_unbind(fx->depth_buffer);
 
 				/* may not be attached, in that case this just returns */
@@ -1107,7 +1107,7 @@ bool GPU_fx_do_composite_pass(
 				GPU_shader_uniform_texture(dof_shader_pass1, interface->color_uniform, src);
 
 				GPU_texture_bind(fx->depth_buffer, numslots++);
-				GPU_texture_filter_mode(fx->depth_buffer, false, true);
+				GPU_texture_filter_mode(fx->depth_buffer, false, true, false);
 				GPU_shader_uniform_texture(dof_shader_pass1, interface->depth_uniform, fx->depth_buffer);
 
 				/* target is the downsampled coc buffer */
@@ -1118,7 +1118,7 @@ bool GPU_fx_do_composite_pass(
 				glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
 				/* disable bindings */
 				GPU_texture_unbind(src);
-				GPU_texture_filter_mode(fx->depth_buffer, true, false);
+				GPU_texture_filter_mode(fx->depth_buffer, true, false, false);
 				GPU_texture_unbind(fx->depth_buffer);
 
 				GPU_framebuffer_texture_detach(fx->dof_near_coc_buffer);
@@ -1144,7 +1144,7 @@ bool GPU_fx_do_composite_pass(
 				GPU_shader_uniform_vector(dof_shader_pass2, interface->viewvecs_uniform, 4, 3, viewvecs[0]);
 
 				GPU_texture_bind(fx->depth_buffer, numslots++);
-				GPU_texture_filter_mode(fx->depth_buffer, false, true);
+				GPU_texture_filter_mode(fx->depth_buffer, false, true, false);
 				GPU_shader_uniform_texture(dof_shader_pass2, interface->depth_uniform, fx->depth_buffer);
 
 				GPU_texture_bind(fx->dof_near_coc_buffer, numslots++);
@@ -1172,7 +1172,7 @@ bool GPU_fx_do_composite_pass(
 				glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
 
 				/* *unbind/detach */
-				GPU_texture_filter_mode(fx->depth_buffer, true, false);
+				GPU_texture_filter_mode(fx->depth_buffer, true, false, false);
 				GPU_texture_unbind(fx->depth_buffer);
 
 				GPU_texture_unbind(fx->dof_near_coc_final_buffer);
@@ -1256,7 +1256,7 @@ bool GPU_fx_do_composite_pass(
 				GPU_shader_uniform_texture(dof_shader_pass5, interface->medium_blurred_uniform, fx->dof_near_coc_buffer);
 
 				GPU_texture_bind(fx->depth_buffer, numslots++);
-				GPU_texture_filter_mode(fx->depth_buffer, false, true);
+				GPU_texture_filter_mode(fx->depth_buffer, false, true, false);
 				GPU_shader_uniform_texture(dof_shader_pass5, interface->depth_uniform, fx->depth_buffer);
 
 				/* if this is the last pass, prepare for rendering on the frambuffer */
@@ -1267,7 +1267,7 @@ bool GPU_fx_do_composite_pass(
 				GPU_texture_unbind(fx->dof_near_coc_buffer);
 				GPU_texture_unbind(fx->dof_near_coc_blurred_buffer);
 				GPU_texture_unbind(src);
-				GPU_texture_filter_mode(fx->depth_buffer, true, false);
+				GPU_texture_filter_mode(fx->depth_buffer, true, false, false);
 				GPU_texture_unbind(fx->depth_buffer);
 
 				/* may not be attached, in that case this just returns */
diff --git a/source/blender/gpu/intern/gpu_draw.c b/source/blender/gpu/intern/gpu_draw.c
index 7936811..90654e0 100644
--- a/source/blender/gpu/intern/gpu_draw.c
+++ b/source/blender/gpu/intern/gpu_draw.c
@@ -98,128 +98,6 @@
 
 extern Material defmaterial; /* from material.c */
 
-/* Text Rendering */
-
-static void gpu_mcol(unsigned int ucol)
-{
-	/* mcol order is swapped */
-	const char *cp = (char *)&ucol;
-	glColor3ub(cp[3], cp[2], cp[1]);
-}
-
-void GPU_render_text(
-        MTexPoly *mtexpoly, int mode,
-        const char *textstr, int textlen, unsigned int *col,
-        const float *v_quad[4], const float *uv_quad[4],
-        int glattrib)
-{
-	if ((mode & GEMAT_TEXT) && (textlen > 0) && mtexpoly->tpage) {
-		const float *v1 = v_quad[0];
-		const float *v2 = v_quad[1];
-		const float *v3 = v_quad[2];
-		const float *v4 = v_quad[3];
-		Image *ima = (Image *)mtexpoly->tpage;
-		const size_t textlen_st = textlen;
-		float centerx, centery, sizex, sizey, transx, transy, movex, movey, advance;
-		
-		/* multiline */
-		float line_start = 0.0f, line_height;
-		
-		if (v4)
-			line_height = max_ffff(v1[1], v2[1], v3[1], v4[2]) - min_ffff(v1[1], v2[1], v3[1], v4[2]);
-		else
-			line_height = max_fff(v1[1], v2[1], v3[1]) - min_fff(v1[1], v2[1], v3[1]);
-		line_height *= 1.2f; /* could be an option? */
-		/* end multiline */
-
-		
-		/* color has been set */
-		if (mtexpoly->mode & TF_OBCOL)
-			col = NULL;
-		else if (!col)
-			glColor3f(1.0f, 1.0f, 1.0f);
-
-		glPushMatrix();
-		
-		/* get the tab width */
-		ImBuf *first_ibuf = BKE_image_get_first_ibuf(ima);
-		matrixGlyph(first_ibuf, ' ', &centerx, &centery,
-			&sizex, &sizey, &transx, &transy, &movex, &movey, &advance);
-		
-		float advance_tab = advance * 4; /* tab width could also be an option */
-		
-		
-		for (size_t index = 0; index < textlen_st; ) {
-			unsigned int character;
-			float uv[4][2];
-
-			/* lets calculate offset stuff */
-			character = BLI_str_utf8_as_unicode_and_size_safe(textstr + index, &index);
-			
-			if (character == '\n') {
-				glTranslatef(line_start, -line_height, 0.0f);
-				line_start = 0.0f;
-				continue;
-			}
-			else if (character == '\t') {
-				glTranslatef(advance_tab, 0.0f, 0.0f);
-				line_start -= advance_tab; /* so we can go back to the start of the line */
-				continue;
-				
-			}
-			else if (character > USHRT_MAX) {
-				/* not much we can do here bmfonts take ushort */
-				character = '?';
-			}
-			
-			/* space starts at offset 1 */
-			/* character = character - ' ' + 1; */
-			matrixGlyph(first_ibuf, character, & centerx, &centery,
-				&sizex, &sizey, &transx, &transy, &movex, &movey, &advance);
-
-			uv[0][0] = (uv_quad[0][0] - centerx) * sizex + transx;
-			uv[0][1] = (uv_quad[0][1] - centery) * sizey + transy;
-			uv[1][0] = (uv_quad[1][0] - centerx) * sizex + transx;
-			uv[1][1] = (uv_quad[1][1] - centery) * sizey + transy;
-			uv[2][0] = (uv_quad[2][0] - centerx) * sizex + transx;
-			uv[2][1] = (uv_quad[2][1] - centery) * sizey + transy;
-			
-			glBegin(GL_POLYGON);
-			if (glattrib >= 0) glVertexAttrib2fv(glattrib, uv[0]);
-			else glTexCoord2fv(uv[0]);
-			if (col) gpu_mcol(col[0]);
-			glVertex3f(sizex * v1[0] + movex, sizey * v1[1] + movey, v1[2]);
-			
-			if (glattrib >= 0) glVertexAttrib2fv(glattrib, uv[1]);
-			else glTexCoord2fv(uv[1]);
-			if (col) gpu_mcol(col[1]);
-			glVertex3f(sizex * v2[0] + movex, sizey * v2[1] + movey, v2[2]);
-
-			if (glattrib >= 0) glVertexAttrib2fv(glattrib, uv[2]);
-			else glTexCoord2fv(uv[2]);
-			if (col) gpu_mcol(col[2]);
-			glVertex3f(sizex * v3[0] + movex, sizey * v3[1] + movey, v3[2]);
-
-			if (v4) {
-				uv[3][0] = (uv_quad[3][0] - centerx) * sizex + transx;
-				uv[3][1] = (uv_quad[3][1] - centery) * sizey + transy;
-
-				if (glattrib >= 0) glVertexAttrib2fv(glattrib, uv[3]);
-				else glTexCoord2fv(uv[3]);
-				if (col) gpu_mcol(col[3]);
-				glVertex3f(sizex * v4[0] + movex, sizey * v4[1] + movey, v4[2]);
-			}
-			glEnd();
-
-			glTranslatef(advance, 0.0f, 0.0f);
-			line_start -= advance; /* so we can go back to the start of the line */
-		}
-		glPopMatrix();
-
-		BKE_image_release_ibuf(ima, first_ibuf, NULL);
-	}
-}
-
 /* Checking powers of two for images since OpenGL ES requires it */
 
 static bool is_power_of_2_resolution(int w, int h)
@@ -1821,7 +1699,7 @@ void GPU_begin_object_materials(
 
 			if (glsl) {
 				GMS.gmatbuf[0] = &defmaterial;
-				GPU_material_from_blender(GMS.gscene, &defmaterial, GMS.is_opensubdiv);
+				GPU_material_from_blender(GMS.gscene, &defmaterial, GMS.is_opensubdiv, false);
 			}
 
 			GMS.alphablend[0] = GPU_BLEND_SOLID;
@@ -1835,7 +1713,7 @@ void GPU_begin_object_materials(
 			if (ma == NULL) ma = &defmaterial;
 
 			/* create glsl material if requested */
-			gpumat = glsl ? GPU_material_from_blender(GMS.gscene, ma, GMS.is_opensubdiv) : NULL;
+			gpumat = glsl ? GPU_material_from_blender(GMS.gscene, ma, GMS.is_opensubdiv, false) : NULL;
 
 			if (gpumat) {
 				/* do glsl only if creating it succeed, else fallback */
@@ -1934,7 +1812,7 @@ int GPU_object_material_bind(int nr, void *attribs)
 	/* unbind glsl material */
 	if (GMS.gboundmat) {
 		if (GMS.is_alpha_pass) glDepthMask(0);
-		GPU_material_unbind(GPU_material_from_blender(GMS.gscene, GMS.gboundmat, GMS.is_opensubdiv));
+		GPU_material_unbind(GPU_material_from_blender(GMS.gscene, GMS.gboundmat, GMS.is_opensubdiv, false));
 		GMS.gboundmat = NULL;
 	}
 
@@ -1961,7 +1839,7 @@ int GPU_object_material_bind(int nr, void *attribs)
 
 			float auto_bump_scale;
 
-			GPUMaterial *gpumat = GPU_material_from_blender(GMS.gscene, mat, GMS.is_opensubdiv);
+			GPUMaterial *gpumat = GPU_material_from_blender(GMS.gscene, mat, GMS.is_opensubdiv, false);
 			GPU_material_vertex_attributes(gpumat, gattribs);
 
 			if (GMS.dob)
@@ -2060,7 +1938,7 @@ void GPU_object_material_unbind(void)
 			glDisable(GL_CULL_FACE);
 
 		if (GMS.is_alpha_pass) glDepthMask(0);
-		GPU_material_unbind(GPU_material_from_blender(GMS.gscene, GMS.gboundmat, GMS.is_opensubdiv));
+		GPU_material_unbind(GPU_material_from_blender(GMS.gscene, GMS.gboundmat, GMS.is_opensubdiv, false));
 		GMS.gboundmat = NULL;
 	}
 	else
@@ -2355,7 +2233,8 @@ void GPU_draw_update_fvar_offset(DerivedMesh *dm)
 
 		gpu_material = GPU_material_from_blender(GMS.gscene,
 		                                         material,
-		                                         GMS.is_opensubdiv);
+		                                         GMS.is_opensubdiv,
+												 false);
 
 		GPU_material_update_fvar_offset(gpu_material, dm);
 	}
diff --git a/source/blender/gpu/intern/gpu_extensions.c b/source/blender/gpu/intern/gpu_extensions.c
index e0ce87d..1b07f93 100644
--- a/source/blender/gpu/intern/gpu_extensions.c
+++ b/source/blender/gpu/intern/gpu_extensions.c
@@ -235,6 +235,10 @@ void gpu_extensions_init(void)
 		GG.dfdyfactors[1] = 1.0;
 	}
 
+	/* Enable globally cube map seamless to avoid edge on mipmapping */
+	if (GLEW_ARB_seamless_cube_map) {
+		glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);
+	}
 
 	GPU_invalid_tex_init();
 	GPU_basic_shaders_init();
diff --git a/source/blender/gpu/intern/gpu_framebuffer.c b/source/blender/gpu/intern/gpu_framebuffer.c
index f62ef67..465170e 100644
--- a/source/blender/gpu/intern/gpu_framebuffer.c
+++ b/source/blender/gpu/intern/gpu_framebuffer.c
@@ -29,6 +29,7 @@
 
 #include "BLI_blenlib.h"
 #include "BLI_utildefines.h"
+#include "BLI_math_base.h"
 
 #include "BKE_global.h"
 
@@ -50,6 +51,8 @@ struct GPUFrameBuffer {
 	GLuint object;
 	GPUTexture *colortex[GPU_FB_MAX_SLOTS];
 	GPUTexture *depthtex;
+	GPURenderBuffer *colorrb[GPU_FB_MAX_SLOTS];
+	GPURenderBuffer *depthrb;
 };
 
 static void GPU_print_framebuffer_error(GLenum status, char err_out[256])
@@ -128,6 +131,11 @@ GPUFrameBuffer *GPU_framebuffer_create(void)
 
 int GPU_framebuffer_texture_attach(GPUFrameBuffer *fb, GPUTexture *tex, int slot, char err_out[256])
 {
+	return GPU_framebuffer_texture_attach_target(fb, tex, GPU_texture_target(tex), slot, err_out);
+}
+
+int GPU_framebuffer_texture_attach_target(GPUFrameBuffer *fb, GPUTexture *tex, int target, int slot, char err_out[256])
+{
 	GLenum attachment;
 	GLenum error;
 
@@ -158,7 +166,7 @@ int GPU_framebuffer_texture_attach(GPUFrameBuffer *fb, GPUTexture *tex, int slot
 	while (glGetError() != GL_NO_ERROR) {}
 
 	glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, attachment, 
-		GPU_texture_target(tex), GPU_texture_opengl_bindcode(tex), 0);
+		target, GPU_texture_opengl_bindcode(tex), 0);
 
 	error = glGetError();
 
@@ -180,6 +188,11 @@ int GPU_framebuffer_texture_attach(GPUFrameBuffer *fb, GPUTexture *tex, int slot
 
 void GPU_framebuffer_texture_detach(GPUTexture *tex)
 {
+	GPU_framebuffer_texture_detach_target(tex, GPU_texture_target(tex));
+}
+
+void GPU_framebuffer_texture_detach_target(GPUTexture *tex, int target)
+{
 	GLenum attachment;
 	GPUFrameBuffer *fb = GPU_texture_framebuffer(tex);
 	int fb_attachment = GPU_texture_framebuffer_attachment(tex);
@@ -202,7 +215,7 @@ void GPU_framebuffer_texture_detach(GPUTexture *tex)
 		attachment = GL_COLOR_ATTACHMENT0_EXT + fb_attachment;
 	}
 
-	glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, attachment, GPU_texture_target(tex), 0, 0);
+	glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, attachment, target, 0, 0);
 
 	GPU_texture_framebuffer_set(tex, NULL, -1);
 }
@@ -312,6 +325,16 @@ void GPU_framebuffer_bind_no_save(GPUFrameBuffer *fb, int slot)
 	GG.currentfb = fb->object;
 }
 
+void GPU_framebuffer_bind_simple(GPUFrameBuffer *fb)
+{
+	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fb->object);
+	/* last bound prevails here, better allow explicit control here too */
+	glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
+	glReadBuffer(GL_COLOR_ATTACHMENT0_EXT);
+
+	GG.currentfb = fb->object;
+}
+
 bool GPU_framebuffer_bound(GPUFrameBuffer *fb)
 {
 	return fb->object == GG.currentfb;
@@ -338,6 +361,80 @@ bool GPU_framebuffer_check_valid(GPUFrameBuffer *fb, char err_out[256])
 	return true;
 }
 
+int GPU_framebuffer_renderbuffer_attach(GPUFrameBuffer *fb, GPURenderBuffer *rb, int slot, char err_out[256])
+{
+	GLenum attachement;
+	GLenum error;
+
+	if (slot >= GPU_FB_MAX_SLOTS) {
+		fprintf(stderr,
+		        "Attaching to index %d framebuffer slot unsupported. "
+		        "Use at most %d\n", slot, GPU_FB_MAX_SLOTS);
+		return 0;
+	}
+
+	if (GPU_renderbuffer_depth(rb)) {
+		attachement = GL_DEPTH_ATTACHMENT_EXT;
+	}
+	else {
+		attachement = GL_COLOR_ATTACHMENT0_EXT + slot;
+	}
+
+	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fb->object);
+	GG.currentfb = fb->object;
+
+	/* Clean glError buffer. */
+	while (glGetError() != GL_NO_ERROR) {}
+
+	glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, attachement, GL_RENDERBUFFER_EXT, GPU_renderbuffer_bindcode(rb));
+
+	error = glGetError();
+
+	if (error == GL_INVALID_OPERATION) {
+		GPU_framebuffer_restore();
+		GPU_print_framebuffer_error(error, err_out);
+		return 0;
+	}
+
+	if (GPU_renderbuffer_depth(rb))
+		fb->depthrb = rb;
+	else
+		fb->colorrb[slot] = rb;
+
+	GPU_renderbuffer_framebuffer_set(rb, fb, slot);
+
+	return 1;
+}
+
+void GPU_framebuffer_renderbuffer_detach(GPURenderBuffer *rb)
+{
+	GLenum attachment;
+	GPUFrameBuffer *fb = GPU_renderbuffer_framebuffer(rb);
+	int fb_attachment = GPU_renderbuffer_framebuffer_attachment(rb);
+
+	if (!fb)
+		return;
+
+	if (GG.currentfb != fb->object) {
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fb->object);
+		GG.currentfb = fb->object;
+	}
+
+	if (GPU_renderbuffer_depth(rb)) {
+		fb->depthrb = NULL;
+		attachment = GL_DEPTH_ATTACHMENT_EXT;
+	}
+	else {
+		BLI_assert(fb->colorrb[fb_attachment] == rb);
+		fb->colorrb[fb_attachment] = NULL;
+		attachment = GL_COLOR_ATTACHMENT0_EXT + fb_attachment;
+	}
+
+	glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, attachment, GL_RENDERBUFFER_EXT, 0);
+
+	GPU_renderbuffer_framebuffer_set(rb, NULL, -1);
+}
+
 void GPU_framebuffer_free(GPUFrameBuffer *fb)
 {
 	int i;
@@ -350,6 +447,15 @@ void GPU_framebuffer_free(GPUFrameBuffer *fb)
 		}
 	}
 
+	if (fb->depthrb)
+		GPU_framebuffer_renderbuffer_detach(fb->depthrb);
+
+	for (i = 0; i < GPU_FB_MAX_SLOTS; i++) {
+		if (fb->colorrb[i]) {
+			GPU_framebuffer_renderbuffer_detach(fb->colorrb[i]);
+		}
+	}
+
 	if (fb->object) {
 		glDeleteFramebuffersEXT(1, &fb->object);
 
@@ -372,10 +478,10 @@ void GPU_framebuffer_restore(void)
 
 void GPU_framebuffer_blur(
         GPUFrameBuffer *fb, GPUTexture *tex,
-        GPUFrameBuffer *blurfb, GPUTexture *blurtex)
+        GPUFrameBuffer *blurfb, GPUTexture *blurtex, float sharpness)
 {
-	const float scaleh[2] = {1.0f / GPU_texture_width(blurtex), 0.0f};
-	const float scalev[2] = {0.0f, 1.0f / GPU_texture_height(tex)};
+	const float scaleh[2] = {(1.0f - sharpness) / GPU_texture_width(blurtex), 0.0f};
+	const float scalev[2] = {0.0f, (1.0f - sharpness) / GPU_texture_height(tex)};
 
 	GPUShader *blur_shader = GPU_shader_get_builtin_shader(GPU_SHADER_SEP_GAUSSIAN_BLUR);
 	int scale_uniform, texture_source_uniform;
@@ -440,18 +546,148 @@ void GPU_framebuffer_blur(
 	glTexCoord2d(0, 1); glVertex2f(1, -1);
 	glEnd();
 
+	GPU_texture_unbind(blurtex);
 	GPU_shader_unbind();
 }
 
+/* GPURenderBuffer */
+
+struct GPURenderBuffer {
+	int width;
+	int height;
+	int samples;
+
+	GPUFrameBuffer *fb; /* GPUFramebuffer this render buffer is attached to */
+	int fb_attachment;  /* slot the render buffer is attached to */
+	bool depth;
+	unsigned int bindcode;
+};
+
+GPURenderBuffer *GPU_renderbuffer_create(int width, int height, int samples, GPUHDRType hdrtype, GPURenderBufferType type, char err_out[256])
+{
+	GPURenderBuffer *rb = MEM_callocN(sizeof(GPURenderBuffer), "GPURenderBuffer");
+
+	glGenRenderbuffers(1, &rb->bindcode);
+
+	if (!rb->bindcode) {
+		if (err_out) {
+			BLI_snprintf(err_out, 256, "GPURenderBuffer: render buffer creation failed: %d",
+				(int)glGetError());
+		}
+		else {
+			fprintf(stderr, "GPURenderBuffer: render buffer creation failed: %d\n",
+				(int)glGetError());
+		}
+		GPU_renderbuffer_free(rb);
+		return NULL;
+	}
+
+	rb->width = width;
+	rb->height = height;
+	rb->samples = samples;
+
+	glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rb->bindcode);
+
+	if (type == GPU_RENDERBUFFER_DEPTH) {
+		if (samples > 0) {
+			glRenderbufferStorageMultisampleEXT(GL_RENDERBUFFER_EXT, samples, GL_DEPTH_COMPONENT, width, height);
+		}
+		else {
+			glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT, width, height);
+		}
+		rb->depth = true;
+	}
+	else {
+		GLenum internalformat = GL_RGBA8;
+		switch (hdrtype) {
+			case GPU_HDR_NONE:
+			{
+				internalformat = GL_RGBA8;
+				break;
+			}
+			/* the following formats rely on ARB_texture_float or OpenGL 3.0 */
+			case GPU_HDR_HALF_FLOAT:
+			{
+				internalformat = GL_RGBA16F_ARB;
+				break;
+			}
+			case GPU_HDR_FULL_FLOAT:
+			{
+				internalformat = GL_RGBA32F_ARB;
+				break;
+			}
+		}
+		if (samples > 0) {
+			glRenderbufferStorageMultisampleEXT(GL_RENDERBUFFER_EXT, samples, internalformat, width, height);
+		}
+		else {
+			glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, internalformat, width, height);
+		}
+	}
+
+	glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0);
+
+	return rb;
+}
+
+void GPU_renderbuffer_free(GPURenderBuffer *rb)
+{
+	if (rb->bindcode) {
+		glDeleteRenderbuffersEXT(1, &rb->bindcode);
+	}
+
+	MEM_freeN(rb);
+}
+
+GPUFrameBuffer *GPU_renderbuffer_framebuffer(GPURenderBuffer *rb)
+{
+	return rb->fb;
+}
+
+int GPU_renderbuffer_framebuffer_attachment(GPURenderBuffer *rb)
+{
+	return rb->fb_attachment;
+}
+
+void GPU_renderbuffer_framebuffer_set(GPURenderBuffer *rb, GPUFrameBuffer *fb, int attachement)
+{
+	rb->fb = fb;
+	rb->fb_attachment = attachement;
+}
+
+int GPU_renderbuffer_bindcode(const GPURenderBuffer *rb)
+{
+	return rb->bindcode;
+}
+
+bool GPU_renderbuffer_depth(const GPURenderBuffer *rb)
+{
+	return rb->depth;
+}
+
+int GPU_renderbuffer_width(const GPURenderBuffer *rb)
+{
+	return rb->width;
+}
+
+int GPU_renderbuffer_height(const GPURenderBuffer *rb)
+{
+	return rb->height;
+}
+
+
 /* GPUOffScreen */
 
 struct GPUOffScreen {
 	GPUFrameBuffer *fb;
 	GPUTexture *color;
 	GPUTexture *depth;
+	GPURenderBuffer *rbcolor;
+	GPURenderBuffer *rbdepth;
+	int samples;
 };
 
-GPUOffScreen *GPU_offscreen_create(int width, int height, int samples, char err_out[256])
+GPUOffScreen *GPU_offscreen_create(int width, int height, int samples, GPUHDRType hdrtype, int mode, char err_out[256])
 {
 	GPUOffScreen *ofs;
 
@@ -465,41 +701,78 @@ GPUOffScreen *GPU_offscreen_create(int width, int height, int samples, char err_
 
 	if (samples) {
 		if (!GLEW_EXT_framebuffer_multisample ||
-		    !GLEW_ARB_texture_multisample ||
+			/* Disable multisample for texture and not render buffers
+			 * when it's not supported */
+		    (!GLEW_ARB_texture_multisample && (!(mode & GPU_OFFSCREEN_RENDERBUFFER_COLOR) || !(mode & GPU_OFFSCREEN_RENDERBUFFER_DEPTH))) ||
 		    /* Only needed for GPU_offscreen_read_pixels.
 		     * We could add an arg if we intend to use multi-sample
 		     * offscreen buffers w/o reading their pixels */
-		    !GLEW_EXT_framebuffer_blit ||
+		    !GLEW_EXT_framebuffer_blit
+
+	/* Some GPUs works even without this extension. */
+#if 0
 		    /* This is required when blitting from a multi-sampled buffers,
 		     * even though we're not scaling. */
-		    !GLEW_EXT_framebuffer_multisample_blit_scaled)
+		    || !GLEW_EXT_framebuffer_multisample_blit_scaled
+#endif
+			)
 		{
 			samples = 0;
 		}
 	}
 
-	ofs->depth = GPU_texture_create_depth_multisample(width, height, samples, err_out);
-	if (!ofs->depth) {
-		GPU_offscreen_free(ofs);
-		return NULL;
+	ofs->samples = samples;
+
+	if (mode & GPU_OFFSCREEN_RENDERBUFFER_COLOR) {
+		ofs->rbcolor = GPU_renderbuffer_create(width, height, samples, hdrtype, GPU_RENDERBUFFER_COLOR, err_out);
+		if (!ofs->rbcolor) {
+			GPU_offscreen_free(ofs);
+			return NULL;
+		}
+
+		if (!GPU_framebuffer_renderbuffer_attach(ofs->fb, ofs->rbcolor, 0, err_out)) {
+			GPU_offscreen_free(ofs);
+			return NULL;
+		}
 	}
+	else {
+		ofs->color = GPU_texture_create_2D_multisample(width, height, NULL, hdrtype, samples, err_out);
+		if (!ofs->color) {
+			GPU_offscreen_free(ofs);
+			return NULL;
+		}
 
-	if (!GPU_framebuffer_texture_attach(ofs->fb, ofs->depth, 0, err_out)) {
-		GPU_offscreen_free(ofs);
-		return NULL;
+		if (!GPU_framebuffer_texture_attach(ofs->fb, ofs->color, 0, err_out)) {
+			GPU_offscreen_free(ofs);
+			return NULL;
+		}
 	}
 
-	ofs->color = GPU_texture_create_2D_multisample(width, height, NULL, GPU_HDR_NONE, samples, err_out);
-	if (!ofs->color) {
-		GPU_offscreen_free(ofs);
-		return NULL;
+	if (mode & GPU_OFFSCREEN_RENDERBUFFER_DEPTH) {
+		ofs->rbdepth = GPU_renderbuffer_create(width, height, samples, GPU_HDR_NONE, GPU_RENDERBUFFER_DEPTH, err_out);
+		if (!ofs->rbdepth) {
+			GPU_offscreen_free(ofs);
+			return NULL;
+		}
+
+		if (!GPU_framebuffer_renderbuffer_attach(ofs->fb, ofs->rbdepth, 0, err_out)) {
+			GPU_offscreen_free(ofs);
+			return NULL;
+		}
 	}
+	else {
+		ofs->depth = GPU_texture_create_depth_multisample(width, height, samples, (mode & GPU_OFFSCREEN_DEPTH_COMPARE), err_out);
+		if (!ofs->depth) {
+			GPU_offscreen_free(ofs);
+			return NULL;
+		}
 
-	if (!GPU_framebuffer_texture_attach(ofs->fb, ofs->color, 0, err_out)) {
-		GPU_offscreen_free(ofs);
-		return NULL;
+		if (!GPU_framebuffer_texture_attach(ofs->fb, ofs->depth, 0, err_out)) {
+			GPU_offscreen_free(ofs);
+			return NULL;
+		}
 	}
-	
+
 	/* check validity at the very end! */
 	if (!GPU_framebuffer_check_valid(ofs->fb, err_out)) {
 		GPU_offscreen_free(ofs);
@@ -519,6 +792,12 @@ void GPU_offscreen_free(GPUOffScreen *ofs)
 		GPU_texture_free(ofs->color);
 	if (ofs->depth)
 		GPU_texture_free(ofs->depth);
+	if (ofs->rbcolor) {
+		GPU_renderbuffer_free(ofs->rbcolor);
+	}
+	if (ofs->rbdepth) {
+		GPU_renderbuffer_free(ofs->rbdepth);
+	}
 	
 	MEM_freeN(ofs);
 }
@@ -533,6 +812,11 @@ void GPU_offscreen_bind(GPUOffScreen *ofs, bool save)
 	}
 }
 
+void GPU_offscreen_bind_simple(GPUOffScreen *ofs)
+{
+	GPU_framebuffer_bind_simple(ofs->fb);
+}
+
 void GPU_offscreen_unbind(GPUOffScreen *ofs, bool restore)
 {
 	if (restore)
@@ -620,14 +904,63 @@ finally:
 	}
 }
 
+void GPU_offscreen_blit(GPUOffScreen *srcofs, GPUOffScreen *dstofs, bool color, bool depth)
+{
+	BLI_assert(color || depth);
+
+	glBindFramebufferEXT(GL_READ_FRAMEBUFFER_EXT, srcofs->fb->object);
+	glBindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, dstofs->fb->object);
+
+	glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
+	glReadBuffer(GL_COLOR_ATTACHMENT0_EXT);
+
+	int height = min_ff(GPU_offscreen_height(srcofs), GPU_offscreen_height(dstofs));
+	int width = min_ff(GPU_offscreen_width(srcofs), GPU_offscreen_width(dstofs));
+
+
+	int mask = 0;
+	if (color) {
+		mask |= GL_COLOR_BUFFER_BIT;
+	}
+	if (depth) {
+		mask |= GL_DEPTH_BUFFER_BIT;
+	}
+
+	glBlitFramebufferEXT(0, 0, width, height, 0, 0, width, height, mask, GL_NEAREST);
+
+	// Call GPU_framebuffer_bind_simple to change GG.currentfb.
+	GPU_framebuffer_bind_simple(dstofs->fb);
+}
+
 int GPU_offscreen_width(const GPUOffScreen *ofs)
 {
-	return GPU_texture_width(ofs->color);
+	if (ofs->color) {
+		return GPU_texture_width(ofs->color);
+	}
+	else if (ofs->rbcolor) {
+		return GPU_renderbuffer_width(ofs->rbcolor);
+	}
+
+	// Should never happen.
+	return 0;
 }
 
 int GPU_offscreen_height(const GPUOffScreen *ofs)
 {
-	return GPU_texture_height(ofs->color);
+	if (ofs->color) {
+		return GPU_texture_height(ofs->color);
+	}
+	else if (ofs->rbcolor) {
+		return GPU_renderbuffer_height(ofs->rbcolor);
+	}
+
+	// Should never happen.
+	return 0;
+}
+
+int GPU_offscreen_samples(const GPUOffScreen *ofs)
+{
+	return ofs->samples;
 }
 
 int GPU_offscreen_color_texture(const GPUOffScreen *ofs)
@@ -635,3 +968,13 @@ int GPU_offscreen_color_texture(const GPUOffScreen *ofs)
 	return GPU_texture_opengl_bindcode(ofs->color);
 }
 
+GPUTexture *GPU_offscreen_texture(const GPUOffScreen *ofs)
+{
+	return ofs->color;
+}
+
+GPUTexture *GPU_offscreen_depth_texture(const GPUOffScreen *ofs)
+{
+	return ofs->depth;
+}
+
diff --git a/source/blender/gpu/intern/gpu_material.c b/source/blender/gpu/intern/gpu_material.c
index b857aea..2b1b24f 100644
--- a/source/blender/gpu/intern/gpu_material.c
+++ b/source/blender/gpu/intern/gpu_material.c
@@ -89,6 +89,8 @@ static struct GPUWorld {
 	float horicol[3];
 	float ambcol[4];
 	float zencol[3];
+	float logfac;
+	float linfac;
 } GPUWorld;
 
 struct GPUMaterial {
@@ -122,10 +124,18 @@ struct GPUMaterial {
 	int partvel;
 	int partangvel;
 
+	int ininstposloc;
+	int ininstmatloc;
+	int ininstcolloc;
+
+	bool use_instancing;
+
 	ListBase lamps;
 	bool bound;
 
 	bool is_opensubdiv;
+
+	float har;
 };
 
 struct GPULamp {
@@ -233,6 +243,7 @@ static int GPU_material_construct_end(GPUMaterial *material, const char *passnam
 			&material->attribs, &material->builtins, material->type,
 			passname,
 			material->is_opensubdiv,
+			material->use_instancing,
 			GPU_material_use_new_shading_nodes(material));
 
 		if (!material->pass)
@@ -268,6 +279,11 @@ static int GPU_material_construct_end(GPUMaterial *material, const char *passnam
 			material->partvel = GPU_shader_get_uniform(shader, GPU_builtin_name(GPU_PARTICLE_VELOCITY));
 		if (material->builtins & GPU_PARTICLE_ANG_VELOCITY)
 			material->partangvel = GPU_shader_get_uniform(shader, GPU_builtin_name(GPU_PARTICLE_ANG_VELOCITY));
+		if (material->use_instancing) {
+			material->ininstposloc = GPU_shader_get_attribute(shader, GPU_builtin_name(GPU_INSTANCING_POSITION_ATTRIB));
+			material->ininstmatloc = GPU_shader_get_attribute(shader, GPU_builtin_name(GPU_INSTANCING_MATRIX_ATTRIB));
+			material->ininstcolloc = GPU_shader_get_attribute(shader, GPU_builtin_name(GPU_INSTANCING_COLOR_ATTRIB));
+		}
 		return 1;
 	}
 	else {
@@ -318,6 +334,64 @@ bool GPU_lamp_override_visible(GPULamp *lamp, SceneRenderLayer *srl, Material *m
 		return true;
 }
 
+void GPU_material_bind_instancing_attrib(GPUMaterial *material, void *matrixoffset, void *positionoffset, void *coloroffset, unsigned int stride)
+{
+	// Matrix
+	if (material->ininstmatloc != -1) {
+		glEnableVertexAttribArrayARB(material->ininstmatloc);
+		glEnableVertexAttribArrayARB(material->ininstmatloc + 1);
+		glEnableVertexAttribArrayARB(material->ininstmatloc + 2);
+
+		glVertexAttribPointerARB(material->ininstmatloc, 3, GL_FLOAT, GL_FALSE, stride, matrixoffset);
+		glVertexAttribPointerARB(material->ininstmatloc + 1, 3, GL_FLOAT, GL_FALSE, stride, ((char *)matrixoffset) + 3 * sizeof(float));
+		glVertexAttribPointerARB(material->ininstmatloc + 2, 3, GL_FLOAT, GL_FALSE, stride, ((char *)matrixoffset) + 6 * sizeof(float));
+
+		glVertexAttribDivisorARB(material->ininstmatloc, 1);
+		glVertexAttribDivisorARB(material->ininstmatloc + 1, 1);
+		glVertexAttribDivisorARB(material->ininstmatloc + 2, 1);
+	}
+
+	// Position
+	if (material->ininstposloc != -1) {
+		glEnableVertexAttribArrayARB(material->ininstposloc);
+		glVertexAttribPointerARB(material->ininstposloc, 3, GL_FLOAT, GL_FALSE, stride, positionoffset);
+		glVertexAttribDivisorARB(material->ininstposloc, 1);
+	}
+
+	// Color
+	if (material->ininstcolloc != -1) {
+		glEnableVertexAttribArrayARB(material->ininstcolloc);
+		glVertexAttribPointerARB(material->ininstcolloc, 4, GL_UNSIGNED_BYTE, GL_TRUE, stride, coloroffset);
+		glVertexAttribDivisorARB(material->ininstcolloc, 1);
+	}
+}
+
+void GPU_material_unbind_instancing_attrib(GPUMaterial *material)
+{
+	// Matrix
+	if (material->ininstmatloc != -1) {
+		glDisableVertexAttribArrayARB(material->ininstmatloc);
+		glDisableVertexAttribArrayARB(material->ininstmatloc + 1);
+		glDisableVertexAttribArrayARB(material->ininstmatloc + 2);
+
+		glVertexAttribDivisorARB(material->ininstmatloc, 0);
+		glVertexAttribDivisorARB(material->ininstmatloc + 1, 0);
+		glVertexAttribDivisorARB(material->ininstmatloc + 2, 0);
+	}
+
+	// Position
+	if (material->ininstposloc != -1) {
+		glDisableVertexAttribArrayARB(material->ininstposloc);
+		glVertexAttribDivisorARB(material->ininstposloc, 0);
+	}
+
+	// Color
+	if (material->ininstcolloc != -1) {
+		glDisableVertexAttribArrayARB(material->ininstcolloc);
+		glVertexAttribDivisorARB(material->ininstcolloc, 0);
+	}
+}
+
 void GPU_material_bind(
         GPUMaterial *material, int oblay, int viewlay, double time, int mipmap,
         float viewmat[4][4], float viewinv[4][4], float camerafactors[4], bool scenelock)
@@ -326,14 +400,17 @@ void GPU_material_bind(
 		GPUShader *shader = GPU_pass_shader(material->pass);
 		SceneRenderLayer *srl = scenelock ? BLI_findlink(&material->scene->r.layers, material->scene->r.actlay) : NULL;
 
+		if (material->ma) {
+			material->har = material->ma->har;
+		}
+
 		if (srl)
 			viewlay &= srl->lay;
 
 		/* handle layer lamps */
-		if (material->type == GPU_MATERIAL_TYPE_MESH) {
+		if (material->type == GPU_MATERIAL_TYPE_MESH || material->use_instancing) {
 			for (LinkData *nlink = material->lamps.first; nlink; nlink = nlink->next) {
 				GPULamp *lamp = nlink->data;
-				
 				if (!lamp->hide && (lamp->lay & viewlay) && (!(lamp->mode & LA_LAYER) || (lamp->lay & oblay)) &&
 				    GPU_lamp_override_visible(lamp, srl, material->ma))
 				{
@@ -476,7 +553,6 @@ GPUMatType GPU_Material_get_type(GPUMaterial *material)
 	return material->type;
 }
 
-
 void GPU_material_vertex_attributes(GPUMaterial *material, GPUVertexAttribs *attribs)
 {
 	*attribs = material->attribs;
@@ -528,6 +604,7 @@ bool GPU_material_use_world_space_shading(GPUMaterial *mat)
 
 static GPUNodeLink *lamp_get_visibility(GPUMaterial *mat, GPULamp *lamp, GPUNodeLink **lv, GPUNodeLink **dist)
 {
+	Material *ma = mat->ma;
 	GPUNodeLink *visifac;
 
 	/* from get_lamp_visibility */
@@ -551,23 +628,23 @@ static GPUNodeLink *lamp_get_visibility(GPUMaterial *mat, GPULamp *lamp, GPUNode
 				break;
 			case LA_FALLOFF_INVLINEAR:
 				GPU_link(mat, "lamp_falloff_invlinear",
-				         GPU_dynamic_uniform(&lamp->dist, GPU_DYNAMIC_LAMP_DISTANCE, lamp->ob), *dist, &visifac);
+				         GPU_select_uniform(&lamp->dist, GPU_DYNAMIC_LAMP_DISTANCE, lamp->ob, ma), *dist, &visifac);
 				break;
 			case LA_FALLOFF_INVSQUARE:
 				GPU_link(mat, "lamp_falloff_invsquare",
-				         GPU_dynamic_uniform(&lamp->dist, GPU_DYNAMIC_LAMP_DISTANCE, lamp->ob), *dist, &visifac);
+				         GPU_select_uniform(&lamp->dist, GPU_DYNAMIC_LAMP_DISTANCE, lamp->ob, ma), *dist, &visifac);
 				break;
 			case LA_FALLOFF_SLIDERS:
 				GPU_link(mat, "lamp_falloff_sliders",
-				         GPU_dynamic_uniform(&lamp->dist, GPU_DYNAMIC_LAMP_DISTANCE, lamp->ob),
-				         GPU_dynamic_uniform(&lamp->att1, GPU_DYNAMIC_LAMP_ATT1, lamp->ob),
-				         GPU_dynamic_uniform(&lamp->att2, GPU_DYNAMIC_LAMP_ATT2, lamp->ob), *dist, &visifac);
+				         GPU_select_uniform(&lamp->dist, GPU_DYNAMIC_LAMP_DISTANCE, lamp->ob, ma),
+				         GPU_select_uniform(&lamp->att1, GPU_DYNAMIC_LAMP_ATT1, lamp->ob, ma),
+				         GPU_select_uniform(&lamp->att2, GPU_DYNAMIC_LAMP_ATT2, lamp->ob, ma), *dist, &visifac);
 				break;
 			case LA_FALLOFF_INVCOEFFICIENTS:
 				GPU_link(mat, "lamp_falloff_invcoefficients",
-					     GPU_dynamic_uniform(&lamp->coeff_const, GPU_DYNAMIC_LAMP_COEFFCONST, lamp->ob),
-					     GPU_dynamic_uniform(&lamp->coeff_lin, GPU_DYNAMIC_LAMP_COEFFLIN, lamp->ob),
-					     GPU_dynamic_uniform(&lamp->coeff_quad, GPU_DYNAMIC_LAMP_COEFFQUAD, lamp->ob), *dist, &visifac);
+					     GPU_select_uniform(&lamp->coeff_const, GPU_DYNAMIC_LAMP_COEFFCONST, lamp->ob, ma),
+					     GPU_select_uniform(&lamp->coeff_lin, GPU_DYNAMIC_LAMP_COEFFLIN, lamp->ob, ma),
+					     GPU_select_uniform(&lamp->coeff_quad, GPU_DYNAMIC_LAMP_COEFFQUAD, lamp->ob, ma), *dist, &visifac);
 				break;
 			case LA_FALLOFF_CURVE:
 			{
@@ -577,7 +654,7 @@ static GPUNodeLink *lamp_get_visibility(GPUMaterial *mat, GPULamp *lamp, GPUNode
 				curvemapping_initialize(lamp->curfalloff);
 				curvemapping_table_RGBA(lamp->curfalloff, &array, &size);
 				GPU_link(mat, "lamp_falloff_curve",
-				         GPU_dynamic_uniform(&lamp->dist, GPU_DYNAMIC_LAMP_DISTANCE, lamp->ob),
+				         GPU_select_uniform(&lamp->dist, GPU_DYNAMIC_LAMP_DISTANCE, lamp->ob, ma),
 				         GPU_texture(size, array), *dist, &visifac);
 
 				break;
@@ -586,7 +663,7 @@ static GPUNodeLink *lamp_get_visibility(GPUMaterial *mat, GPULamp *lamp, GPUNode
 
 		if (lamp->mode & LA_SPHERE)
 			GPU_link(mat, "lamp_visibility_sphere",
-			         GPU_dynamic_uniform(&lamp->dist, GPU_DYNAMIC_LAMP_DISTANCE, lamp->ob),
+			         GPU_select_uniform(&lamp->dist, GPU_DYNAMIC_LAMP_DISTANCE, lamp->ob, ma),
 			         *dist, visifac, &visifac);
 
 		if (lamp->type == LA_SPOT) {
@@ -597,19 +674,19 @@ static GPUNodeLink *lamp_get_visibility(GPUMaterial *mat, GPULamp *lamp, GPUNode
 				GPU_link(mat, "lamp_visibility_spot_square",
 				         GPU_dynamic_uniform(lamp->dynvec, GPU_DYNAMIC_LAMP_DYNVEC, lamp->ob),
 				         GPU_dynamic_uniform((float *)lamp->dynimat, GPU_DYNAMIC_LAMP_DYNIMAT, lamp->ob),
-				GPU_dynamic_uniform((float *)lamp->spotvec, GPU_DYNAMIC_LAMP_SPOTSCALE, lamp->ob), *lv, &inpr);
+				         GPU_dynamic_uniform((float *)lamp->spotvec, GPU_DYNAMIC_LAMP_DYNSPOTSCALE, lamp->ob), *lv, &inpr);
 			}
 			else {
 				mat->dynproperty |= DYN_LAMP_VEC | DYN_LAMP_IMAT;
 				GPU_link(mat, "lamp_visibility_spot_circle",
 				         GPU_dynamic_uniform(lamp->dynvec, GPU_DYNAMIC_LAMP_DYNVEC, lamp->ob),
-				GPU_dynamic_uniform((float *)lamp->dynimat, GPU_DYNAMIC_LAMP_DYNIMAT, lamp->ob),
-				GPU_dynamic_uniform((float *)lamp->spotvec, GPU_DYNAMIC_LAMP_SPOTSCALE, lamp->ob), *lv, &inpr);
+				         GPU_dynamic_uniform((float *)lamp->dynimat, GPU_DYNAMIC_LAMP_DYNIMAT, lamp->ob),
+				         GPU_dynamic_uniform((float *)lamp->spotvec, GPU_DYNAMIC_LAMP_DYNSPOTSCALE, lamp->ob), *lv, &inpr);
 			}
 			
 			GPU_link(mat, "lamp_visibility_spot",
-			         GPU_dynamic_uniform(&lamp->spotsi, GPU_DYNAMIC_LAMP_SPOTSIZE, lamp->ob),
-			         GPU_dynamic_uniform(&lamp->spotbl, GPU_DYNAMIC_LAMP_SPOTSIZE, lamp->ob),
+			         GPU_select_uniform(&lamp->spotsi, GPU_DYNAMIC_LAMP_SPOTSIZE, lamp->ob, ma),
+			         GPU_select_uniform(&lamp->spotbl, GPU_DYNAMIC_LAMP_SPOTSIZE, lamp->ob, ma),
 			         inpr, visifac, &visifac);
 		}
 
@@ -812,7 +889,8 @@ static void shade_light_textures(GPUMaterial *mat, GPULamp *lamp, GPUNodeLink **
 
 			GPU_link(mat, "shade_light_texture",
 			         GPU_builtin(GPU_VIEW_POSITION),
-			         GPU_image(mtex->tex->ima, &mtex->tex->iuser, false),
+			         GPU_image(mtex->tex->ima, &mtex->tex->iuser, false), GPU_uniform(mtex->size),
+					 GPU_select_uniform(&mtex->lodbias, GPU_DYNAMIC_TEX_LODBIAS, NULL, mat->ma),
 			         GPU_dynamic_uniform((float *)lamp->dynpersmat, GPU_DYNAMIC_LAMP_DYNPERSMAT, lamp->ob),
 			         &tex_rgb);
 			texture_rgb_blend(mat, tex_rgb, *rgb, GPU_uniform(&one), GPU_uniform(&mtex->colfac), mtex->blendtype, rgb);
@@ -913,11 +991,31 @@ static void shade_one_light(GPUShadeInput *shi, GPUShadeResult *shr, GPULamp *la
 				         GPU_uniform(&lamp->bias), GPU_uniform(&lamp->la->bleedbias), inp, &shadfac);
 			}
 			else {
-				GPU_link(mat, "test_shadowbuf",
-				         GPU_builtin(GPU_VIEW_POSITION),
-				         GPU_dynamic_texture(lamp->tex, GPU_DYNAMIC_SAMPLER_2DSHADOW, lamp->ob),
-				         GPU_dynamic_uniform((float *)lamp->dynpersmat, GPU_DYNAMIC_LAMP_DYNPERSMAT, lamp->ob),
-				         GPU_uniform(&lamp->bias), inp, &shadfac);
+				if (lamp->la->samp > 1 && lamp->la->soft >= 0.01f && lamp->la->shadow_filter != LA_SHADOW_FILTER_NONE) {
+					float samp = lamp->la->samp;
+					float samplesize = lamp->la->soft / lamp->la->shadow_frustum_size;
+					if (lamp->la->shadow_filter == LA_SHADOW_FILTER_PCF) {
+						GPU_link(mat, "test_shadowbuf_pcf",
+								 GPU_builtin(GPU_VIEW_POSITION),
+								 GPU_dynamic_texture(lamp->tex, GPU_DYNAMIC_SAMPLER_2DSHADOW, lamp->ob),
+								 GPU_dynamic_uniform((float *)lamp->dynpersmat, GPU_DYNAMIC_LAMP_DYNPERSMAT, lamp->ob),
+								 GPU_uniform(&samp), GPU_uniform(&samplesize), GPU_uniform(&lamp->bias), inp, &shadfac);
+					}
+					else if (lamp->la->shadow_filter == LA_SHADOW_FILTER_PCF_BAIL) {
+						GPU_link(mat, "test_shadowbuf_pcf_early_bail",
+								 GPU_builtin(GPU_VIEW_POSITION),
+								 GPU_dynamic_texture(lamp->tex, GPU_DYNAMIC_SAMPLER_2DSHADOW, lamp->ob),
+								 GPU_dynamic_uniform((float *)lamp->dynpersmat, GPU_DYNAMIC_LAMP_DYNPERSMAT, lamp->ob),
+								 GPU_uniform(&samp), GPU_uniform(&samplesize), GPU_uniform(&lamp->bias), inp, &shadfac);
+					}
+				}
+				else {
+					GPU_link(mat, "test_shadowbuf",
+				             GPU_builtin(GPU_VIEW_POSITION),
+				             GPU_dynamic_texture(lamp->tex, GPU_DYNAMIC_SAMPLER_2DSHADOW, lamp->ob),
+				             GPU_dynamic_uniform((float *)lamp->dynpersmat, GPU_DYNAMIC_LAMP_DYNPERSMAT, lamp->ob),
+				             GPU_uniform(&lamp->bias), inp, &shadfac);
+				}
 			}
 			
 			if (lamp->mode & LA_ONLYSHADOW) {
@@ -950,7 +1048,15 @@ static void shade_one_light(GPUShadeInput *shi, GPUShadeResult *shr, GPULamp *la
 	else
 		GPU_link(mat, "set_value", GPU_uniform(&one), &shadfac);
 
-	if (GPU_link_changed(shi->refl) || ma->ref != 0.0f) {
+	if (ma->sss_flag && lamp->type != LA_SPOT) {
+		GPU_link(mat, "set_sss", GPU_dynamic_uniform(&lamp->dynenergy, GPU_DYNAMIC_LAMP_DYNENERGY, lamp->ob), visifac,
+								 GPU_dynamic_uniform(lamp->dyncol, GPU_DYNAMIC_LAMP_DYNCOL, lamp->ob),
+								 GPU_uniform(&ma->sss_scale), GPU_uniform((float *)&ma->sss_radius),
+								 shi->rgb, i, view, lv, vn, &shr->combined);
+		GPU_link(mat, "shade_add", shr->combined, shr->diff, &shr->diff);
+	}		
+			
+	if (GPU_link_changed(shi->refl) || ma->ref != 0.0f || !(ma->constflag & MA_CONSTANT_MATERIAL)) {
 		if (!(lamp->mode & LA_NO_DIFF)) {
 			GPUNodeLink *rgb;
 			GPU_link(mat, "shade_mul_value", i, lcol, &rgb);
@@ -965,7 +1071,7 @@ static void shade_one_light(GPUShadeInput *shi, GPUShadeResult *shr, GPULamp *la
 		/* pass */
 	}
 	else if (!(lamp->mode & LA_NO_SPEC) && !(lamp->mode & LA_ONLYSHADOW) &&
-	         (GPU_link_changed(shi->spec) || ma->spec != 0.0f))
+		(GPU_link_changed(shi->spec) || ma->spec != 0.0f || !(ma->constflag & MA_CONSTANT_MATERIAL)))
 	{
 		if (lamp->type == LA_HEMI) {
 			GPU_link(mat, "shade_hemi_spec", vn, lv, view, GPU_uniform(&ma->spec), shi->har, visifac, &t);
@@ -1159,13 +1265,16 @@ static void do_material_tex(GPUShadeInput *shi)
 	GPUMaterial *mat = shi->gpumat;
 	MTex *mtex;
 	Tex *tex;
-	GPUNodeLink *texco, *tin, *trgb, *tnor, *tcol, *stencil, *tnorfac;
+	GPUNodeLink *texco, *tin, *trgb, *tnor, *tcol, *stencil, *tnorfac, *rotmat;
 	GPUNodeLink *texco_norm, *texco_orco, *texco_object;
 	GPUNodeLink *texco_global, *texco_uv = NULL;
 	GPUNodeLink *newnor, *orn;
 	float one = 1.0f;
+	GPUNodeLink *parco = NULL;
 	int rgbnor, talpha;
 	bool init_done = false;
+	float discard;
+	int tex_nr;
 	int iBumpSpacePrev = 0; /* Not necessary, quieting gcc warning. */
 	GPUNodeLink *vNorg, *vNacc, *fPrevMagnitude;
 	int iFirstTimeNMap = 1;
@@ -1176,7 +1285,7 @@ static void do_material_tex(GPUShadeInput *shi)
 	GPU_link(mat, "texco_norm", GPU_builtin(GPU_VIEW_NORMAL), &texco_norm);
 	GPU_link(mat, "texco_orco", GPU_attribute(CD_ORCO, ""), &texco_orco);
 	GPU_link(mat, "texco_object", GPU_builtin(GPU_INVERSE_VIEW_MATRIX),
-		GPU_builtin(GPU_INVERSE_OBJECT_MATRIX),
+		GPU_builtin((mat->use_instancing) ? GPU_INSTANCING_INVERSE_MATRIX : GPU_INVERSE_OBJECT_MATRIX),
 		GPU_builtin(GPU_VIEW_POSITION), &texco_object);
 #if 0
 	GPU_link(mat, "texco_tangent", GPU_attribute(CD_TANGENT, ""), &texco_tangent);
@@ -1185,15 +1294,52 @@ static void do_material_tex(GPUShadeInput *shi)
 		GPU_builtin(GPU_VIEW_POSITION), &texco_global);
 
 	orn = texco_norm;
+	
+	/* find parallax texco (parco) */
+	for (tex_nr = 0; tex_nr < MAX_MTEX; tex_nr++) {
+		/* separate tex switching */
+		if (ma->septex & (1 << tex_nr)) continue;
+		if (ma->mtex[tex_nr]) {
+			mtex = ma->mtex[tex_nr];
+			tex = mtex->tex;
+			if (tex == NULL || !((mtex->texflag & MTEX_PARALLAX_UV) || (mtex->mapto & MAP_PARALLAX)) || mtex->texco != TEXCO_UV) {
+				continue;
+			}
+
+			GPU_link(mat, "texco_uv", GPU_attribute(CD_MTFACE, mtex->uvname), &texco_uv);
+			texco = texco_uv;
+
+			if (mtex->mapto & MAP_PARALLAX) {
+				GPU_link(mat, "mat_math_rot", GPU_select_uniform(&mtex->rot, GPU_DYNAMIC_TEX_UVROTATION, NULL, ma), &rotmat);
+				GPU_link(mat, "mtex_mapping_transform", texco, rotmat,
+						 GPU_select_uniform(mtex->ofs, GPU_DYNAMIC_TEX_UVOFFSET, NULL, ma),
+						 GPU_select_uniform(mtex->size, GPU_DYNAMIC_TEX_UVSIZE, NULL, ma),
+						 &texco);
+
+				discard = (mtex->parflag & MTEX_DISCARD_AT_EDGES) != 0 ? 1.0f : 0.0f;
+				GPU_link(mat, "parallax_out", texco,
+					GPU_builtin(GPU_VIEW_POSITION), GPU_attribute(CD_TANGENT, ""),
+					GPU_builtin(GPU_VIEW_NORMAL),
+					GPU_select_uniform(mtex->size, GPU_DYNAMIC_TEX_UVSIZE, NULL, ma), rotmat,
+					GPU_image(tex->ima, &tex->iuser, false), 
+					GPU_uniform(&mtex->parallaxuv),
+					GPU_select_uniform(&mtex->parallaxsteps, GPU_DYNAMIC_TEX_PARALLAXSTEP, NULL, ma),
+					GPU_select_uniform(&mtex->parallaxbumpsc, GPU_DYNAMIC_TEX_PARALLAXBUMP, NULL, ma),
+					GPU_uniform(&discard),
+					&parco);
+			}
+		}
+	}
 
 	/* go over texture slots */
-	for (int tex_nr = 0; tex_nr < MAX_MTEX; tex_nr++) {
+	for (tex_nr = 0; tex_nr < MAX_MTEX; tex_nr++) {
 		/* separate tex switching */
 		if (ma->septex & (1 << tex_nr)) continue;
 		
 		if (ma->mtex[tex_nr]) {
 			mtex = ma->mtex[tex_nr];
-			
+			bool use_parallax = (mtex->texflag & MTEX_PARALLAX_UV) || (mtex->mapto & MAP_PARALLAX);
+
 			tex = mtex->tex;
 			if (tex == NULL) continue;
 
@@ -1221,22 +1367,26 @@ static void do_material_tex(GPUShadeInput *shi)
 			}
 			else
 				continue;
-
+			
+			/*if parallax has modified uv*/
+			if (use_parallax && parco) {
+				texco = parco;
+			}
 			/* in case of uv, this would just undo a multiplication in texco_uv */
 			if (mtex->texco != TEXCO_UV)
 				GPU_link(mat, "mtex_2d_mapping", texco, &texco);
 
-			if (mtex->size[0] != 1.0f || mtex->size[1] != 1.0f || mtex->size[2] != 1.0f)
-				GPU_link(mat, "mtex_mapping_size", texco, GPU_uniform(mtex->size), &texco);
-
-			float ofs[3] = {
-				mtex->ofs[0] + 0.5f - 0.5f * mtex->size[0],
-				mtex->ofs[1] + 0.5f - 0.5f * mtex->size[1],
-				0.0f
-			};
-
-			if (ofs[0] != 0.0f || ofs[1] != 0.0f || ofs[2] != 0.0f)
-				GPU_link(mat, "mtex_mapping_ofs", texco, GPU_uniform(ofs), &texco);
+			if (!use_parallax && (!(ma->constflag & MA_CONSTANT_TEXTURE_UV) ||
+				(mtex->size[0] != 1.0f || mtex->size[1] != 1.0f || mtex->size[2] != 1.0f) ||
+				(mtex->ofs[0] == 0.0f || mtex->ofs[1] == 0.0f) ||
+				(mtex->rot != 0.0f)))
+			{
+				GPU_link(mat, "mat_math_rot", GPU_select_uniform(&mtex->rot, GPU_DYNAMIC_TEX_UVROTATION, NULL, ma), &rotmat);
+				GPU_link(mat, "mtex_mapping_transform", texco, rotmat,
+						 GPU_select_uniform(mtex->ofs, GPU_DYNAMIC_TEX_UVOFFSET, NULL, ma),
+						 GPU_select_uniform(mtex->size, GPU_DYNAMIC_TEX_UVSIZE, NULL, ma),
+						 &texco);
+			}
 
 			talpha = 0;
 
@@ -1245,13 +1395,17 @@ static void do_material_tex(GPUShadeInput *shi)
 			     ((tex->type == TEX_ENVMAP) && (mtex->texco == TEXCO_REFL))))
 			{
 				if (tex->type == TEX_IMAGE) {
-					GPU_link(mat, "mtex_image", texco, GPU_image(tex->ima, &tex->iuser, false), &tin, &trgb);
+					GPU_link(mat, "mtex_image", texco, GPU_image(tex->ima, &tex->iuser, false),
+							 GPU_select_uniform(&mtex->lodbias, GPU_DYNAMIC_TEX_LODBIAS, NULL, ma), &tin, &trgb);
 				}
 				else {
-					GPU_link(mat, "mtex_cube_map_refl",
+					GPU_link(mat, "mtex_cube_map_refl_refr",
 					         GPU_cube_map(tex->ima, &tex->iuser, false), shi->view, shi->vn,
-					         GPU_builtin(GPU_INVERSE_VIEW_MATRIX),
-					         GPU_builtin(GPU_VIEW_MATRIX), &tin, &trgb);
+							 GPU_select_uniform(&mtex->lodbias, GPU_DYNAMIC_TEX_LODBIAS, NULL, ma),
+							 GPU_builtin(GPU_INVERSE_VIEW_MATRIX),
+							 GPU_select_uniform(&mtex->ior, GPU_DYNAMIC_TEX_IOR, NULL, ma),
+							 GPU_select_uniform(&mtex->refrratio, GPU_DYNAMIC_TEX_REFRRATIO, NULL, ma),
+							 &tin, &trgb);
 				}
 				rgbnor = TEX_RGB;
 
@@ -1301,7 +1455,7 @@ static void do_material_tex(GPUShadeInput *shi)
 				if ((tex->type == TEX_IMAGE) ||
 				    ((tex->type == TEX_ENVMAP) && (mtex->texco == TEXCO_REFL)))
 				{
-					if (GPU_material_do_color_management(mat)) {
+					if (GPU_material_do_color_management(mat) && !(ma->sss_flag)) {
 						GPU_link(mat, "srgb_to_linearrgb", tcol, &tcol);
 					}
 				}
@@ -1309,8 +1463,8 @@ static void do_material_tex(GPUShadeInput *shi)
 				if (mtex->mapto & MAP_COL) {
 					GPUNodeLink *colfac;
 
-					if (mtex->colfac == 1.0f) colfac = stencil;
-					else GPU_link(mat, "math_multiply", GPU_uniform(&mtex->colfac), stencil, &colfac);
+					if (mtex->colfac == 1.0f && (ma->constflag & MA_CONSTANT_TEXTURE)) colfac = stencil;
+					else GPU_link(mat, "math_multiply", GPU_select_uniform(&mtex->colfac, GPU_DYNAMIC_TEX_COLFAC, NULL, ma), stencil, &colfac);
 
 					texture_rgb_blend(mat, tcol, shi->rgb, tin, colfac, mtex->blendtype, &shi->rgb);
 				}
@@ -1318,8 +1472,8 @@ static void do_material_tex(GPUShadeInput *shi)
 				if (!(mat->scene->gm.flag & GAME_GLSL_NO_EXTRA_TEX) && (mtex->mapto & MAP_COLSPEC)) {
 					GPUNodeLink *colspecfac;
 
-					if (mtex->colspecfac == 1.0f) colspecfac = stencil;
-					else GPU_link(mat, "math_multiply", GPU_uniform(&mtex->colspecfac), stencil, &colspecfac);
+					if (mtex->colspecfac == 1.0f && (ma->constflag & MA_CONSTANT_TEXTURE)) colspecfac = stencil;
+					else GPU_link(mat, "math_multiply", GPU_select_uniform(&mtex->colspecfac, GPU_DYNAMIC_TEX_SPECFAC, NULL, ma), stencil, &colspecfac);
 
 					texture_rgb_blend(mat, tcol, shi->specrgb, tin, colspecfac, mtex->blendtype, &shi->specrgb);
 				}
@@ -1327,8 +1481,8 @@ static void do_material_tex(GPUShadeInput *shi)
 				if (mtex->mapto & MAP_COLMIR) {
 					GPUNodeLink *colmirfac;
 
-					if (mtex->mirrfac == 1.0f) colmirfac = stencil;
-					else GPU_link(mat, "math_multiply", GPU_uniform(&mtex->mirrfac), stencil, &colmirfac);
+					if (mtex->mirrfac == 1.0f && (ma->constflag & MA_CONSTANT_TEXTURE)) colmirfac = stencil;
+					else GPU_link(mat, "math_multiply", GPU_select_uniform(&mtex->mirrfac, GPU_DYNAMIC_TEX_MIRROR, NULL, ma), stencil, &colmirfac);
 
 					/* exception for envmap only */
 					if (tex->type == TEX_ENVMAP && mtex->blendtype == MTEX_BLEND) {
@@ -1345,7 +1499,8 @@ static void do_material_tex(GPUShadeInput *shi)
 
 					if (tex->imaflag & TEX_NORMALMAP) {
 						/* normalmap image */
-						GPU_link(mat, "mtex_normal", texco, GPU_image(tex->ima, &tex->iuser, true), &tnor);
+						GPU_link(mat, "mtex_normal", texco, GPU_image(tex->ima, &tex->iuser, true),
+								 GPU_select_uniform(&mtex->lodbias, GPU_DYNAMIC_TEX_LODBIAS, NULL, ma), &tnor);
 						
 						if (mtex->norfac < 0.0f)
 							GPU_link(mat, "mtex_negate_texnormal", tnor, &tnor);
@@ -1380,12 +1535,12 @@ static void do_material_tex(GPUShadeInput *shi)
 						
 						float norfac = min_ff(fabsf(mtex->norfac), 1.0f);
 						
-						if (norfac == 1.0f && !GPU_link_changed(stencil)) {
+						if (norfac == 1.0f && !GPU_link_changed(stencil) && (ma->constflag & MA_CONSTANT_TEXTURE)) {
 							shi->vn = newnor;
 						}
 						else {
-							tnorfac = GPU_uniform(&norfac);
-	
+							tnorfac = GPU_select_uniform(&mtex->norfac, GPU_DYNAMIC_TEX_NORMAL, NULL, ma);
+
 							if (GPU_link_changed(stencil))
 								GPU_link(mat, "math_multiply", tnorfac, stencil, &tnorfac);
 	
@@ -1466,8 +1621,8 @@ static void do_material_tex(GPUShadeInput *shi)
 								         surf_pos, vNorg,
 								         GPU_builtin(GPU_VIEW_MATRIX),
 								         GPU_builtin(GPU_INVERSE_VIEW_MATRIX),
-								         GPU_builtin(GPU_OBJECT_MATRIX),
-								         GPU_builtin(GPU_INVERSE_OBJECT_MATRIX),
+								         GPU_builtin((mat->use_instancing) ? GPU_INSTANCING_MATRIX : GPU_OBJECT_MATRIX),
+								         GPU_builtin((mat->use_instancing) ? GPU_INSTANCING_INVERSE_MATRIX : GPU_INVERSE_OBJECT_MATRIX),
 								         fPrevMagnitude, vNacc,
 								         &fPrevMagnitude, &vNacc,
 								         &vR1, &vR2, &fDet);
@@ -1494,25 +1649,30 @@ static void do_material_tex(GPUShadeInput *shi)
 							GPU_link(mat, "mtex_bump_deriv",
 							         texco, GPU_image(tex->ima, &tex->iuser, true),
 							         GPU_uniform(&ima_x), GPU_uniform(&ima_y), tnorfac,
+									 GPU_select_uniform(&mtex->lodbias, GPU_DYNAMIC_TEX_LODBIAS, NULL, ma),
 							         &dBs, &dBt);
 						}
 						else if (mtex->texflag & MTEX_3TAP_BUMP)
 							GPU_link(mat, "mtex_bump_tap3",
 							         texco, GPU_image(tex->ima, &tex->iuser, true), tnorfac,
+									 GPU_select_uniform(&mtex->lodbias, GPU_DYNAMIC_TEX_LODBIAS, NULL, ma),
 							         &dBs, &dBt);
 						else if (mtex->texflag & MTEX_5TAP_BUMP)
 							GPU_link(mat, "mtex_bump_tap5",
 							         texco, GPU_image(tex->ima, &tex->iuser, true), tnorfac,
+									 GPU_select_uniform(&mtex->lodbias, GPU_DYNAMIC_TEX_LODBIAS, NULL, ma),
 							         &dBs, &dBt);
 						else if (mtex->texflag & MTEX_BICUBIC_BUMP) {
 							if (GPU_bicubic_bump_support()) {
 								GPU_link(mat, "mtex_bump_bicubic",
 								         texco, GPU_image(tex->ima, &tex->iuser, true), tnorfac,
+										 GPU_select_uniform(&mtex->lodbias, GPU_DYNAMIC_TEX_LODBIAS, NULL, ma),
 								         &dBs, &dBt);
 							}
 							else {
 								GPU_link(mat, "mtex_bump_tap5",
 								         texco, GPU_image(tex->ima, &tex->iuser, true), tnorfac,
+										 GPU_select_uniform(&mtex->lodbias, GPU_DYNAMIC_TEX_LODBIAS, NULL, ma),
 								         &dBs, &dBt);
 							}
 						}
@@ -1549,8 +1709,8 @@ static void do_material_tex(GPUShadeInput *shi)
 				if (!(mat->scene->gm.flag & GAME_GLSL_NO_EXTRA_TEX) && mtex->mapto & MAP_REF) {
 					GPUNodeLink *difffac;
 
-					if (mtex->difffac == 1.0f) difffac = stencil;
-					else GPU_link(mat, "math_multiply", GPU_uniform(&mtex->difffac), stencil, &difffac);
+					if (mtex->difffac == 1.0f && (ma->constflag & MA_CONSTANT_TEXTURE)) difffac = stencil;
+					else GPU_link(mat, "math_multiply", GPU_select_uniform(&mtex->difffac, GPU_DYNAMIC_TEX_COLINTENS, NULL, ma), stencil, &difffac);
 
 					texture_value_blend(
 					        mat, GPU_uniform(&mtex->def_var), shi->refl, tin, difffac,
@@ -1560,8 +1720,8 @@ static void do_material_tex(GPUShadeInput *shi)
 				if (!(mat->scene->gm.flag & GAME_GLSL_NO_EXTRA_TEX) && mtex->mapto & MAP_SPEC) {
 					GPUNodeLink *specfac;
 
-					if (mtex->specfac == 1.0f) specfac = stencil;
-					else GPU_link(mat, "math_multiply", GPU_uniform(&mtex->specfac), stencil, &specfac);
+					if (mtex->specfac == 1.0f && (ma->constflag & MA_CONSTANT_TEXTURE)) specfac = stencil;
+					else GPU_link(mat, "math_multiply", GPU_select_uniform(&mtex->specfac, GPU_DYNAMIC_TEX_SPECINTENS, NULL, ma), stencil, &specfac);
 
 					texture_value_blend(
 					        mat, GPU_uniform(&mtex->def_var), shi->spec, tin, specfac,
@@ -1571,8 +1731,8 @@ static void do_material_tex(GPUShadeInput *shi)
 				if (!(mat->scene->gm.flag & GAME_GLSL_NO_EXTRA_TEX) && mtex->mapto & MAP_EMIT) {
 					GPUNodeLink *emitfac;
 
-					if (mtex->emitfac == 1.0f) emitfac = stencil;
-					else GPU_link(mat, "math_multiply", GPU_uniform(&mtex->emitfac), stencil, &emitfac);
+					if (mtex->emitfac == 1.0f && (ma->constflag & MA_CONSTANT_TEXTURE)) emitfac = stencil;
+					else GPU_link(mat, "math_multiply", GPU_select_uniform(&mtex->emitfac, GPU_DYNAMIC_TEX_EMIT, NULL, ma), stencil, &emitfac);
 
 					texture_value_blend(
 					        mat, GPU_uniform(&mtex->def_var), shi->emit, tin, emitfac,
@@ -1582,8 +1742,8 @@ static void do_material_tex(GPUShadeInput *shi)
 				if (!(mat->scene->gm.flag & GAME_GLSL_NO_EXTRA_TEX) && mtex->mapto & MAP_HAR) {
 					GPUNodeLink *hardfac;
 
-					if (mtex->hardfac == 1.0f) hardfac = stencil;
-					else GPU_link(mat, "math_multiply", GPU_uniform(&mtex->hardfac), stencil, &hardfac);
+					if (mtex->hardfac == 1.0f && (ma->constflag & MA_CONSTANT_TEXTURE)) hardfac = stencil;
+					else GPU_link(mat, "math_multiply", GPU_select_uniform(&mtex->hardfac, GPU_DYNAMIC_TEX_HARDNESS, NULL, ma), stencil, &hardfac);
 
 					GPU_link(mat, "mtex_har_divide", shi->har, &shi->har);
 					texture_value_blend(
@@ -1594,8 +1754,8 @@ static void do_material_tex(GPUShadeInput *shi)
 				if (mtex->mapto & MAP_ALPHA) {
 					GPUNodeLink *alphafac;
 
-					if (mtex->alphafac == 1.0f) alphafac = stencil;
-					else GPU_link(mat, "math_multiply", GPU_uniform(&mtex->alphafac), stencil, &alphafac);
+					if (mtex->alphafac == 1.0f && (ma->constflag & MA_CONSTANT_TEXTURE)) alphafac = stencil;
+					else GPU_link(mat, "math_multiply", GPU_select_uniform(&mtex->alphafac, GPU_DYNAMIC_TEX_ALPHA, NULL, ma), stencil, &alphafac);
 
 					texture_value_blend(
 					        mat, GPU_uniform(&mtex->def_var), shi->alpha, tin, alphafac,
@@ -1627,26 +1787,26 @@ void GPU_shadeinput_set(GPUMaterial *mat, Material *ma, GPUShadeInput *shi)
 	shi->gpumat = mat;
 	shi->mat = ma;
 
-	GPU_link(mat, "set_rgb", GPU_dynamic_uniform(&ma->r, GPU_DYNAMIC_MAT_DIFFRGB, ma), &shi->rgb);
-	GPU_link(mat, "set_rgb", GPU_dynamic_uniform(&ma->specr, GPU_DYNAMIC_MAT_SPECRGB, ma), &shi->specrgb);
-	GPU_link(mat, "set_rgb", GPU_dynamic_uniform(&ma->mirr, GPU_DYNAMIC_MAT_MIR, ma), &shi->mir);
+	GPU_link(mat, "set_rgb", GPU_select_uniform(&ma->r, GPU_DYNAMIC_MAT_DIFFRGB, ma, ma), &shi->rgb);
+	GPU_link(mat, "set_rgb", GPU_select_uniform(&ma->specr, GPU_DYNAMIC_MAT_SPECRGB, ma, ma), &shi->specrgb);
+	GPU_link(mat, "set_rgb", GPU_select_uniform(&ma->mirr, GPU_DYNAMIC_MAT_MIR, ma, ma), &shi->mir);
 	GPU_link(mat, "set_rgba_zero", &shi->refcol);
 	GPU_link(mat, "shade_norm", GPU_builtin(GPU_VIEW_NORMAL), &shi->vn);
 
 	if (mat->alpha)
-		GPU_link(mat, "set_value", GPU_dynamic_uniform(&ma->alpha, GPU_DYNAMIC_MAT_ALPHA, ma), &shi->alpha);
+		GPU_link(mat, "set_value", GPU_select_uniform(&ma->alpha, GPU_DYNAMIC_MAT_ALPHA, ma, ma), &shi->alpha);
 	else
 		GPU_link(mat, "set_value", GPU_uniform(&one), &shi->alpha);
 
-	GPU_link(mat, "set_value", GPU_dynamic_uniform(&ma->ref, GPU_DYNAMIC_MAT_REF, ma), &shi->refl);
-	GPU_link(mat, "set_value", GPU_dynamic_uniform(&ma->spec, GPU_DYNAMIC_MAT_SPEC, ma), &shi->spec);
-	GPU_link(mat, "set_value", GPU_dynamic_uniform(&ma->emit, GPU_DYNAMIC_MAT_EMIT, ma), &shi->emit);
-	GPU_link(mat, "set_value", GPU_dynamic_uniform((float *)&ma->har, GPU_DYNAMIC_MAT_HARD, ma), &shi->har);
-	GPU_link(mat, "set_value", GPU_dynamic_uniform(&ma->amb, GPU_DYNAMIC_MAT_AMB, ma), &shi->amb);
-	GPU_link(mat, "set_value", GPU_uniform(&ma->spectra), &shi->spectra);
+	GPU_link(mat, "set_value", GPU_select_uniform(&ma->ref, GPU_DYNAMIC_MAT_REF, ma, ma), &shi->refl);
+	GPU_link(mat, "set_value", GPU_select_uniform(&ma->spec, GPU_DYNAMIC_MAT_SPEC, ma, ma), &shi->spec);
+	GPU_link(mat, "set_value", GPU_select_uniform(&ma->emit, GPU_DYNAMIC_MAT_EMIT, ma, ma), &shi->emit);
+	GPU_link(mat, "set_value", GPU_select_uniform(&mat->har, GPU_DYNAMIC_MAT_HARD, ma, ma), &shi->har);
+	GPU_link(mat, "set_value", GPU_select_uniform(&ma->amb, GPU_DYNAMIC_MAT_AMB, ma, ma), &shi->amb);
+	GPU_link(mat, "set_value", GPU_select_uniform(&ma->spectra, GPU_DYNAMIC_MAT_SPECTRA, ma, ma), &shi->spectra);
 	GPU_link(mat, "shade_view", GPU_builtin(GPU_VIEW_POSITION), &shi->view);
 	GPU_link(mat, "vcol_attribute", GPU_attribute(CD_MCOL, ""), &shi->vcol);
-	if (GPU_material_do_color_management(mat))
+	if (GPU_material_do_color_management(mat) && !(ma->sss_flag))
 		GPU_link(mat, "srgb_to_linearrgb", shi->vcol, &shi->vcol);
 	GPU_link(mat, "texco_refl", shi->vn, shi->view, &shi->ref);
 }
@@ -1682,14 +1842,20 @@ void GPU_zenith_update_color(float color[3])
 	copy_v3_v3(GPUWorld.zencol, color);
 }
 
+void GPU_update_exposure_range(float exp, float range)
+{
+	GPUWorld.linfac = 1.0f + powf((2.0f * exp + 0.5f), -10.0f);
+	GPUWorld.logfac = log((GPUWorld.linfac - 1.0f) / GPUWorld.linfac) / range;
+}
+
 void GPU_shaderesult_set(GPUShadeInput *shi, GPUShadeResult *shr)
 {
 	GPUMaterial *mat = shi->gpumat;
-	GPUNodeLink *emit, *ulinfac, *ulogfac, *mistfac;
+	GPUNodeLink *emit, *mistfac;
 	Material *ma = shi->mat;
 	World *world = mat->scene->world;
-	float linfac, logfac;
 
+	mat->dynproperty |= DYN_LAMP_CO;
 	memset(shr, 0, sizeof(*shr));
 
 	if (ma->mode & MA_VERTEXCOLP)
@@ -1704,7 +1870,7 @@ void GPU_shaderesult_set(GPUShadeInput *shi, GPUShadeResult *shr)
 		shr->combined = shr->diff;
 	}
 	else {
-		if (GPU_link_changed(shi->emit) || ma->emit != 0.0f) {
+		if (GPU_link_changed(shi->emit) || ma->emit != 0.0f || !(ma->constflag & MA_CONSTANT_MATERIAL)) {
 			if ((ma->mode & (MA_VERTEXCOL | MA_VERTEXCOLP)) == MA_VERTEXCOL) {
 				GPU_link(mat, "shade_add", shi->emit, shi->vcol, &emit);
 				GPU_link(mat, "shade_mul", emit, shi->rgb, &shr->diff);
@@ -1725,18 +1891,14 @@ void GPU_shaderesult_set(GPUShadeInput *shi, GPUShadeResult *shr)
 
 		if (world) {
 			/* exposure correction */
-			if (world->exp != 0.0f || world->range != 1.0f) {
-				linfac = 1.0f + powf((2.0f * world->exp + 0.5f), -10);
-				logfac = logf((linfac - 1.0f) / linfac) / world->range;
-
-				GPU_link(mat, "set_value", GPU_uniform(&linfac), &ulinfac);
-				GPU_link(mat, "set_value", GPU_uniform(&logfac), &ulogfac);
-
-				GPU_link(mat, "shade_exposure_correct", shr->combined,
-					ulinfac, ulogfac, &shr->combined);
-				GPU_link(mat, "shade_exposure_correct", shr->spec,
-					ulinfac, ulogfac, &shr->spec);
-			}
+			GPU_link(mat, "shade_exposure_correct", shr->combined,
+					 GPU_select_uniform(&GPUWorld.linfac, GPU_DYNAMIC_WORLD_LINFAC, NULL, ma),
+					 GPU_select_uniform(&GPUWorld.logfac, GPU_DYNAMIC_WORLD_LOGFAC, NULL, ma),
+					 &shr->combined);
+			GPU_link(mat, "shade_exposure_correct", shr->spec,
+					 GPU_select_uniform(&GPUWorld.linfac, GPU_DYNAMIC_WORLD_LINFAC, NULL, ma),
+					 GPU_select_uniform(&GPUWorld.logfac, GPU_DYNAMIC_WORLD_LOGFAC, NULL, ma),
+					 &shr->spec);
 
 			/* environment lighting */
 			if (!(mat->scene->gm.flag & GAME_GLSL_NO_ENV_LIGHTING) &&
@@ -1754,8 +1916,8 @@ void GPU_shaderesult_set(GPUShadeInput *shi, GPUShadeResult *shr)
 							GPU_link(mat, "math_multiply", f, GPU_uniform(&world->ao_env_energy), &f);
 							GPU_link(mat, "shade_mul_value", f, shi->rgb, &fcol);
 							GPU_link(mat, "env_apply", shr->combined,
-							         GPU_dynamic_uniform(GPUWorld.horicol, GPU_DYNAMIC_HORIZON_COLOR, NULL),
-							         GPU_dynamic_uniform(GPUWorld.zencol, GPU_DYNAMIC_ZENITH_COLOR, NULL), fcol,
+							         GPU_select_uniform(GPUWorld.horicol, GPU_DYNAMIC_HORIZON_COLOR, NULL, ma),
+							         GPU_select_uniform(GPUWorld.zencol, GPU_DYNAMIC_ZENITH_COLOR, NULL, ma), fcol,
 							         GPU_builtin(GPU_VIEW_MATRIX), shi->vn, &shr->combined);
 						}
 					}
@@ -1769,15 +1931,15 @@ void GPU_shaderesult_set(GPUShadeInput *shi, GPUShadeResult *shr)
 			}
 
 			/* ambient color */
-			if (GPU_link_changed(shi->amb) || ma->amb != 0.0f) {
-				GPU_link(mat, "shade_maddf", shr->combined, GPU_uniform(&ma->amb),
-				         GPU_dynamic_uniform(GPUWorld.ambcol, GPU_DYNAMIC_AMBIENT_COLOR, NULL),
+			if (GPU_link_changed(shi->amb) || ma->amb != 0.0f || !(ma->constflag & MA_CONSTANT_MATERIAL)) {
+				GPU_link(mat, "shade_maddf", shr->combined, GPU_select_uniform(&ma->amb, GPU_DYNAMIC_MAT_AMB, NULL, ma),
+				         GPU_select_uniform(GPUWorld.ambcol, GPU_DYNAMIC_AMBIENT_COLOR, NULL, ma),
 				         &shr->combined);
 			}
 		}
 
 		if (ma->mode & MA_TRANSP && (ma->mode & (MA_ZTRANSP | MA_RAYTRANSP))) {
-			if (GPU_link_changed(shi->spectra) || ma->spectra != 0.0f) {
+			if (GPU_link_changed(shi->spectra) || ma->spectra != 0.0f || !(ma->constflag & MA_CONSTANT_MATERIAL)) {
 				GPU_link(mat, "alpha_spec_correction", shr->spec, shi->spectra,
 				         shi->alpha, &shr->alpha);
 			}
@@ -1789,30 +1951,39 @@ void GPU_shaderesult_set(GPUShadeInput *shi, GPUShadeResult *shr)
 		if (GPU_link_changed(shi->refcol))
 			GPU_link(mat, "shade_add_mirror", shi->mir, shi->refcol, shr->combined, &shr->combined);
 
-		if (GPU_link_changed(shi->spec) || ma->spec != 0.0f)
+		if (GPU_link_changed(shi->spec) || ma->spec != 0.0f || !(ma->constflag & MA_CONSTANT_MATERIAL))
 			GPU_link(mat, "shade_add", shr->combined, shr->spec, &shr->combined);
 	}
 
+	if (ma->mode & MA_TRANSP && ma->mode2 & MA_DEPTH_TRANSP) {
+		GPU_link(mat, "shade_alpha_depth",
+				 GPU_builtin(GPU_VIEW_POSITION),
+				 GPU_dynamic_texture_ptr(GPU_texture_global_depth_ptr(), GPU_DYNAMIC_SAMPLER_2DBUFFER, ma),
+				 shi->alpha, GPU_uniform(&ma->depthtranspfactor), &shr->alpha);
+	}
+
 	GPU_link(mat, "mtex_alpha_to_col", shr->combined, shr->alpha, &shr->combined);
 
-	if (ma->shade_flag & MA_OBCOLOR)
-		GPU_link(mat, "shade_obcolor", shr->combined, GPU_builtin(GPU_OBCOLOR), &shr->combined);
+	if (ma->shade_flag & MA_OBCOLOR) {
+		GPU_link(mat, "shade_obcolor", shr->combined, 
+			GPU_builtin((mat->use_instancing) ? GPU_INSTANCING_COLOR : GPU_OBCOLOR), &shr->combined);
+	}
 
 	if (!(ma->mode & MA_NOMIST)) {
 		GPU_link(mat, "shade_mist_factor", GPU_builtin(GPU_VIEW_POSITION),
-		         GPU_dynamic_uniform(&GPUWorld.mistenabled, GPU_DYNAMIC_MIST_ENABLE, NULL),
-		         GPU_dynamic_uniform(&GPUWorld.miststart, GPU_DYNAMIC_MIST_START, NULL),
-		         GPU_dynamic_uniform(&GPUWorld.mistdistance, GPU_DYNAMIC_MIST_DISTANCE, NULL),
-		         GPU_dynamic_uniform(&GPUWorld.mistype, GPU_DYNAMIC_MIST_TYPE, NULL),
-		         GPU_dynamic_uniform(&GPUWorld.mistintensity, GPU_DYNAMIC_MIST_INTENSITY, NULL), &mistfac);
+		         GPU_select_uniform(&GPUWorld.mistenabled, GPU_DYNAMIC_MIST_ENABLE, NULL, ma),
+		         GPU_select_uniform(&GPUWorld.miststart, GPU_DYNAMIC_MIST_START, NULL, ma),
+		         GPU_select_uniform(&GPUWorld.mistdistance, GPU_DYNAMIC_MIST_DISTANCE, NULL, ma),
+		         GPU_select_uniform(&GPUWorld.mistype, GPU_DYNAMIC_MIST_TYPE, NULL, ma),
+		         GPU_select_uniform(&GPUWorld.mistintensity, GPU_DYNAMIC_MIST_INTENSITY, NULL, ma), &mistfac);
 
 		GPU_link(mat, "mix_blend", mistfac, shr->combined,
-		         GPU_dynamic_uniform(GPUWorld.mistcol, GPU_DYNAMIC_MIST_COLOR, NULL), &shr->combined);
+		         GPU_select_uniform(GPUWorld.mistcol, GPU_DYNAMIC_MIST_COLOR, NULL, ma), &shr->combined);
 	}
 
 	if (!mat->alpha) {
 		if (world && (GPU_link_changed(shr->alpha) || ma->alpha != 1.0f))
-			GPU_link(mat, "shade_world_mix", GPU_dynamic_uniform(GPUWorld.horicol, GPU_DYNAMIC_HORIZON_COLOR, NULL),
+			GPU_link(mat, "shade_world_mix", GPU_select_uniform(GPUWorld.horicol, GPU_DYNAMIC_HORIZON_COLOR, NULL, ma),
 			         shr->combined, &shr->combined);
 
 		GPU_link(mat, "shade_alpha_opaque", shr->combined, &shr->combined);
@@ -1820,7 +1991,8 @@ void GPU_shaderesult_set(GPUShadeInput *shi, GPUShadeResult *shr)
 
 	if (ma->shade_flag & MA_OBCOLOR) {
 		mat->obcolalpha = 1;
-		GPU_link(mat, "shade_alpha_obcolor", shr->combined, GPU_builtin(GPU_OBCOLOR), &shr->combined);
+		GPU_link(mat, "shade_alpha_obcolor", shr->combined, 
+			GPU_builtin((mat->use_instancing) ? GPU_INSTANCING_COLOR : GPU_OBCOLOR), &shr->combined);
 	}
 }
 
@@ -1960,16 +2132,16 @@ static void do_world_tex(GPUShadeInput *shi, struct World *wo, GPUNodeLink **hor
 			if (ofs[0] != 0.0f || ofs[1] != 0.0f || ofs[2] != 0.0f)
 				GPU_link(mat, "mtex_mapping_ofs", texco, GPU_uniform(ofs), &texco);
 			if (mtex->texco == TEXCO_EQUIRECTMAP) {
-				GPU_link(mat, "node_tex_environment_equirectangular", texco, GPU_image(tex->ima, &tex->iuser, false), &trgb);
+				GPU_link(mat, "node_tex_environment_equirectangular", texco, GPU_image(tex->ima, &tex->iuser, false), GPU_uniform(&mtex->lodbias), &trgb);
 			}
 			else if (mtex->texco == TEXCO_ANGMAP) {
-				GPU_link(mat, "node_tex_environment_mirror_ball", texco, GPU_image(tex->ima, &tex->iuser, false), &trgb);
+				GPU_link(mat, "node_tex_environment_mirror_ball", texco, GPU_image(tex->ima, &tex->iuser, false), GPU_uniform(&mtex->lodbias), &trgb);
 			}
 			else {
 				if (tex->type == TEX_ENVMAP)
-					GPU_link(mat, "mtex_cube_map", texco, GPU_cube_map(tex->ima, &tex->iuser, false), &tin, &trgb);
+					GPU_link(mat, "mtex_cube_map", texco, GPU_cube_map(tex->ima, &tex->iuser, false), GPU_uniform(&mtex->lodbias), &tin, &trgb);
 				else if (tex->type == TEX_IMAGE)
-					GPU_link(mat, "mtex_image", texco, GPU_image(tex->ima, &tex->iuser, false), &tin, &trgb);
+					GPU_link(mat, "mtex_image", texco, GPU_image(tex->ima, &tex->iuser, false), GPU_uniform(&mtex->lodbias), &tin, &trgb);
 			}
 			rgbnor = TEX_RGB;
 			if (tex->type == TEX_IMAGE || tex->type == TEX_ENVMAP)
@@ -2136,13 +2308,21 @@ GPUMaterial *GPU_material_world(struct Scene *scene, struct World *wo)
 }
 
 
-GPUMaterial *GPU_material_from_blender(Scene *scene, Material *ma, bool use_opensubdiv)
+GPUMaterial *GPU_material_from_blender(Scene *scene, Material *ma, bool use_opensubdiv, bool is_instancing)
 {
 	GPUMaterial *mat;
 	GPUNodeLink *outlink;
 	LinkData *link;
+	ListBase *gpumaterials;
 
-	for (link = ma->gpumaterial.first; link; link = link->next) {
+	if (is_instancing) {
+		gpumaterials = &ma->gpumaterialinstancing;
+	}
+	else {
+		gpumaterials = &ma->gpumaterial;
+	}
+
+	for (link = gpumaterials->first; link; link = link->next) {
 		GPUMaterial *current_material = (GPUMaterial *)link->data;
 		if (current_material->scene == scene &&
 		    current_material->is_opensubdiv == use_opensubdiv)
@@ -2155,7 +2335,9 @@ GPUMaterial *GPU_material_from_blender(Scene *scene, Material *ma, bool use_open
 	mat = GPU_material_construct_begin(ma);
 	mat->scene = scene;
 	mat->type = GPU_MATERIAL_TYPE_MESH;
+	mat->use_instancing = is_instancing;
 	mat->is_opensubdiv = use_opensubdiv;
+	mat->har = ma->har;
 
 	/* render pipeline option */
 	bool new_shading_nodes = BKE_scene_use_new_shading_nodes(scene);
@@ -2184,7 +2366,7 @@ GPUMaterial *GPU_material_from_blender(Scene *scene, Material *ma, bool use_open
 		GPU_material_output_link(mat, outlink);
 	}
 
-	if (GPU_material_do_color_management(mat))
+	if (GPU_material_do_color_management(mat) && !(ma->sss_flag))
 		if (mat->outlink)
 			GPU_link(mat, "linearrgb_to_srgb", mat->outlink, &mat->outlink);
 
@@ -2196,7 +2378,7 @@ GPUMaterial *GPU_material_from_blender(Scene *scene, Material *ma, bool use_open
 
 	link = MEM_callocN(sizeof(LinkData), "GPUMaterialLink");
 	link->data = mat;
-	BLI_addtail(&ma->gpumaterial, link);
+	BLI_addtail(gpumaterials, link);
 
 	return mat;
 }
@@ -2208,13 +2390,16 @@ void GPU_materials_free(void)
 	World *wo;
 	extern Material defmaterial;
 
-	for (ma = G.main->mat.first; ma; ma = ma->id.next)
+	for (ma = G.main->mat.first; ma; ma = ma->id.next) {
 		GPU_material_free(&ma->gpumaterial);
+		GPU_material_free(&ma->gpumaterialinstancing);
+	}
 
 	for (wo = G.main->world.first; wo; wo = wo->id.next)
 		GPU_material_free(&wo->gpumaterial);
 	
 	GPU_material_free(&defmaterial.gpumaterial);
+	GPU_material_free(&defmaterial.gpumaterialinstancing);
 
 	for (ob = G.main->object.first; ob; ob = ob->id.next)
 		GPU_lamp_free(ob);
@@ -2403,7 +2588,7 @@ GPULamp *GPU_lamp_from_blender(Scene *scene, Object *ob, Object *par)
 
 		if (lamp->la->shadowmap_type == LA_SHADMAP_VARIANCE) {
 			/* Shadow depth map */
-			lamp->depthtex = GPU_texture_create_depth(lamp->size, lamp->size, NULL);
+			lamp->depthtex = GPU_texture_create_depth(lamp->size, lamp->size, true, NULL);
 			if (!lamp->depthtex) {
 				gpu_lamp_shadow_free(lamp);
 				return lamp;
@@ -2460,7 +2645,7 @@ GPULamp *GPU_lamp_from_blender(Scene *scene, Object *ob, Object *par)
 			GPU_framebuffer_texture_unbind(lamp->blurfb, lamp->blurtex);
 		}
 		else {
-			lamp->tex = GPU_texture_create_depth(lamp->size, lamp->size, NULL);
+			lamp->tex = GPU_texture_create_depth(lamp->size, lamp->size, true, NULL);
 			if (!lamp->tex) {
 				gpu_lamp_shadow_free(lamp);
 				return lamp;
@@ -2509,6 +2694,8 @@ void GPU_lamp_free(Object *ob)
 
 			if (ma->gpumaterial.first)
 				GPU_material_free(&ma->gpumaterial);
+			if (ma->gpumaterialinstancing.first)
+				GPU_material_free(&ma->gpumaterialinstancing);
 		}
 
 		gpu_lamp_shadow_free(lamp);
@@ -2558,8 +2745,6 @@ void GPU_lamp_shadow_buffer_bind(GPULamp *lamp, float viewmat[4][4], int *winsiz
 	/* opengl */
 	glDisable(GL_SCISSOR_TEST);
 	GPU_texture_bind_as_framebuffer(lamp->tex);
-	if (lamp->la->shadowmap_type == LA_SHADMAP_VARIANCE)
-		GPU_shader_bind(GPU_shader_get_builtin_shader(GPU_SHADER_VSM_STORE));
 
 	/* set matrices */
 	copy_m4_m4(viewmat, lamp->viewmat);
@@ -2571,7 +2756,7 @@ void GPU_lamp_shadow_buffer_unbind(GPULamp *lamp)
 {
 	if (lamp->la->shadowmap_type == LA_SHADMAP_VARIANCE) {
 		GPU_shader_unbind();
-		GPU_framebuffer_blur(lamp->fb, lamp->tex, lamp->blurfb, lamp->blurtex);
+		GPU_framebuffer_blur(lamp->fb, lamp->tex, lamp->blurfb, lamp->blurtex, lamp->la->bufsharp);
 	}
 
 	GPU_framebuffer_texture_unbind(lamp->fb, lamp->tex);
@@ -2607,6 +2792,7 @@ GPUNodeLink *GPU_lamp_get_data(
         GPUNodeLink **r_col, GPUNodeLink **r_lv, GPUNodeLink **r_dist, GPUNodeLink **r_shadow, GPUNodeLink **r_energy)
 {
 	GPUNodeLink *visifac;
+	GPUNodeLink *shadowfac;
 
 	*r_col = GPU_dynamic_uniform(lamp->dyncol, GPU_DYNAMIC_LAMP_DYNCOL, lamp->ob);
 	*r_energy = GPU_dynamic_uniform(&lamp->dynenergy, GPU_DYNAMIC_LAMP_DYNENERGY, lamp->ob);
@@ -2622,20 +2808,40 @@ GPUNodeLink *GPU_lamp_get_data(
 		mat->dynproperty |= DYN_LAMP_PERSMAT;
 
 		if (lamp->la->shadowmap_type == LA_SHADMAP_VARIANCE) {
-			GPU_link(mat, "shadows_only_vsm",
+			GPU_link(mat, "test_shadowbuf_vsm",
 			         GPU_builtin(GPU_VIEW_POSITION),
 			         GPU_dynamic_texture(lamp->tex, GPU_DYNAMIC_SAMPLER_2DSHADOW, lamp->ob),
 			         GPU_dynamic_uniform((float *)lamp->dynpersmat, GPU_DYNAMIC_LAMP_DYNPERSMAT, lamp->ob),
-			         GPU_uniform(&lamp->bias), GPU_uniform(&lamp->la->bleedbias),
-			         GPU_uniform(lamp->shadow_color), inp, r_shadow);
+			         GPU_uniform(&lamp->bias), GPU_uniform(&lamp->la->bleedbias), inp, &shadowfac);
 		}
 		else {
-			GPU_link(mat, "shadows_only",
-			         GPU_builtin(GPU_VIEW_POSITION),
-			         GPU_dynamic_texture(lamp->tex, GPU_DYNAMIC_SAMPLER_2DSHADOW, lamp->ob),
-			         GPU_dynamic_uniform((float *)lamp->dynpersmat, GPU_DYNAMIC_LAMP_DYNPERSMAT, lamp->ob),
-			         GPU_uniform(&lamp->bias), GPU_uniform(lamp->shadow_color), inp, r_shadow);
+			if (lamp->la->samp > 1 && lamp->la->soft >= 0.01f && lamp->la->shadow_filter != LA_SHADOW_FILTER_NONE) {
+				float samp = lamp->la->samp;
+				float samplesize = lamp->la->soft / lamp->la->shadow_frustum_size;
+				if (lamp->la->shadow_filter == LA_SHADOW_FILTER_PCF) {
+					GPU_link(mat, "test_shadowbuf_pcf",
+							 GPU_builtin(GPU_VIEW_POSITION),
+							 GPU_dynamic_texture(lamp->tex, GPU_DYNAMIC_SAMPLER_2DSHADOW, lamp->ob),
+							 GPU_dynamic_uniform((float *)lamp->dynpersmat, GPU_DYNAMIC_LAMP_DYNPERSMAT, lamp->ob),
+							 GPU_uniform(&samp), GPU_uniform(&samplesize), GPU_uniform(&lamp->bias), inp, &shadowfac);
+				}
+				else if (lamp->la->shadow_filter == LA_SHADOW_FILTER_PCF_BAIL) {
+					GPU_link(mat, "test_shadowbuf_pcf_early_bail",
+							 GPU_builtin(GPU_VIEW_POSITION),
+							 GPU_dynamic_texture(lamp->tex, GPU_DYNAMIC_SAMPLER_2DSHADOW, lamp->ob),
+							 GPU_dynamic_uniform((float *)lamp->dynpersmat, GPU_DYNAMIC_LAMP_DYNPERSMAT, lamp->ob),
+							 GPU_uniform(&samp), GPU_uniform(&samplesize), GPU_uniform(&lamp->bias), inp, &shadowfac);
+				}
+			}
+			else {
+				GPU_link(mat, "test_shadowbuf",
+			             GPU_builtin(GPU_VIEW_POSITION),
+			             GPU_dynamic_texture(lamp->tex, GPU_DYNAMIC_SAMPLER_2DSHADOW, lamp->ob),
+			             GPU_dynamic_uniform((float *)lamp->dynpersmat, GPU_DYNAMIC_LAMP_DYNPERSMAT, lamp->ob),
+			             GPU_uniform(&lamp->bias), inp, &shadowfac);
+			}
 		}
+		GPU_link(mat, "shadows_only", inp, shadowfac, GPU_uniform(lamp->shadow_color), r_shadow);
 	}
 	else {
 		GPU_link(mat, "set_rgb_one", r_shadow);
@@ -2673,7 +2879,7 @@ GPUShaderExport *GPU_shader_export(struct Scene *scene, struct Material *ma)
 	int liblen, fraglen;
 
 	/* TODO(sergey): How to determine whether we need OSD or not here? */
-	GPUMaterial *mat = GPU_material_from_blender(scene, ma, false);
+	GPUMaterial *mat = GPU_material_from_blender(scene, ma, false, false);
 	GPUPass *pass = (mat) ? mat->pass : NULL;
 
 	if (pass && pass->fragmentcode && pass->vertexcode) {
diff --git a/source/blender/gpu/intern/gpu_shader.c b/source/blender/gpu/intern/gpu_shader.c
index 14f2764..7a47c10 100644
--- a/source/blender/gpu/intern/gpu_shader.c
+++ b/source/blender/gpu/intern/gpu_shader.c
@@ -39,12 +39,17 @@
 #include "GPU_glew.h"
 #include "GPU_shader.h"
 #include "GPU_texture.h"
+#include "gpu_codegen.h"
 
 /* TODO(sergey): Find better default values for this constants. */
 #define MAX_DEFINE_LENGTH 1024
 #define MAX_EXT_DEFINE_LENGTH 1024
 
 /* Non-generated shaders */
+extern char datatoc_gpu_shader_basic_instancing_frag_glsl[];
+extern char datatoc_gpu_shader_basic_instancing_vert_glsl[];
+extern char datatoc_gpu_shader_frame_buffer_frag_glsl[];
+extern char datatoc_gpu_shader_frame_buffer_vert_glsl[];
 extern char datatoc_gpu_shader_fire_frag_glsl[];
 extern char datatoc_gpu_shader_smoke_vert_glsl[];
 extern char datatoc_gpu_shader_smoke_frag_glsl[];
@@ -61,14 +66,20 @@ extern char datatoc_gpu_shader_fx_dof_hq_vert_glsl[];
 extern char datatoc_gpu_shader_fx_dof_hq_geo_glsl[];
 extern char datatoc_gpu_shader_fx_depth_resolve_glsl[];
 extern char datatoc_gpu_shader_fx_lib_glsl[];
+extern char datatoc_gpu_shader_lib_glsl[];
 
 static struct GPUShadersGlobal {
 	struct {
 		GPUShader *vsm_store;
+		GPUShader *vsm_store_instancing;
 		GPUShader *sep_gaussian_blur;
 		GPUShader *smoke;
 		GPUShader *smoke_fire;
 		GPUShader *smoke_coba;
+		GPUShader *instancing;
+		GPUShader *draw_frame_buffer;
+		GPUShader *stereo_stipple;
+		GPUShader *stereo_anaglyph;
 		/* cache for shader fx. Those can exist in combinations so store them here */
 		GPUShader *fx_shaders[MAX_FX_SHADERS * 2];
 	} shaders;
@@ -188,6 +199,7 @@ static void gpu_shader_standard_extensions(char defines[MAX_EXT_DEFINE_LENGTH],
 
 static void gpu_shader_standard_defines(char defines[MAX_DEFINE_LENGTH],
                                         bool use_opensubdiv,
+										bool use_instancing,
                                         bool use_new_shading)
 {
 	/* some useful defines to detect GPU type */
@@ -231,6 +243,10 @@ static void gpu_shader_standard_defines(char defines[MAX_DEFINE_LENGTH],
 	UNUSED_VARS(use_opensubdiv);
 #endif
 
+	if (use_instancing) {
+		strcat(defines, "#define USE_INSTANCING\n");
+	}
+
 	if (use_new_shading) {
 		strcat(defines, "#define USE_NEW_SHADING\n");
 	}
@@ -278,6 +294,8 @@ GPUShader *GPU_shader_create_ex(const char *vertexcode,
 	UNUSED_VARS(flags);
 	bool use_opensubdiv = false;
 #endif
+	bool use_instancing = (flags & GPU_SHADER_FLAGS_SPECIAL_INSTANCING) != 0;
+	bool resetline = (flags & GPU_SHADER_FLAGS_SPECIAL_RESET_LINE) != 0;
 	GLint status;
 	GLchar log[5000];
 	GLsizei length = 0;
@@ -311,19 +329,25 @@ GPUShader *GPU_shader_create_ex(const char *vertexcode,
 
 	gpu_shader_standard_defines(standard_defines,
 	                            use_opensubdiv,
+								use_instancing,
 	                            (flags & GPU_SHADER_FLAGS_NEW_SHADING) != 0);
 	gpu_shader_standard_extensions(standard_extensions, geocode != NULL);
 
 	if (vertexcode) {
-		const char *source[5];
+		const char *source[7];
 		/* custom limit, may be too small, beware */
 		int num_source = 0;
 
 		source[num_source++] = gpu_shader_version();
 		source[num_source++] = standard_extensions;
 		source[num_source++] = standard_defines;
+		source[num_source++] = datatoc_gpu_shader_lib_glsl;
 
 		if (defines) source[num_source++] = defines;
+		if (resetline) {
+			/* Print error message with the correct line number corresponding to the passed code */
+			source[num_source++] = "#line 0\n";
+		}
 		source[num_source++] = vertexcode;
 
 		glAttachShader(shader->program, shader->vertex);
@@ -342,12 +366,13 @@ GPUShader *GPU_shader_create_ex(const char *vertexcode,
 	}
 
 	if (fragcode) {
-		const char *source[7];
+		const char *source[9];
 		int num_source = 0;
 
 		source[num_source++] = gpu_shader_version();
 		source[num_source++] = standard_extensions;
 		source[num_source++] = standard_defines;
+		source[num_source++] = datatoc_gpu_shader_lib_glsl;
 
 #ifdef WITH_OPENSUBDIV
 		/* TODO(sergey): Move to fragment shader source code generation. */
@@ -363,6 +388,10 @@ GPUShader *GPU_shader_create_ex(const char *vertexcode,
 
 		if (defines) source[num_source++] = defines;
 		if (libcode) source[num_source++] = libcode;
+		if (resetline) {
+			/* Print error message with the correct line number corresponding to the passed code */
+			source[num_source++] = "#line 0\n";
+		}
 		source[num_source++] = fragcode;
 
 		glAttachShader(shader->program, shader->fragment);
@@ -381,14 +410,19 @@ GPUShader *GPU_shader_create_ex(const char *vertexcode,
 	}
 
 	if (geocode) {
-		const char *source[6];
+		const char *source[8];
 		int num_source = 0;
 
 		source[num_source++] = gpu_shader_version();
 		source[num_source++] = standard_extensions;
 		source[num_source++] = standard_defines;
+		source[num_source++] = datatoc_gpu_shader_lib_glsl;
 
 		if (defines) source[num_source++] = defines;
+		if (resetline) {
+			/* Print error message with the correct line number corresponding to the passed code */
+			source[num_source++] = "#line 0\n";
+		}
 		source[num_source++] = geocode;
 
 		glAttachShader(shader->program, shader->geometry);
@@ -451,6 +485,23 @@ GPUShader *GPU_shader_create_ex(const char *vertexcode,
 	return shader;
 }
 
+char *GPU_shader_validate(GPUShader *shader)
+{
+	int stat = 0;
+	glValidateProgram(shader->program);
+	glGetObjectParameterivARB(shader->program, GL_OBJECT_VALIDATE_STATUS_ARB, (GLint *)&stat);
+
+	if (stat > 0) {
+		int charlen = 0;
+		char *log = (char *)MEM_mallocN(stat, "GPU_shader_validate");
+
+		glGetInfoLogARB(shader->program, stat, (GLsizei *)&charlen, log);
+
+		return log;
+	}
+	return NULL;
+}
+
 void GPU_shader_bind(GPUShader *shader)
 {
 	GPU_ASSERT_NO_GL_ERRORS("Pre Shader Bind");
@@ -465,6 +516,11 @@ void GPU_shader_unbind(void)
 	GPU_ASSERT_NO_GL_ERRORS("Post Shader Unbind");
 }
 
+int GPU_shader_program(GPUShader *shader)
+{
+	return shader->program;
+}
+
 void GPU_shader_free(GPUShader *shader)
 {
 	if (shader->vertex)
@@ -537,6 +593,14 @@ void GPU_shader_uniform_int(GPUShader *UNUSED(shader), int location, int value)
 	GPU_CHECK_ERRORS_AROUND(glUniform1i(location, value));
 }
 
+void GPU_shader_uniform_float(GPUShader *UNUSED(shader), int location, float value)
+{
+	if (location == -1)
+		return;
+
+	GPU_CHECK_ERRORS_AROUND(glUniform1f(location, value));
+}
+
 void GPU_shader_geometry_stage_primitive_io(GPUShader *shader, int input, int output, int number)
 {
 	if (GPU_geometry_shader_support_via_extension()) {
@@ -590,6 +654,63 @@ int GPU_shader_get_attribute(GPUShader *shader, const char *name)
 	return index;
 }
 
+void GPU_shader_bind_attribute(GPUShader *shader, int location, const char *name)
+{
+	GPU_CHECK_ERRORS_AROUND(glBindAttribLocation(shader->program, location, name));
+}
+
+// Used only for VSM shader with geometry instancing support.
+void GPU_shader_bind_instancing_attrib(GPUShader *shader, void *matrixoffset, void *positionoffset, unsigned int stride)
+{
+	int posloc = GPU_shader_get_attribute(shader, GPU_builtin_name(GPU_INSTANCING_POSITION_ATTRIB));
+	int matloc = GPU_shader_get_attribute(shader, GPU_builtin_name(GPU_INSTANCING_MATRIX_ATTRIB));
+
+	// Matrix
+	if (matloc != -1) {
+		glEnableVertexAttribArrayARB(matloc);
+		glEnableVertexAttribArrayARB(matloc + 1);
+		glEnableVertexAttribArrayARB(matloc + 2);
+
+		glVertexAttribPointerARB(matloc, 3, GL_FLOAT, GL_FALSE, stride, matrixoffset);
+		glVertexAttribPointerARB(matloc + 1, 3, GL_FLOAT, GL_FALSE, stride, ((char *)matrixoffset) + 3 * sizeof(float));
+		glVertexAttribPointerARB(matloc + 2, 3, GL_FLOAT, GL_FALSE, stride, ((char *)matrixoffset) + 6 * sizeof(float));
+
+		glVertexAttribDivisorARB(matloc, 1);
+		glVertexAttribDivisorARB(matloc + 1, 1);
+		glVertexAttribDivisorARB(matloc + 2, 1);
+	}
+
+	// Position
+	if (posloc != -1) {
+		glEnableVertexAttribArrayARB(posloc);
+		glVertexAttribPointerARB(posloc, 3, GL_FLOAT, GL_FALSE, stride, positionoffset);
+		glVertexAttribDivisorARB(posloc, 1);
+	}
+}
+
+void GPU_shader_unbind_instancing_attrib(GPUShader *shader)
+{
+	int posloc = GPU_shader_get_attribute(shader, GPU_builtin_name(GPU_INSTANCING_POSITION_ATTRIB));
+	int matloc = GPU_shader_get_attribute(shader, GPU_builtin_name(GPU_INSTANCING_MATRIX_ATTRIB));
+
+	// Matrix
+	if (matloc != -1) {
+		glDisableVertexAttribArrayARB(matloc);
+		glDisableVertexAttribArrayARB(matloc + 1);
+		glDisableVertexAttribArrayARB(matloc + 2);
+
+		glVertexAttribDivisorARB(matloc, 0);
+		glVertexAttribDivisorARB(matloc + 1, 0);
+		glVertexAttribDivisorARB(matloc + 2, 0);
+	}
+
+	// Position
+	if (posloc != -1) {
+		glDisableVertexAttribArrayARB(posloc);
+		glVertexAttribDivisorARB(posloc, 0);
+	}
+}
+
 GPUShader *GPU_shader_get_builtin_shader(GPUBuiltinShader shader)
 {
 	GPUShader *retval = NULL;
@@ -602,6 +723,13 @@ GPUShader *GPU_shader_get_builtin_shader(GPUBuiltinShader shader)
 				        NULL, NULL, NULL, 0, 0, 0);
 			retval = GG.shaders.vsm_store;
 			break;
+		case GPU_SHADER_VSM_STORE_INSTANCING:
+			if (!GG.shaders.vsm_store_instancing)
+				GG.shaders.vsm_store_instancing = GPU_shader_create(
+					datatoc_gpu_shader_vsm_store_vert_glsl, datatoc_gpu_shader_vsm_store_frag_glsl,
+					NULL, NULL, "#define USE_INSTANCING;\n", 0, 0, 0);
+			retval = GG.shaders.vsm_store_instancing;
+			break;
 		case GPU_SHADER_SEP_GAUSSIAN_BLUR:
 			if (!GG.shaders.sep_gaussian_blur)
 				GG.shaders.sep_gaussian_blur = GPU_shader_create(
@@ -631,6 +759,34 @@ GPUShader *GPU_shader_get_builtin_shader(GPUBuiltinShader shader)
 				        NULL, NULL, "#define USE_COBA;\n", 0, 0, 0);
 			retval = GG.shaders.smoke_coba;
 			break;
+		case GPU_SHADER_INSTANCING:
+			if (!GG.shaders.instancing)
+				GG.shaders.instancing = GPU_shader_create(
+					datatoc_gpu_shader_basic_instancing_vert_glsl, datatoc_gpu_shader_basic_instancing_frag_glsl,
+					NULL, NULL, NULL, 0, 0, 0);
+			retval = GG.shaders.instancing;
+			break;
+		case GPU_SHADER_DRAW_FRAME_BUFFER:
+			if (!GG.shaders.draw_frame_buffer)
+				GG.shaders.draw_frame_buffer = GPU_shader_create(
+					datatoc_gpu_shader_frame_buffer_vert_glsl, datatoc_gpu_shader_frame_buffer_frag_glsl,
+					NULL, NULL, NULL, 0, 0, 0);
+			retval = GG.shaders.draw_frame_buffer;
+			break;
+		case GPU_SHADER_STEREO_STIPPLE:
+			if (!GG.shaders.stereo_stipple)
+				GG.shaders.stereo_stipple = GPU_shader_create(
+					datatoc_gpu_shader_frame_buffer_vert_glsl, datatoc_gpu_shader_frame_buffer_frag_glsl,
+					NULL, NULL, "#define STIPPLE;\n", 0, 0, 0);
+			retval = GG.shaders.stereo_stipple;
+			break;
+		case GPU_SHADER_STEREO_ANAGLYPH:
+			if (!GG.shaders.stereo_anaglyph)
+				GG.shaders.stereo_anaglyph = GPU_shader_create(
+					datatoc_gpu_shader_frame_buffer_vert_glsl, datatoc_gpu_shader_frame_buffer_frag_glsl,
+					NULL, NULL, "#define ANAGLYPH;\n", 0, 0, 0);
+			retval = GG.shaders.stereo_anaglyph;
+			break;
 	}
 
 	if (retval == NULL)
@@ -747,6 +903,26 @@ void GPU_shader_free_builtin_shaders(void)
 		GG.shaders.smoke_coba = NULL;
 	}
 
+	if (GG.shaders.instancing) {
+		GPU_shader_free(GG.shaders.instancing);
+		GG.shaders.instancing = NULL;
+	}
+
+	if (GG.shaders.draw_frame_buffer) {
+		GPU_shader_free(GG.shaders.draw_frame_buffer);
+		GG.shaders.draw_frame_buffer = NULL;
+	}
+
+	if (GG.shaders.stereo_stipple) {
+		GPU_shader_free(GG.shaders.stereo_stipple);
+		GG.shaders.stereo_stipple = NULL;
+	}
+
+	if (GG.shaders.stereo_anaglyph) {
+		GPU_shader_free(GG.shaders.stereo_anaglyph);
+		GG.shaders.stereo_anaglyph = NULL;
+	}
+
 	for (i = 0; i < 2 * MAX_FX_SHADERS; ++i) {
 		if (GG.shaders.fx_shaders[i]) {
 			GPU_shader_free(GG.shaders.fx_shaders[i]);
diff --git a/source/blender/gpu/intern/gpu_texture.c b/source/blender/gpu/intern/gpu_texture.c
index 54f0003..8d69d2a 100644
--- a/source/blender/gpu/intern/gpu_texture.c
+++ b/source/blender/gpu/intern/gpu_texture.c
@@ -46,7 +46,8 @@ static struct GPUTextureGlobal {
 	GPUTexture *invalid_tex_1D; /* texture used in place of invalid textures (not loaded correctly, missing) */
 	GPUTexture *invalid_tex_2D;
 	GPUTexture *invalid_tex_3D;
-} GG = {NULL, NULL, NULL};
+	GPUTexture *depth_tex;
+} GG = {NULL, NULL, NULL, NULL};
 
 /* GPUTexture */
 
@@ -92,7 +93,7 @@ static void GPU_glTexSubImageEmpty(GLenum target, GLenum format, int x, int y, i
 }
 
 static GPUTexture *GPU_texture_create_nD(
-        int w, int h, int n, const float *fpixels, int depth,
+        int w, int h, int n, const float *fpixels, int mode,
         GPUHDRType hdr_type, int components, int samples,
         char err_out[256])
 {
@@ -110,7 +111,7 @@ static GPUTexture *GPU_texture_create_nD(
 	tex->refcount = 1;
 	tex->target = (n == 1) ? GL_TEXTURE_1D : (samples ? GL_TEXTURE_2D_MULTISAMPLE : GL_TEXTURE_2D);
 	tex->target_base = (n == 1) ? GL_TEXTURE_1D : GL_TEXTURE_2D;
-	tex->depth = depth;
+	tex->depth = (mode & GPU_TEXTURE_DEPTH);
 	tex->fb_attachment = -1;
 
 	glGenTextures(1, &tex->bindcode);
@@ -136,7 +137,7 @@ static GPUTexture *GPU_texture_create_nD(
 	tex->number = 0;
 	glBindTexture(tex->target, tex->bindcode);
 
-	if (depth) {
+	if (tex->depth) {
 		type = GL_UNSIGNED_BYTE;
 		format = GL_DEPTH_COMPONENT;
 		internalformat = GL_DEPTH_COMPONENT;
@@ -220,11 +221,13 @@ static GPUTexture *GPU_texture_create_nD(
 	if (pixels)
 		MEM_freeN(pixels);
 
-	if (depth) {
+	if (tex->depth) {
 		glTexParameteri(tex->target_base, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
 		glTexParameteri(tex->target_base, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-		glTexParameteri(tex->target_base, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_R_TO_TEXTURE);
-		glTexParameteri(tex->target_base, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL);
+		if (mode & GPU_TEXTURE_DEPTH_COMPARE) {
+			glTexParameteri(tex->target_base, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_R_TO_TEXTURE);
+			glTexParameteri(tex->target_base, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL);
+		}
 		glTexParameteri(tex->target_base, GL_DEPTH_TEXTURE_MODE, GL_INTENSITY);
 	}
 	else {
@@ -242,7 +245,6 @@ static GPUTexture *GPU_texture_create_nD(
 	return tex;
 }
 
-
 GPUTexture *GPU_texture_create_3D(int w, int h, int depth, int channels, const float *fpixels)
 {
 	GLenum type, format, internalformat;
@@ -475,7 +477,7 @@ GPUTexture *GPU_texture_from_preview(PreviewImage *prv, int mipmap)
 
 GPUTexture *GPU_texture_create_1D(int w, const float *fpixels, char err_out[256])
 {
-	GPUTexture *tex = GPU_texture_create_nD(w, 1, 1, fpixels, 0, GPU_HDR_NONE, 4, 0, err_out);
+	GPUTexture *tex = GPU_texture_create_nD(w, 1, 1, fpixels, GPU_TEXTURE_MODE_NONE, GPU_HDR_NONE, 4, 0, err_out);
 
 	if (tex)
 		GPU_texture_unbind(tex);
@@ -485,7 +487,7 @@ GPUTexture *GPU_texture_create_1D(int w, const float *fpixels, char err_out[256]
 
 GPUTexture *GPU_texture_create_2D(int w, int h, const float *fpixels, GPUHDRType hdr, char err_out[256])
 {
-	GPUTexture *tex = GPU_texture_create_nD(w, h, 2, fpixels, 0, hdr, 4, 0, err_out);
+	GPUTexture *tex = GPU_texture_create_nD(w, h, 2, fpixels, GPU_TEXTURE_MODE_NONE, hdr, 4, 0, err_out);
 
 	if (tex)
 		GPU_texture_unbind(tex);
@@ -495,7 +497,7 @@ GPUTexture *GPU_texture_create_2D(int w, int h, const float *fpixels, GPUHDRType
 GPUTexture *GPU_texture_create_2D_multisample(
         int w, int h, const float *fpixels, GPUHDRType hdr, int samples, char err_out[256])
 {
-	GPUTexture *tex = GPU_texture_create_nD(w, h, 2, fpixels, 0, hdr, 4, samples, err_out);
+	GPUTexture *tex = GPU_texture_create_nD(w, h, 2, fpixels, GPU_TEXTURE_MODE_NONE, hdr, 4, samples, err_out);
 
 	if (tex)
 		GPU_texture_unbind(tex);
@@ -503,18 +505,20 @@ GPUTexture *GPU_texture_create_2D_multisample(
 	return tex;
 }
 
-GPUTexture *GPU_texture_create_depth(int w, int h, char err_out[256])
+GPUTexture *GPU_texture_create_depth(int w, int h, bool compare, char err_out[256])
 {
-	GPUTexture *tex = GPU_texture_create_nD(w, h, 2, NULL, 1, GPU_HDR_NONE, 1, 0, err_out);
+	const int mode = GPU_TEXTURE_DEPTH | (compare ? GPU_TEXTURE_DEPTH_COMPARE : 0);
+	GPUTexture *tex = GPU_texture_create_nD(w, h, 2, NULL, mode, GPU_HDR_NONE, 1, 0, err_out);
 
 	if (tex)
 		GPU_texture_unbind(tex);
 	
 	return tex;
 }
-GPUTexture *GPU_texture_create_depth_multisample(int w, int h, int samples, char err_out[256])
+GPUTexture *GPU_texture_create_depth_multisample(int w, int h, int samples, bool compare, char err_out[256])
 {
-	GPUTexture *tex = GPU_texture_create_nD(w, h, 2, NULL, 1, GPU_HDR_NONE, 1, samples, err_out);
+	const int mode = GPU_TEXTURE_DEPTH | (compare ? GPU_TEXTURE_DEPTH_COMPARE : 0);
+	GPUTexture *tex = GPU_texture_create_nD(w, h, 2, NULL, mode, GPU_HDR_NONE, 1, samples, err_out);
 
 	if (tex)
 		GPU_texture_unbind(tex);
@@ -527,7 +531,7 @@ GPUTexture *GPU_texture_create_depth_multisample(int w, int h, int samples, char
  */
 GPUTexture *GPU_texture_create_vsm_shadow_map(int size, char err_out[256])
 {
-	GPUTexture *tex = GPU_texture_create_nD(size, size, 2, NULL, 0, GPU_HDR_FULL_FLOAT, 2, 0, err_out);
+	GPUTexture *tex = GPU_texture_create_nD(size, size, 2, NULL, GPU_TEXTURE_MODE_NONE, GPU_HDR_FULL_FLOAT, 2, 0, err_out);
 
 	if (tex) {
 		/* Now we tweak some of the settings */
@@ -542,7 +546,7 @@ GPUTexture *GPU_texture_create_vsm_shadow_map(int size, char err_out[256])
 
 GPUTexture *GPU_texture_create_2D_procedural(int w, int h, const float *pixels, bool repeat, char err_out[256])
 {
-	GPUTexture *tex = GPU_texture_create_nD(w, h, 2, pixels, 0, GPU_HDR_HALF_FLOAT, 2, 0, err_out);
+	GPUTexture *tex = GPU_texture_create_nD(w, h, 2, pixels, GPU_TEXTURE_MODE_NONE, GPU_HDR_HALF_FLOAT, 2, 0, err_out);
 
 	if (tex) {
 		/* Now we tweak some of the settings */
@@ -561,7 +565,7 @@ GPUTexture *GPU_texture_create_2D_procedural(int w, int h, const float *pixels,
 
 GPUTexture *GPU_texture_create_1D_procedural(int w, const float *pixels, char err_out[256])
 {
-	GPUTexture *tex = GPU_texture_create_nD(w, 0, 1, pixels, 0, GPU_HDR_HALF_FLOAT, 2, 0, err_out);
+	GPUTexture *tex = GPU_texture_create_nD(w, 0, 1, pixels, GPU_TEXTURE_MODE_NONE, GPU_HDR_HALF_FLOAT, 2, 0, err_out);
 
 	if (tex) {
 		/* Now we tweak some of the settings */
@@ -575,12 +579,28 @@ GPUTexture *GPU_texture_create_1D_procedural(int w, const float *pixels, char er
 	return tex;
 }
 
+GPUTexture **GPU_texture_global_depth_ptr(void)
+{
+	return &GG.depth_tex;
+}
+
+void GPU_texture_set_global_depth(GPUTexture *depthtex)
+{
+	if (depthtex) {
+		GG.depth_tex = depthtex;
+	}
+	else {
+		GG.depth_tex = GG.invalid_tex_2D;
+	}
+}
+
 void GPU_invalid_tex_init(void)
 {
 	const float color[4] = {1.0f, 0.0f, 1.0f, 1.0f};
 	GG.invalid_tex_1D = GPU_texture_create_1D(1, color, NULL);
 	GG.invalid_tex_2D = GPU_texture_create_2D(1, 1, color, GPU_HDR_NONE, NULL);
 	GG.invalid_tex_3D = GPU_texture_create_3D(1, 1, 1, 4, color);
+	GG.depth_tex = GG.invalid_tex_2D;
 }
 
 void GPU_invalid_tex_bind(int mode)
@@ -670,7 +690,7 @@ int GPU_texture_bound_number(GPUTexture *tex)
 	return tex->number;
 }
 
-void GPU_texture_filter_mode(GPUTexture *tex, bool compare, bool use_filter)
+void GPU_texture_filter_mode(GPUTexture *tex, bool compare, bool use_filter, bool mipmap)
 {
 	if (tex->number >= GPU_max_textures()) {
 		fprintf(stderr, "Not enough texture slots.\n");
@@ -685,26 +705,59 @@ void GPU_texture_filter_mode(GPUTexture *tex, bool compare, bool use_filter)
 	GLenum arbnumber = (GLenum)((GLuint)GL_TEXTURE0 + tex->number);
 	if (tex->number != 0) glActiveTexture(arbnumber);
 
+	int target = tex->target;
 	if (tex->depth) {
 		if (compare)
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_R_TO_TEXTURE);
+			glTexParameteri(target, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_R_TO_TEXTURE);
 		else
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE, GL_NONE);
+			glTexParameteri(target, GL_TEXTURE_COMPARE_MODE, GL_NONE);
 	}
 
 	if (use_filter) {
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+		glTexParameteri(target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+		if (mipmap) {
+			glTexParameteri(target, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+		}
+		else {
+			glTexParameteri(target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+		}
 	}
 	else {
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+		glTexParameteri(target, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		glTexParameteri(target, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
 	}
 	if (tex->number != 0) glActiveTexture(GL_TEXTURE0);
 
 	GPU_ASSERT_NO_GL_ERRORS("Post Texture Unbind");
 }
 
+void GPU_texture_generate_mipmap(GPUTexture *tex)
+{
+	if (tex->number >= GPU_max_textures()) {
+		fprintf(stderr, "Not enough texture slots.\n");
+		return;
+	}
+
+	if (tex->number == -1) {
+		return;
+	}
+
+	GPU_ASSERT_NO_GL_ERRORS("Pre Texture Unbind");
+
+	GLenum arbnumber = (GLenum)((GLuint)GL_TEXTURE0 + tex->number);
+	if (tex->number != 0) {
+		glActiveTexture(arbnumber);
+	}
+
+	glGenerateMipmap(tex->target);
+
+	if (tex->number != 0) {
+		glActiveTexture(GL_TEXTURE0);
+	}
+
+	GPU_ASSERT_NO_GL_ERRORS("Post Texture Unbind");
+}
+
 void GPU_texture_free(GPUTexture *tex)
 {
 	tex->refcount--;
@@ -727,6 +780,11 @@ void GPU_texture_ref(GPUTexture *tex)
 	tex->refcount++;
 }
 
+int GPU_texture_ref_count(GPUTexture *tex)
+{
+	return tex->refcount;
+}
+
 int GPU_texture_target(const GPUTexture *tex)
 {
 	return tex->target;
@@ -752,6 +810,11 @@ int GPU_texture_opengl_bindcode(const GPUTexture *tex)
 	return tex->bindcode;
 }
 
+void GPU_texture_set_opengl_bindcode(GPUTexture *tex, int bindcode)
+{
+	tex->bindcode = bindcode;
+}
+
 GPUFrameBuffer *GPU_texture_framebuffer(GPUTexture *tex)
 {
 	return tex->fb;
diff --git a/source/blender/gpu/shaders/gpu_shader_basic_instancing_frag.glsl b/source/blender/gpu/shaders/gpu_shader_basic_instancing_frag.glsl
new file mode 100644
index 0000000..da5c89f
--- /dev/null
+++ b/source/blender/gpu/shaders/gpu_shader_basic_instancing_frag.glsl
@@ -0,0 +1,4 @@
+void main()
+{
+	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
+}
diff --git a/source/blender/gpu/shaders/gpu_shader_basic_instancing_vert.glsl b/source/blender/gpu/shaders/gpu_shader_basic_instancing_vert.glsl
new file mode 100644
index 0000000..e16ae42
--- /dev/null
+++ b/source/blender/gpu/shaders/gpu_shader_basic_instancing_vert.glsl
@@ -0,0 +1,12 @@
+in mat3 ininstmatrix;
+in vec3 ininstposition;
+
+void main()
+{
+	mat4 instmat = mat4(vec4(ininstmatrix[0], ininstposition.x),
+						vec4(ininstmatrix[1], ininstposition.y),
+						vec4(ininstmatrix[2], ininstposition.z),
+						vec4(0.0, 0.0, 0.0, 1.0));
+
+	gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * (gl_Vertex * instmat);
+}
diff --git a/source/blender/gpu/shaders/gpu_shader_frame_buffer_frag.glsl b/source/blender/gpu/shaders/gpu_shader_frame_buffer_frag.glsl
new file mode 100644
index 0000000..470dec7
--- /dev/null
+++ b/source/blender/gpu/shaders/gpu_shader_frame_buffer_frag.glsl
@@ -0,0 +1,48 @@
+#if defined(ANAGLYPH) || defined(STIPPLE)
+uniform sampler2D lefteyetex;
+uniform sampler2D righteyetex;
+#else
+uniform sampler2D colortex;
+#  ifdef DEPTH
+uniform sampler2D depthtex;
+#  endif
+#endif
+
+#ifdef STIPPLE
+#define STIPPLE_COLUMN 0
+#define STIPPLE_ROW 1
+
+uniform int stippleid;
+#endif
+
+void main()
+{
+	vec2 co = gl_TexCoord[0].xy;
+#ifdef STIPPLE
+	if (stippleid == STIPPLE_ROW) {
+		int result = int(mod(gl_FragCoord.y, 2));
+		if (result != 0) {
+			gl_FragColor = texture2D(lefteyetex, co);
+		}
+		else {
+			gl_FragColor = texture2D(righteyetex, co);
+		}
+	}
+	else if (stippleid == STIPPLE_COLUMN) {
+		int result = int(mod(gl_FragCoord.x, 2));
+		if (result == 0) {
+			gl_FragColor = texture2D(lefteyetex, co);
+		}
+		else {
+			gl_FragColor = texture2D(righteyetex, co);
+		}
+	}
+#elif defined(ANAGLYPH)
+	gl_FragColor = vec4(texture2D(lefteyetex, co).r, texture2D(righteyetex, co).gb, 1.0);
+#else
+	gl_FragColor = texture2D(colortex, co);
+#  ifdef DEPTH
+	gl_FragDepth = texture2D(depthtex, co).x;
+#  endif
+#endif
+}
diff --git a/source/blender/gpu/shaders/gpu_shader_frame_buffer_vert.glsl b/source/blender/gpu/shaders/gpu_shader_frame_buffer_vert.glsl
new file mode 100644
index 0000000..a8fb0cf
--- /dev/null
+++ b/source/blender/gpu/shaders/gpu_shader_frame_buffer_vert.glsl
@@ -0,0 +1,5 @@
+void main()
+{
+	gl_Position = gl_Vertex;
+	gl_TexCoord[0] = gl_MultiTexCoord0;
+}
diff --git a/source/blender/gpu/shaders/gpu_shader_lib.glsl b/source/blender/gpu/shaders/gpu_shader_lib.glsl
new file mode 100644
index 0000000..5832d6b
--- /dev/null
+++ b/source/blender/gpu/shaders/gpu_shader_lib.glsl
@@ -0,0 +1,70 @@
+#if __VERSION__ < 140
+/* Manual implementation of inverse(mat4) for GLSL version before 1.40, 
+ * copied from https://github.com/stackgl/glsl-inverse/blob/master/index.glsl
+ */
+
+float inverse(float m) {
+  return 1.0 / m;
+}
+
+mat2 inverse(mat2 m) {
+  return mat2(m[1][1],-m[0][1],
+             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);
+}
+
+mat3 inverse(mat3 m) {
+  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];
+  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];
+  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];
+
+  float b01 = a22 * a11 - a12 * a21;
+  float b11 = -a22 * a10 + a12 * a20;
+  float b21 = a21 * a10 - a11 * a20;
+
+  float det = a00 * b01 + a01 * b11 + a02 * b21;
+
+  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),
+              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),
+              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;
+}
+
+mat4 inverse(mat4 m) {
+	float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
+	a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
+	a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
+	a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],
+
+	b00 = a00 * a11 - a01 * a10,
+	b01 = a00 * a12 - a02 * a10,
+	b02 = a00 * a13 - a03 * a10,
+	b03 = a01 * a12 - a02 * a11,
+	b04 = a01 * a13 - a03 * a11,
+	b05 = a02 * a13 - a03 * a12,
+	b06 = a20 * a31 - a21 * a30,
+	b07 = a20 * a32 - a22 * a30,
+	b08 = a20 * a33 - a23 * a30,
+	b09 = a21 * a32 - a22 * a31,
+	b10 = a21 * a33 - a23 * a31,
+	b11 = a22 * a33 - a23 * a32,
+
+	det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
+
+	return mat4(
+		a11 * b11 - a12 * b10 + a13 * b09,
+		a02 * b10 - a01 * b11 - a03 * b09,
+		a31 * b05 - a32 * b04 + a33 * b03,
+		a22 * b04 - a21 * b05 - a23 * b03,
+		a12 * b08 - a10 * b11 - a13 * b07,
+		a00 * b11 - a02 * b08 + a03 * b07,
+		a32 * b02 - a30 * b05 - a33 * b01,
+		a20 * b05 - a22 * b02 + a23 * b01,
+		a10 * b10 - a11 * b08 + a13 * b06,
+		a01 * b08 - a00 * b10 - a03 * b06,
+		a30 * b04 - a31 * b02 + a33 * b00,
+		a21 * b02 - a20 * b04 - a23 * b00,
+		a11 * b07 - a10 * b09 - a12 * b06,
+		a00 * b09 - a01 * b07 + a02 * b06,
+		a31 * b01 - a30 * b03 - a32 * b00,
+		a20 * b03 - a21 * b01 + a22 * b00) / det;
+}
+#endif
diff --git a/source/blender/gpu/shaders/gpu_shader_material.glsl b/source/blender/gpu/shaders/gpu_shader_material.glsl
index 4416b64..37dd44e 100644
--- a/source/blender/gpu/shaders/gpu_shader_material.glsl
+++ b/source/blender/gpu/shaders/gpu_shader_material.glsl
@@ -481,6 +481,13 @@ void normal_new_shading(vec3 dir, vec3 nor, out vec3 outnor, out float outdot)
 	outdot = dot(normalize(dir), nor);
 }
 
+void mat_math_rot(float rot, out mat3 mat)
+{
+	mat = mat3(cos(rot), -sin(rot), 0.0,
+			   sin(rot), cos(rot), 0.0,
+			   0.0, 0.0, 1.0);
+}
+
 void curves_vec(float fac, vec3 vec, sampler2D curvemap, out vec3 outvec)
 {
 	outvec.x = texture2D(curvemap, vec2((vec.x + 1.0) * 0.5, 0.0)).x;
@@ -509,6 +516,37 @@ void set_value(float val, out float outval)
 	outval = val;
 }
 
+float half_lambert(in vec3 vect1, in vec3 vect2)
+{
+	float product = dot(vect1, vect2);
+	return product * 0.5 + 0.5;
+}
+
+vec3 sub_scatter_fs(float brightness, float visifac, vec3 lightcol, float scale, vec3 radius, vec3 col, float i, vec3 view, vec3 lv, vec3 normal)
+{
+	vec3 extinctioncoefficient = radius * 0.1;
+	float attenuation = visifac * brightness;
+	vec3 evec = normalize(-view);
+
+	vec3 dotLN = vec3(half_lambert(lv, -normal) * attenuation);
+	dotLN *= col;
+
+	vec3 indirectlightcomponent = vec3(scale * max(0.0, dot(-normal, lv)));
+	indirectlightcomponent += scale * vec3(half_lambert(-evec, lv));
+	indirectlightcomponent *= attenuation;
+	indirectlightcomponent *= extinctioncoefficient;
+
+	vec3 finalcol = dotLN + vec3(indirectlightcomponent);
+
+	finalcol.rgb *= lightcol.rgb;
+	return finalcol;
+}
+
+void set_sss(float brightness, float visifac, vec3 lightcol, float scale, vec3 radius, vec3 col, float i, vec3 view, vec3 lv, vec3 normal, out vec4 outcol)
+{
+	outcol = vec4(sub_scatter_fs(brightness, visifac, lightcol, scale, radius, col, i, view, lv, normal), 1.0);
+}
+
 void set_rgb(vec3 col, out vec3 outcol)
 {
 	outcol = col;
@@ -1338,6 +1376,11 @@ void mtex_mapping_size(vec3 texco, vec3 size, out vec3 outtexco)
 	outtexco = size * texco;
 }
 
+void mtex_mapping_transform(vec3 texco, mat3 mat, vec3 ofs, vec3 size, out vec3 outtexco)
+{
+	outtexco = (texco - vec3(0.5)) * mat * size + vec3(0.5) + ofs;
+}
+
 void mtex_2d_mapping(vec3 vec, out vec3 outvec)
 {
 	outvec = vec3(vec.xy * 0.5 + vec2(0.5), vec.z);
@@ -1348,9 +1391,9 @@ vec3 mtex_2d_mapping(vec3 vec)
 	return vec3(vec.xy * 0.5 + vec2(0.5), vec.z);
 }
 
-void mtex_cube_map(vec3 co, samplerCube ima, out float value, out vec4 color)
+void mtex_cube_map(vec3 co, samplerCube ima, float lodbias, out float value, out vec4 color)
 {
-	color = textureCube(ima, co);
+	color = textureCube(ima, co, lodbias);
 	value = 1.0;
 }
 
@@ -1361,31 +1404,65 @@ void mtex_cube_map_refl_from_refldir(
         value = 1.0;
 }
 
+vec4 mtex_cube_map_refl_color(samplerCube ima, mat4 viewmatrixinverse, float lodbias, vec3 vn, vec3 viewdirection)
+{
+	vec3 normaldirection = normalize(viewmatrixinverse * vec4(vn, 0.0)).xyz;
+	vec3 reflecteddirection = reflect(viewdirection, normaldirection);
+	vec4 col = textureCube(ima, reflecteddirection, lodbias);
+	return col;
+}
+
+vec4 mtex_cube_map_refr_color(samplerCube ima, mat4 viewmatrixinverse, float ior, float lodbias, vec3 vn, vec3 viewdirection)
+{
+	vec3 normaldirection = normalize(viewmatrixinverse * vec4(vec3(vn.x, vn.y, -vn.z), 0.0)).xyz;
+	vec3 refracteddirection = refract(viewdirection, normaldirection, 1.0 / ior);
+	vec4 col = textureCube(ima, refracteddirection, lodbias);
+	return col;
+}
+
 void mtex_cube_map_refl(
-        samplerCube ima, vec3 vp, vec3 vn, mat4 viewmatrixinverse, mat4 viewmatrix,
+        samplerCube ima, vec3 vp, vec3 vn, float lodbias, mat4 viewmatrixinverse,
         out float value, out vec4 color)
 {
 	vec3 viewdirection = vec3(viewmatrixinverse * vec4(vp, 0.0));
-	vec3 normaldirection = normalize(vec3(vec4(vn, 0.0) * viewmatrix));
-	vec3 reflecteddirection = reflect(viewdirection, normaldirection);
-	color = textureCube(ima, reflecteddirection);
+	color = mtex_cube_map_refl_color(ima, viewmatrixinverse, lodbias, vn, viewdirection);
+	value = 1.0;
+}
+
+void mtex_cube_map_refl_refr(
+        samplerCube ima, vec3 vp, vec3 vn, float lodbias, mat4 viewmatrixinverse,
+        float ior, float ratio, out float value, out vec4 color)
+{
+	vec3 viewdirection = vec3(viewmatrixinverse * vec4(vp, 0.0));
+
+	if (ratio <= 0.0) {
+		color = mtex_cube_map_refl_color(ima, viewmatrixinverse, lodbias, vn, viewdirection);
+	}
+	else if (ratio >= 1.0) {
+		color = mtex_cube_map_refr_color(ima, viewmatrixinverse, ior, lodbias, vn, viewdirection);
+	}
+	else {
+		vec4 refl = mtex_cube_map_refl_color(ima, viewmatrixinverse, lodbias, vn, viewdirection);
+		vec4 refr = mtex_cube_map_refr_color(ima, viewmatrixinverse, ior, lodbias, vn, viewdirection);
+		color = mix(refl, refr, ratio);
+	}
 	value = 1.0;
 }
 
-void mtex_image(vec3 texco, sampler2D ima, out float value, out vec4 color)
+void mtex_image(vec3 texco, sampler2D ima, float lodbias, out float value, out vec4 color)
 {
-	color = texture2D(ima, texco.xy);
+	color = texture2D(ima, texco.xy, lodbias);
 	value = 1.0;
 }
 
-void mtex_normal(vec3 texco, sampler2D ima, out vec3 normal)
+void mtex_normal(vec3 texco, sampler2D ima, float lodbias, out vec3 normal)
 {
 	// The invert of the red channel is to make
 	// the normal map compliant with the outside world.
 	// It needs to be done because in Blender
 	// the normal used points inward.
 	// Should this ever change this negate must be removed.
-	vec4 color = texture2D(ima, texco.xy);
+	vec4 color = texture2D(ima, texco.xy, lodbias);
 	normal = 2.0 * (vec3(-color.r, color.g, color.b) - vec3(-0.5, 0.5, 0.5));
 }
 
@@ -1474,16 +1551,16 @@ void mtex_bump_init_viewspace(
 
 void mtex_bump_tap3(
         vec3 texco, sampler2D ima, float hScale,
-        out float dBs, out float dBt)
+        float lodbias, out float dBs, out float dBt)
 {
 	vec2 STll = texco.xy;
 	vec2 STlr = texco.xy + dFdx(texco.xy);
 	vec2 STul = texco.xy + dFdy(texco.xy);
 
 	float Hll, Hlr, Hul;
-	rgbtobw(texture2D(ima, STll), Hll);
-	rgbtobw(texture2D(ima, STlr), Hlr);
-	rgbtobw(texture2D(ima, STul), Hul);
+	rgbtobw(texture2D(ima, STll, lodbias), Hll);
+	rgbtobw(texture2D(ima, STlr, lodbias), Hlr);
+	rgbtobw(texture2D(ima, STul, lodbias), Hul);
 
 	dBs = hScale * (Hlr - Hll);
 	dBt = hScale * (Hul - Hll);
@@ -1493,7 +1570,7 @@ void mtex_bump_tap3(
 
 void mtex_bump_bicubic(
         vec3 texco, sampler2D ima, float hScale,
-        out float dBs, out float dBt )
+        float lodbias, out float dBs, out float dBt )
 {
 	float Hl;
 	float Hr;
@@ -1508,10 +1585,10 @@ void mtex_bump_bicubic(
 	vec2 STd = texco.xy - 0.5 * TexDy;
 	vec2 STu = texco.xy + 0.5 * TexDy;
 
-	rgbtobw(texture2D(ima, STl), Hl);
-	rgbtobw(texture2D(ima, STr), Hr);
-	rgbtobw(texture2D(ima, STd), Hd);
-	rgbtobw(texture2D(ima, STu), Hu);
+	rgbtobw(texture2D(ima, STl, lodbias), Hl);
+	rgbtobw(texture2D(ima, STr, lodbias), Hr);
+	rgbtobw(texture2D(ima, STd, lodbias), Hd);
+	rgbtobw(texture2D(ima, STu, lodbias), Hu);
 
 	vec2 dHdxy = vec2(Hr - Hl, Hu - Hd);
 	float fBlend = clamp(1.0 - textureQueryLOD(ima, texco.xy).x, 0.0, 1.0);
@@ -1585,7 +1662,7 @@ void mtex_bump_bicubic(
 
 void mtex_bump_tap5(
         vec3 texco, sampler2D ima, float hScale,
-        out float dBs, out float dBt)
+        float lodbias, out float dBs, out float dBt)
 {
 	vec2 TexDx = dFdx(texco.xy);
 	vec2 TexDy = dFdy(texco.xy);
@@ -1597,11 +1674,11 @@ void mtex_bump_tap5(
 	vec2 STu = texco.xy + 0.5 * TexDy;
 
 	float Hc, Hl, Hr, Hd, Hu;
-	rgbtobw(texture2D(ima, STc), Hc);
-	rgbtobw(texture2D(ima, STl), Hl);
-	rgbtobw(texture2D(ima, STr), Hr);
-	rgbtobw(texture2D(ima, STd), Hd);
-	rgbtobw(texture2D(ima, STu), Hu);
+	rgbtobw(texture2D(ima, STc, lodbias), Hc);
+	rgbtobw(texture2D(ima, STl, lodbias), Hl);
+	rgbtobw(texture2D(ima, STr, lodbias), Hr);
+	rgbtobw(texture2D(ima, STd, lodbias), Hd);
+	rgbtobw(texture2D(ima, STu, lodbias), Hu);
 
 	dBs = hScale * (Hr - Hl);
 	dBt = hScale * (Hu - Hd);
@@ -1609,7 +1686,7 @@ void mtex_bump_tap5(
 
 void mtex_bump_deriv(
         vec3 texco, sampler2D ima, float ima_x, float ima_y, float hScale,
-        out float dBs, out float dBt)
+        float lodbias, out float dBs, out float dBt)
 {
 	float s = 1.0;      // negate this if flipped texture coordinate
 	vec2 TexDx = dFdx(texco.xy);
@@ -1618,7 +1695,7 @@ void mtex_bump_deriv(
 	// this variant using a derivative map is described here
 	// http://mmikkelsen3d.blogspot.com/2011/07/derivative-maps.html
 	vec2 dim = vec2(ima_x, ima_y);
-	vec2 dBduv = hScale * dim * (2.0 * texture2D(ima, texco.xy).xy - 1.0);
+	vec2 dBduv = hScale * dim * (2.0 * texture2D(ima, texco.xy, lodbias).xy - 1.0);
 
 	dBs = dBduv.x * TexDx.x + s * dBduv.y * TexDx.y;
 	dBt = dBduv.x * TexDy.x + s * dBduv.y * TexDy.y;
@@ -1791,6 +1868,18 @@ void lamp_visibility_clamp(float visifac, out float outvisifac)
 	outvisifac = (visifac < 0.001) ? 0.0 : visifac;
 }
 
+void shade_alpha_depth(vec3 vp, sampler2D ima, float alpha, float factor, out float outalpha)
+{
+	float depth = texture2D(ima, gl_FragCoord.xy / vec2(textureSize(ima, 0))).x;
+
+	vec4 depthvp = gl_ProjectionMatrix * vec4(vp.xy, vp.z - factor, 1.0);
+
+	float startfade = gl_FragCoord.z;
+	float endfade = (1.0 + depthvp.z / depthvp.w) * 0.5;
+
+	outalpha = alpha * smoothstep(startfade, endfade, depth);
+}
+
 void world_paper_view(vec3 vec, out vec3 outvec)
 {
 	vec3 nvec = normalize(vec);
@@ -2034,6 +2123,26 @@ void shade_hemi_spec(vec3 vn, vec3 lv, vec3 view, float spec, float hard, float
 	t = visifac * spec * pow(t, hard);
 }
 
+float InScatter(vec3 start, vec3 dir, vec3 lightPos, float d)
+{
+	// calculate quadratic coefficients a,b,c
+	vec3 q = start - lightPos;
+	float b = dot(dir, q);
+	float c = dot(q, q);
+
+	// evaluate integral
+	float s = 1.0 / sqrt(c - b*b);
+
+	float l = s * (atan( (d + b) * s) - atan( b*s ));
+
+	return l;	
+}
+ 
+vec3 linePlaneIntersect(in vec3 lp, in vec3 lv, in vec3 pc, in vec3 pn)
+{
+   return lp+lv*(dot(pn,pc-lp)/dot(pn,lv));
+}
+
 void shade_phong_spec(vec3 n, vec3 l, vec3 v, float hard, out float specfac)
 {
 	vec3 h = normalize(l + v);
@@ -2255,10 +2364,92 @@ void test_shadowbuf(
 		//float bias = (1.5 - inp*inp)*shadowbias;
 		co.z -= shadowbias * co.w;
 
-		if (co.w > 0.0 && co.x > 0.0 && co.x / co.w < 1.0 && co.y > 0.0 && co.y / co.w < 1.0)
+		if (co.w > 0.0 && co.x > 0.0 && co.x / co.w < 1.0 && co.y > 0.0 && co.y / co.w < 1.0) {
 			result = shadow2DProj(shadowmap, co).x;
-		else
+		}
+		else {
 			result = 1.0;
+		}
+	}
+}
+
+void test_shadowbuf_pcf_early_bail(
+        vec3 rco, sampler2DShadow shadowmap, mat4 shadowpersmat, float samples, float samplesize, float shadowbias, float inp,
+        out float result)
+{
+	if (inp <= 0.0) {
+		result = 0.0;
+	}
+	else {
+		vec4 co = shadowpersmat * vec4(rco, 1.0);
+
+		//float bias = (1.5 - inp*inp)*shadowbias;
+		co.z -= shadowbias * co.w;
+
+		if (co.w > 0.0 && co.x > 0.0 && co.x / co.w < 1.0 && co.y > 0.0 && co.y / co.w < 1.0) {
+			float step = samplesize / samples;
+			float fullstep = samplesize - step * 0.95;
+			float halfsample = samplesize / 2.0 - step * 0.5 * 0.95;
+
+			result = 0.0;
+			for (float y = -halfsample; y <= halfsample; y += fullstep) {
+				for (float x = -halfsample; x <= halfsample; x += fullstep) {
+					result += shadow2DProj(shadowmap, vec4(co.xy + vec2(x, y) * 0.1, co.z, co.w)).x;
+				}
+			}
+
+			if (result > 0.0 && result < 4.0) {
+				float sampleoffset = halfsample - step;
+				for (float y = -sampleoffset; y <= sampleoffset; y += step) {
+					for (float x = -halfsample; x <= halfsample; x += step) {
+						result += shadow2DProj(shadowmap, vec4(co.xy + vec2(x, y) * 0.1, co.z, co.w)).x;
+					}
+				}
+				for (float y = -halfsample; y <= halfsample; y += fullstep) {
+					for (float x = -sampleoffset; x <= sampleoffset; x += step) {
+						result += shadow2DProj(shadowmap, vec4(co.xy + vec2(x, y) * 0.1, co.z, co.w)).x;
+					}
+				}
+				result /= (samples * samples);
+			}
+			else {
+				result /= 4.0;
+			}
+		}
+		else {
+			result = 1.0;
+		}
+	}
+}
+
+void test_shadowbuf_pcf(
+        vec3 rco, sampler2DShadow shadowmap, mat4 shadowpersmat, float samples, float samplesize, float shadowbias, float inp,
+        out float result)
+{
+	if (inp <= 0.0) {
+		result = 0.0;
+	}
+	else {
+		vec4 co = shadowpersmat * vec4(rco, 1.0);
+
+		//float bias = (1.5 - inp*inp)*shadowbias;
+		co.z -= shadowbias * co.w;
+
+		if (co.w > 0.0 && co.x > 0.0 && co.x / co.w < 1.0 && co.y > 0.0 && co.y / co.w < 1.0) {
+			float step = samplesize / samples;
+			float halfsample = samplesize / 2.0 - step * 0.5 * 0.95;
+
+			result = 0.0;
+			for (float y = -halfsample; y <= halfsample; y += step) {
+				for (float x = -halfsample; x <= halfsample; x += step) {
+					result += shadow2DProj(shadowmap, vec4(co.xy + vec2(x, y) * 0.1, co.z, co.w)).x;
+				}
+			}
+			result /= (samples * samples);
+		}
+		else {
+			result = 1.0;
+		}
 	}
 }
 
@@ -2296,42 +2487,21 @@ void test_shadowbuf_vsm(
 	}
 }
 
-void shadows_only(
-        vec3 rco, sampler2DShadow shadowmap, mat4 shadowpersmat,
-        float shadowbias, vec3 shadowcolor, float inp,
-        out vec3 result)
+void shadows_only(float inp, float shadfac, vec3 shadowcolor, out vec3 result)
 {
 	result = vec3(1.0);
 
 	if (inp > 0.0) {
-		float shadfac;
-
-		test_shadowbuf(rco, shadowmap, shadowpersmat, shadowbias, inp, shadfac);
 		result -= (1.0 - shadfac) * (vec3(1.0) - shadowcolor);
 	}
 }
 
-void shadows_only_vsm(
-        vec3 rco, sampler2D shadowmap, mat4 shadowpersmat,
-        float shadowbias, float bleedbias, vec3 shadowcolor, float inp,
-        out vec3 result)
-{
-	result = vec3(1.0);
-
-	if (inp > 0.0) {
-		float shadfac;
-
-		test_shadowbuf_vsm(rco, shadowmap, shadowpersmat, shadowbias, bleedbias, inp, shadfac);
-		result -= (1.0 - shadfac) * (vec3(1.0) - shadowcolor);
-	}
-}
-
-void shade_light_texture(vec3 rco, sampler2D cookie, mat4 shadowpersmat, out vec4 result)
+void shade_light_texture(vec3 rco, sampler2D cookie, vec3 scale, float lodbias, mat4 shadowpersmat, out vec4 result)
 {
 
 	vec4 co = shadowpersmat * vec4(rco, 1.0);
 
-	result = texture2DProj(cookie, co);
+	result = texture2DProj(cookie, co * vec4(scale, 1.0), lodbias);
 }
 
 void shade_exposure_correct(vec3 col, float linfac, float logfac, out vec3 outcol)
@@ -2894,16 +3064,16 @@ void node_tex_clouds(vec3 co, float size, out vec4 color, out float fac)
 	fac = 1.0;
 }
 
-void node_tex_environment_equirectangular(vec3 co, sampler2D ima, out vec4 color)
+void node_tex_environment_equirectangular(vec3 co, sampler2D ima, float lodbias, out vec4 color)
 {
 	vec3 nco = normalize(co);
 	float u = -atan(nco.y, nco.x) / (2.0 * M_PI) + 0.5;
 	float v = atan(nco.z, hypot(nco.x, nco.y)) / M_PI + 0.5;
 
-	color = texture2D(ima, vec2(u, v));
+	color = texture2D(ima, vec2(u, v), lodbias);
 }
 
-void node_tex_environment_mirror_ball(vec3 co, sampler2D ima, out vec4 color)
+void node_tex_environment_mirror_ball(vec3 co, sampler2D ima, float lodbias, out vec4 color)
 {
 	vec3 nco = normalize(co);
 
@@ -2916,7 +3086,7 @@ void node_tex_environment_mirror_ball(vec3 co, sampler2D ima, out vec4 color)
 	float u = 0.5 * (nco.x + 1.0);
 	float v = 0.5 * (nco.z + 1.0);
 
-	color = texture2D(ima, vec2(u, v));
+	color = texture2D(ima, vec2(u, v), lodbias);
 }
 
 void node_tex_environment_empty(vec3 co, out vec4 color)
@@ -3613,6 +3783,76 @@ void node_output_world(vec4 surface, vec4 volume, out vec4 result)
 	result = surface;
 }
 
+void parallax_out(vec3 texco, vec3 vp, vec4 tangent, vec3 vn, vec3 size, mat3 mat, sampler2D ima, float scale, float numsteps,
+				  float bumpscale, float discarduv, out vec3 ptexcoord)
+{
+	vec3 binormal = cross(-vn, tangent.xyz) * tangent.w;
+	vec3 vvec = vec3(dot(tangent.xyz, vp), dot(binormal, vp), dot(-vn, vp));
+	vec3 vv = normalize(vvec);
+
+	// The uv shift per depth step, multitply by rotation and after size.
+	vec2 delta = (vec3(-vv.x, gl_FrontFacing ? vv.y : -vv.y, 0.0) * mat * size * bumpscale / vv.z).xy;
+
+	float height = 0.0;
+
+	// The depth to start from, top to bottom.
+	float depth = 1.0;
+	float depthstep = 1.0 / numsteps;
+
+	/* Uv is computed with the current depth value using the formula:
+	 * uv = original_uv * delta_uv * (1.0 - depth)
+	 */
+
+	// Linear sample from top.
+	for (int i = 0; i < numsteps; ++i) {
+		height = textureLod(ima, texco.xy - delta * (1.0 - depth), 0).a;
+		// Stop if the texture height is greater than current depth.
+		if (height > depth) {
+			break;
+		}
+
+		depth -= depthstep;
+	}
+
+	vec2 texuv = texco.xy - delta * (1.0 - depth);
+
+	/* Interpolation.
+	 * Compare the distance of the height texture with current level and previous level.
+	 */
+
+	// Compute the depth before the last step, reverse operation.
+	float depthprelay = depth + depthstep;
+	// Compute the uv with the pre depth.
+	vec2 texuvprelay = texco.xy - delta * (1.0 - depthprelay);
+
+	// The shift between the texture height and the last depth.
+	float depthshiftcurlay = height - depth;
+	// The shift between the texture height with precedent uv computed with pre detph and the pre depth.
+	float depthshiftprelay = textureLod(ima, texuvprelay, 0).a - depthprelay;
+
+	float weight = 1.0;
+	// If the height is right in the middle of two step the difference of the two shifts will be null.
+	if ((depthshiftcurlay - depthshiftprelay) > 0.0) {
+		// Get shift ratio.
+		weight = depthshiftcurlay / (depthshiftcurlay - depthshiftprelay);
+	}
+
+	vec2 finaltexuv = mix(texuv, texuvprelay, weight);
+
+	// Discard if uv is out of the range 0 to 1.
+	const vec2 clampmin = vec2(-0.5);
+	const vec2 clampmax = vec2(0.5);
+
+	if ((discarduv == 1.0) &&
+		(finaltexuv.x - 0.5 < clampmin.x * size.x || finaltexuv.x - 0.5 > clampmax.x * size.x ||
+		finaltexuv.y - 0.5 < clampmin.y * size.y || finaltexuv.y - 0.5 > clampmax.y * size.y))
+	{
+		discard;
+	}
+
+	ptexcoord = vec3(finaltexuv, texco.z);
+}
+
 /* ********************** matcap style render ******************** */
 
 void material_preview_matcap(vec4 color, sampler2D ima, vec4 N, vec4 mask, out vec4 result)
diff --git a/source/blender/gpu/shaders/gpu_shader_vertex.glsl b/source/blender/gpu/shaders/gpu_shader_vertex.glsl
index db0068d..7b67597 100644
--- a/source/blender/gpu/shaders/gpu_shader_vertex.glsl
+++ b/source/blender/gpu/shaders/gpu_shader_vertex.glsl
@@ -7,6 +7,20 @@ out block {
 } outpt;
 #endif
 
+#ifdef USE_INSTANCING
+in mat3 ininstmatrix;
+in vec3 ininstposition;
+in vec4 ininstcolor;
+
+varying vec4 varinstcolor;
+varying mat4 varinstmat;
+varying mat4 varinstinvmat;
+varying mat4 varinstlocaltoviewmat;
+varying mat4 varinstinvlocaltoviewmat;
+
+uniform mat4 unfviewmat;
+#endif
+
 varying vec3 varposition;
 varying vec3 varnormal;
 
@@ -89,6 +103,22 @@ void main()
 	vec3 normal = gl_Normal;
 #endif
 
+#ifdef USE_INSTANCING
+	mat4 instmat = mat4(vec4(ininstmatrix[0], ininstposition.x),
+						vec4(ininstmatrix[1], ininstposition.y),
+						vec4(ininstmatrix[2], ininstposition.z),
+						vec4(0.0, 0.0, 0.0, 1.0));
+
+	varinstmat = transpose(instmat);
+	varinstlocaltoviewmat = unfviewmat * varinstmat;
+	varinstinvmat = inverse(varinstmat);
+	varinstinvlocaltoviewmat = inverse(varinstlocaltoviewmat);
+	varinstcolor = ininstcolor;
+
+	position *= instmat;
+	normal *= ininstmatrix;
+#endif
+
 	vec4 co = gl_ModelViewMatrix * position;
 
 	varposition = co.xyz;
diff --git a/source/blender/gpu/shaders/gpu_shader_vsm_store_vert.glsl b/source/blender/gpu/shaders/gpu_shader_vsm_store_vert.glsl
index 224c3e7..58af4b7 100644
--- a/source/blender/gpu/shaders/gpu_shader_vsm_store_vert.glsl
+++ b/source/blender/gpu/shaders/gpu_shader_vsm_store_vert.glsl
@@ -1,7 +1,22 @@
 varying vec4 v_position;
 
+#ifdef USE_INSTANCING
+in mat3 ininstmatrix;
+in vec3 ininstposition;
+#endif
+
 void main()
 {
-	gl_Position = ftransform();
+#ifdef USE_INSTANCING
+	mat4 instmat = mat4(vec4(ininstmatrix[0], ininstposition.x),
+						vec4(ininstmatrix[1], ininstposition.y),
+						vec4(ininstmatrix[2], ininstposition.z),
+						vec4(0.0, 0.0, 0.0, 1.0));
+
+	v_position = gl_ProjectionMatrix * gl_ModelViewMatrix * (gl_Vertex * instmat);
+	gl_Position = v_position;
+#else
+	gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * gl_Vertex;
 	v_position = gl_Position;
+#endif
 }
diff --git a/source/blender/makesdna/DNA_actuator_types.h b/source/blender/makesdna/DNA_actuator_types.h
index 6bdea21..a91354e 100644
--- a/source/blender/makesdna/DNA_actuator_types.h
+++ b/source/blender/makesdna/DNA_actuator_types.h
@@ -87,7 +87,7 @@ typedef struct bSoundActuator {
 } bSoundActuator;
 
 typedef struct bEditObjectActuator {
-	int time;
+	float time;
 	short type, flag;
 	struct Object *ob;
 	struct Mesh *me;
@@ -190,6 +190,13 @@ typedef struct bGameActuator {
 	char loadaniname[64];
 } bGameActuator;
 
+typedef struct bVibrationActuator {
+	int joyindex;
+	short mode, pad1; /* mode: 0 = Play, 1 = Stop */
+	float strength, strength_right; /* strength --> low frequency motor, strength_right --> high frequency motor */
+	int duration;
+} bVibrationActuator;
+
 typedef struct bVisibilityActuator {
 	/** bit 0: Is this object visible? 
 	 ** bit 1: Apply recursively  
@@ -329,6 +336,7 @@ typedef struct bActuator {
 #define ACT_ARMATURE	23
 #define ACT_STEERING    24
 #define ACT_MOUSE		25
+#define ACT_VIBRATION	26
 
 /* actuator flag */
 #define ACT_SHOW		1
@@ -454,7 +462,8 @@ typedef struct bActuator {
 #define ACT_EDOB_ENABLE_RB		2
 #define ACT_EDOB_DISABLE_RB		3
 #define ACT_EDOB_SET_MASS		4
-
+#define ACT_EDOB_RESTORE_PHY	5
+#define ACT_EDOB_SUSPEND_PHY	6
 
 /* SceneActuator->type */
 #define ACT_SCENE_RESTART		0
@@ -580,4 +589,8 @@ typedef struct bActuator {
 #define ACT_MOUSE_OBJECT_AXIS_Y	1
 #define ACT_MOUSE_OBJECT_AXIS_Z	2
 
+/* vibrationactuator->mode */
+#define ACT_VIBRATION_PLAY		0
+#define ACT_VIBRATION_STOP		1
+
 #endif  /* __DNA_ACTUATOR_TYPES_H__ */
diff --git a/source/blender/makesdna/DNA_camera_types.h b/source/blender/makesdna/DNA_camera_types.h
index 52e40cb..7f62357 100644
--- a/source/blender/makesdna/DNA_camera_types.h
+++ b/source/blender/makesdna/DNA_camera_types.h
@@ -124,6 +124,7 @@ enum {
 #endif
 	CAM_SHOWSENSOR          = (1 << 8),
 	CAM_SHOW_SAFE_CENTER    = (1 << 9),
+	CAM_SHOW_FRUSTUM		= (1 << 10),
 };
 
 /* yafray: dof sampling switch */
diff --git a/source/blender/makesdna/DNA_lamp_types.h b/source/blender/makesdna/DNA_lamp_types.h
index a2e39f9..df5a4c6 100644
--- a/source/blender/makesdna/DNA_lamp_types.h
+++ b/source/blender/makesdna/DNA_lamp_types.h
@@ -67,7 +67,8 @@ typedef struct Lamp {
 	short pad2;
 	
 	float clipsta, clipend;
-	float bias, soft, compressthresh, bleedbias, pad5;
+	float bias, soft, compressthresh, bleedbias;
+	float bufsharp;
 	short bufsize, samp, buffers, filtertype;
 	char bufflag, buftype;
 	
@@ -78,6 +79,7 @@ typedef struct Lamp {
 	float adapt_thresh;
 	short ray_samp_method;
 	short shadowmap_type;
+	short shadow_filter, pad3[3];
 	
 	/* texact is for buttons */
 	short texact, shadhalostep;
@@ -151,6 +153,12 @@ typedef struct Lamp {
 #define LA_SHAD_TEX     (1 << 16)
 #define LA_SHOW_CONE    (1 << 17)
 #define LA_SHOW_SHADOW_BOX (1 << 18)
+#define LA_STATIC_SHADOW (1 << 19)
+
+/* shadow_filter */
+#define LA_SHADOW_FILTER_NONE		0
+#define LA_SHADOW_FILTER_PCF		1
+#define LA_SHADOW_FILTER_PCF_BAIL	2
 
 /* layer_shadow */
 #define LA_LAYER_SHADOW_BOTH	0
diff --git a/source/blender/makesdna/DNA_material_types.h b/source/blender/makesdna/DNA_material_types.h
index 0c500e3..6ace3f6 100644
--- a/source/blender/makesdna/DNA_material_types.h
+++ b/source/blender/makesdna/DNA_material_types.h
@@ -80,7 +80,7 @@ typedef struct GameSettings {
 	int flag;
 	int alpha_blend;
 	int face_orientation;
-	int pad1;
+	int pad;
 } GameSettings;
 
 typedef struct TexPaintSlot {
@@ -171,9 +171,10 @@ typedef struct Material {
 	struct PreviewImage *preview;
 
 	/* dynamic properties */
-	float friction, fh, reflect;
-	float fhdist, xyfrict;
-	short dynamode, pad2;
+	float friction DNA_DEPRECATED, rolling_friction DNA_DEPRECATED;
+	float fh DNA_DEPRECATED, reflect DNA_DEPRECATED;
+	float fhdist DNA_DEPRECATED, xyfrict DNA_DEPRECATED;
+	short dynamode DNA_DEPRECATED, pad2[3];
 
 	/* subsurface scattering */
 	float sss_radius[3], sss_col[3];
@@ -195,7 +196,12 @@ typedef struct Material {
 	short paint_active_slot;
 	short paint_clone_slot;
 	short tot_slots;
-	short pad4[3];
+
+	/* Constants settings */
+	short constflag;
+
+	/* Depth transparency settings */
+	float depthtranspfactor;
 
 	/* multiple tangent (Normal Map node) */
 	char nmap_tangent_names[9][64]; /* [MAX_MTFACE+1][MAX_NAME]; +1 for empty name */
@@ -204,6 +210,7 @@ typedef struct Material {
 	struct TexPaintSlot *texpaintslot; /* cached slot for painting. Make sure to recalculate before use
 	                                    * with refresh_texpaint_image_cache */
 	ListBase gpumaterial;		/* runtime */
+	ListBase gpumaterialinstancing;		/* runtime */
 } Material;
 
 
@@ -219,8 +226,7 @@ typedef struct Material {
 // Game Options - flag
 #define GEMAT_BACKCULL 		16 /* KX_BACKCULL */
 #define GEMAT_SHADED		32 /* KX_LIGHT */
-#define GEMAT_TEXT		64 /* RAS_RENDER_3DPOLYGON_TEXT */
-#define	GEMAT_NOPHYSICS		128
+#define GEMAT_NOPHYSICS		128
 #define GEMAT_INVISIBLE 	256
 
 // Face Orientation Options - face_orientation
@@ -229,10 +235,6 @@ typedef struct Material {
 #define GEMAT_BILLBOARD		1024 /* BILLBOARD_AXISALIGNED */
 #define GEMAT_SHADOW		2048 /* SHADOW */
 
-// Use Textures - not defined directly in the UI
-#define GEMAT_TEX		4096 /* KX_TEX */
-
-
 /* **************** MATERIAL ********************* */
 
 /* maximum number of materials per material array.
@@ -247,6 +249,14 @@ typedef struct Material {
 #define MA_TYPE_VOLUME	2
 #define MA_TYPE_WIRE	3
 
+/* constflag */
+#define MA_CONSTANT_MATERIAL	(1 << 0)
+#define MA_CONSTANT_LAMP		(1 << 1)
+#define MA_CONSTANT_TEXTURE		(1 << 2)
+#define MA_CONSTANT_WORLD		(1 << 3)
+#define MA_CONSTANT_MIST		(1 << 4)
+#define MA_CONSTANT_TEXTURE_UV	(1 << 5)
+
 /* flag */
 		/* for render */
 #define MA_IS_USED		1
@@ -310,6 +320,7 @@ typedef struct Material {
 #define MA_CASTSHADOW		(1 << 0)
 #define MA_MODE2_PIPELINE	(MA_CASTSHADOW)
 #define MA_TANGENT_CONCRETE	(1 << 1)
+#define MA_DEPTH_TRANSP		(1 << 2)
 
 /* mapflag */
 #define MA_MAPFLAG_UVPROJECT (1 << 0)
@@ -328,6 +339,7 @@ typedef struct Material {
 #define MA_OBCOLOR			2
 #define MA_APPROX_OCCLUSION	4
 #define MA_GROUP_LOCAL      8
+#define MA_INSTANCING		16
 
 /* diff_shader */
 #define MA_DIFF_LAMBERT		0
@@ -344,8 +356,9 @@ typedef struct Material {
 #define MA_SPEC_WARDISO		4
 
 /* dynamode */
-// #define MA_DRAW_DYNABUTS    1		/* deprecated */
-#define MA_FH_NOR	        2
+#ifdef DNA_DEPRECATED
+#  define MA_FH_NOR	        2
+#endif
 
 /* ramps */
 #define MA_RAMP_IN_SHADER	0
@@ -409,6 +422,7 @@ typedef struct Material {
 #define MAP_DISPLACE	4096
 #define MAP_WARP		8192
 // #define MAP_LAYER		16384		/* unused */
+#define MAP_PARALLAX	32768
 
 /* volume mapto - reuse definitions for now - a bit naughty! */
 #define MAP_DENSITY				128
diff --git a/source/blender/makesdna/DNA_object_types.h b/source/blender/makesdna/DNA_object_types.h
index d24c7fa..ab7851f 100644
--- a/source/blender/makesdna/DNA_object_types.h
+++ b/source/blender/makesdna/DNA_object_types.h
@@ -243,6 +243,7 @@ typedef struct Object {
 	ListBase sensors;		/* game logic sensors */
 	ListBase controllers;	/* game logic controllers */
 	ListBase actuators;		/* game logic actuators */
+	ListBase components;	/* python components */
 
 	float sf; /* sf is time-offset */
 
@@ -260,6 +261,11 @@ typedef struct Object {
 	short softflag;			/* softbody settings */
 	float anisotropicFriction[3];
 
+	/* dynamic properties */
+	float friction, rolling_friction, fh, reflect;
+	float fhdist, xyfrict;
+	short dynamode, pad3[3];
+
 	ListBase constraints;		/* object constraints */
 	ListBase nlastrips  DNA_DEPRECATED;			// XXX deprecated... old animation system
 	ListBase hooks  DNA_DEPRECATED;				// XXX deprecated... old animation system
@@ -299,6 +305,8 @@ typedef struct Object {
 	LodLevel *currentlod;
 
 	struct PreviewImage *preview;
+
+	struct Mesh *gamePredefinedBound;
 } Object;
 
 /* Warning, this is not used anymore because hooks are now modifiers */
@@ -339,6 +347,9 @@ typedef struct DupliObject {
 
 /* **************** OBJECT ********************* */
 
+/* dynamode */
+#define OB_FH_NOR	        2
+
 /* used many places... should be specialized  */
 #define SELECT          1
 
@@ -561,8 +572,6 @@ enum {
 	OB_NAVMESH               = 1 << 20,
 	OB_HASOBSTACLE           = 1 << 21,
 	OB_CHARACTER             = 1 << 22,
-
-	OB_RECORD_ANIMATION      = 1 << 23,
 };
 
 /* ob->gameflag2 */
diff --git a/source/blender/makesdna/DNA_python_component_types.h b/source/blender/makesdna/DNA_python_component_types.h
new file mode 100644
index 0000000..b20bacd
--- /dev/null
+++ b/source/blender/makesdna/DNA_python_component_types.h
@@ -0,0 +1,59 @@
+/**
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contributor(s): Mitchell Stokes, Diego Lopes, Tristan Porteries.
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef __DNA_COMPONENT_TYPES_H__
+#define __DNA_COMPONENT_TYPES_H__
+
+#include "DNA_listBase.h"
+
+typedef struct PythonComponentProperty {
+	struct PythonComponentProperty *next, *prev;
+	char name[64];
+	short type;
+	short boolval;
+	int intval;
+	float floatval;
+	char strval[64];
+	int itemval;
+	float vec[4];
+	ListBase enumval;
+} PythonComponentProperty;
+
+typedef struct PythonComponent {
+	struct PythonComponent *next, *prev;
+	ListBase properties;
+	char name[64];
+	char module[64];
+} PythonComponent;
+
+
+/* PythonComponentProperty.type */
+#define CPROP_TYPE_INT         0
+#define CPROP_TYPE_FLOAT       1
+#define CPROP_TYPE_STRING      2
+#define CPROP_TYPE_BOOLEAN     3
+#define CPROP_TYPE_SET         4
+#define CPROP_TYPE_VEC2        5
+#define CPROP_TYPE_VEC3        6
+#define CPROP_TYPE_VEC4        7
+
+#endif /* __DNA_COMPONENT_TYPES_H__ */
diff --git a/source/blender/makesdna/DNA_scene_types.h b/source/blender/makesdna/DNA_scene_types.h
index f5e71ae..a2e51be 100644
--- a/source/blender/makesdna/DNA_scene_types.h
+++ b/source/blender/makesdna/DNA_scene_types.h
@@ -736,13 +736,6 @@ typedef struct RenderData {
 	short jp2_preset  DNA_DEPRECATED, jp2_depth  DNA_DEPRECATED;  /*deprecated*/
 	int rpad3;
 
-	/* Dome variables */ //  XXX deprecated since 2.5
-	short domeres  DNA_DEPRECATED, domemode  DNA_DEPRECATED;	//  XXX deprecated since 2.5
-	short domeangle  DNA_DEPRECATED, dometilt  DNA_DEPRECATED;	//  XXX deprecated since 2.5
-	float domeresbuf  DNA_DEPRECATED;	//  XXX deprecated since 2.5
-	float pad2;
-	struct Text *dometext  DNA_DEPRECATED;	//  XXX deprecated since 2.5
-
 	/* Freestyle line thickness options */
 	int line_thickness_mode;
 	float unit_line_thickness; /* in pixels */
@@ -790,23 +783,6 @@ typedef struct RenderProfile {
 } RenderProfile;
 
 /* *************************************************************** */
-/* Game Engine - Dome */
-
-typedef struct GameDome {
-	short res, mode;
-	short angle, tilt;
-	float resbuf, pad2;
-	struct Text *warptext;
-} GameDome;
-
-#define DOME_FISHEYE			1
-#define DOME_TRUNCATED_FRONT	2
-#define DOME_TRUNCATED_REAR		3
-#define DOME_ENVMAP				4
-#define DOME_PANORAM_SPH		5
-#define DOME_NUM_MODES			6
-
-/* *************************************************************** */
 /* Game Engine */
 
 typedef struct GameFraming {
@@ -847,10 +823,10 @@ typedef struct GameData {
 	struct GameFraming framing;
 	short playerflag, xplay, yplay, freqplay;
 	short depth, attrib, rt1, rt2;
-	short aasamples, pad4[3];
+	short aasamples;
+	short hdr;
+	short pad4[2];
 
-	/* stereo/dome mode */
-	struct GameDome dome;
 	short stereoflag, stereomode;
 	float eyeseparation;
 	RecastData recastData;
@@ -869,35 +845,32 @@ typedef struct GameData {
 	 * bit 5: (gameengine) : enable Bullet DBVT tree for view frustum culling
 	 */
 	int flag;
-	short mode, matmode;
+	short mode;
 	short occlusionRes;		/* resolution of occlusion Z buffer in pixel */
 	short physicsEngine;
 	short exitkey;
+	short pythonkeys[4];
 	short vsync; /* Controls vsync: off, on, or adaptive (if supported) */
 	short ticrate, maxlogicstep, physubstep, maxphystep;
 	short obstacleSimulation;
-	short raster_storage;
 	float levelHeight;
 	float deactivationtime, lineardeactthreshold, angulardeactthreshold;
 
 	/* Scene LoD */
 	short lodflag, pad2;
-	int scehysteresis, pad5;
+	int scehysteresis;
 
 } GameData;
 
 #define STEREO_NOSTEREO		1
 #define STEREO_ENABLED		2
-#define STEREO_DOME			3
 
-//#define STEREO_NOSTEREO		 1
 #define STEREO_QUADBUFFERED 2
 #define STEREO_ABOVEBELOW	 3
 #define STEREO_INTERLACED	 4
 #define STEREO_ANAGLYPH		5
 #define STEREO_SIDEBYSIDE	6
 #define STEREO_VINTERLACE	7
-//#define STEREO_DOME		8
 #define STEREO_3DTVTOPBOTTOM 9
 
 /* physicsEngine */
@@ -909,12 +882,6 @@ typedef struct GameData {
 #define OBSTSIMULATION_TOI_rays		1
 #define OBSTSIMULATION_TOI_cells	2
 
-/* Raster storage */
-#define RAS_STORE_AUTO		0
-#define RAS_STORE_IMMEDIATE	1
-#define RAS_STORE_VA		2
-#define RAS_STORE_VBO		3
-
 /* vsync */
 #define VSYNC_ON	0
 #define VSYNC_OFF	1
@@ -926,7 +893,6 @@ typedef struct GameData {
 #define GAME_SHOW_DEBUG_PROPS				(1 << 2)
 #define GAME_SHOW_FRAMERATE					(1 << 3)
 #define GAME_SHOW_PHYSICS					(1 << 4)
-#define GAME_DISPLAY_LISTS					(1 << 5)
 #define GAME_GLSL_NO_LIGHTS					(1 << 6)
 #define GAME_GLSL_NO_SHADERS				(1 << 7)
 #define GAME_GLSL_NO_SHADOWS				(1 << 8)
@@ -934,12 +900,13 @@ typedef struct GameData {
 #define GAME_GLSL_NO_NODES					(1 << 10)
 #define GAME_GLSL_NO_EXTRA_TEX				(1 << 11)
 #define GAME_IGNORE_DEPRECATION_WARNINGS	(1 << 12)
-#define GAME_ENABLE_ANIMATION_RECORD		(1 << 13)
 #define GAME_SHOW_MOUSE						(1 << 14)
 #define GAME_GLSL_NO_COLOR_MANAGEMENT		(1 << 15)
 #define GAME_SHOW_OBSTACLE_SIMULATION		(1 << 16)
-#define GAME_NO_MATERIAL_CACHING			(1 << 17)
-#define GAME_GLSL_NO_ENV_LIGHTING			(1 << 18)
+#define GAME_SHOW_BOUNDING_BOX				(1 << 18)
+#define GAME_SHOW_ARMATURES					(1 << 19)
+#define GAME_PYTHON_CONSOLE					(1 << 20)
+#define GAME_GLSL_NO_ENV_LIGHTING			(1 << 21)
 /* Note: GameData.flag is now an int (max 32 flags). A short could only take 16 flags */
 
 /* GameData.playerflag */
@@ -950,14 +917,19 @@ typedef struct GameData {
 enum {
 #ifdef DNA_DEPRECATED
 	GAME_MAT_TEXFACE    = 0, /* deprecated */
-#endif
 	GAME_MAT_MULTITEX   = 1,
 	GAME_MAT_GLSL       = 2,
+#endif
 };
 
 /* GameData.lodflag */
 #define SCE_LOD_USE_HYST		(1 << 0)
 
+/* GameData.hdr */
+#define GAME_HDR_NONE		0
+#define GAME_HDR_HALF_FLOAT	1
+#define GAME_HDR_FULL_FLOAT	2
+
 /* UV Paint */
 #define UV_SCULPT_LOCK_BORDERS				1
 #define UV_SCULPT_ALL_ISLANDS				2
diff --git a/source/blender/makesdna/DNA_sensor_types.h b/source/blender/makesdna/DNA_sensor_types.h
index 3706485..2d55d1c 100644
--- a/source/blender/makesdna/DNA_sensor_types.h
+++ b/source/blender/makesdna/DNA_sensor_types.h
@@ -134,6 +134,7 @@ typedef struct bRaySensor {
 	short mode;
 	short pad1;
 	int axisflag;
+	int mask;
 } bRaySensor;
 
 typedef struct bArmatureSensor {
@@ -188,11 +189,15 @@ typedef struct bJoystickSensor {
 	short axis_single;
 	int axisf;
 	int button;
-	int hat;
-	int hatf;
 	int precision;
 } bJoystickSensor;
 
+typedef struct bMovementSensor {
+	int axisflag;
+	int localflag;
+	float threshold, pad;
+} bMovementSensor;
+
 /* bMouseSensor->type: uses blender event defines */
 
 /* bMouseSensor->flag: only pulse for now */
@@ -217,6 +222,20 @@ typedef struct bJoystickSensor {
 #define SENS_RAY_NEG_Z_AXIS     5
 //#define SENS_RAY_NEGATIVE_AXIS     1
 
+/* movementSensor->axisflag */
+/* flip x and y to make y default!!! */
+#define SENS_MOVEMENT_X_AXIS     0
+#define SENS_MOVEMENT_Y_AXIS     1
+#define SENS_MOVEMENT_Z_AXIS     2
+#define SENS_MOVEMENT_NEG_X_AXIS     3
+#define SENS_MOVEMENT_NEG_Y_AXIS     4
+#define SENS_MOVEMENT_NEG_Z_AXIS     5
+#define SENS_MOVEMENT_ALL_AXIS       6
+
+/* movementSensor->localflag */
+/* Flag to toggle local/global coordinates*/
+#define SENS_MOVEMENT_LOCAL 1
+
 /* bRadarSensor->axis */
 #define SENS_RADAR_X_AXIS     0
 #define SENS_RADAR_Y_AXIS     1
@@ -254,6 +273,7 @@ typedef struct bJoystickSensor {
 #define SENS_ACTUATOR  12
 #define SENS_DELAY     13
 #define SENS_ARMATURE  14
+#define SENS_MOVEMENT  15
 /* sensor->flag */
 #define SENS_SHOW		1
 #define SENS_DEL		2
@@ -303,15 +323,34 @@ typedef struct bJoystickSensor {
 #define SENS_JOY_ANY_EVENT		1
 
 #define SENS_JOY_BUTTON		0			/* axis type */
+#define SENS_JOY_BUTTON_PRESSED			0
+#define SENS_JOY_BUTTON_RELEASED		1
+#define SENS_JOY_BUTTON_A				0
+#define SENS_JOY_BUTTON_B				1
+#define SENS_JOY_BUTTON_X				2
+#define SENS_JOY_BUTTON_Y				3
+#define SENS_JOY_BUTTON_BACK			4
+#define SENS_JOY_BUTTON_GUIDE			5
+#define SENS_JOY_BUTTON_START			6
+#define SENS_JOY_BUTTON_STICK_LEFT		7
+#define SENS_JOY_BUTTON_STICK_RIGHT		8
+#define SENS_JOY_BUTTON_SHOULDER_LEFT	9
+#define SENS_JOY_BUTTON_SHOULDER_RIGHT	10
+#define SENS_JOY_BUTTON_DPAD_UP			11
+#define SENS_JOY_BUTTON_DPAD_DOWN		12
+#define SENS_JOY_BUTTON_DPAD_LEFT		13
+#define SENS_JOY_BUTTON_DPAD_RIGHT		14
 
 #define SENS_JOY_AXIS			1		/* axis type */
+#define SENS_JOY_LEFT_STICK			1
+#define SENS_JOY_RIGHT_STICK		2
 #define SENS_JOY_X_AXIS		0
 #define SENS_JOY_Y_AXIS		1
 #define SENS_JOY_NEG_X_AXIS     	2
 #define SENS_JOY_NEG_Y_AXIS     	3
 #define SENS_JOY_PRECISION		4
 
-#define SENS_JOY_HAT			2		/* axis type */
+#define SENS_JOY_HAT			2		/* axis type */ /* Unused all Hat related defines */
 #define SENS_JOY_HAT_DIR		0
 #define SENS_JOY_HAT_UP			1
 #define SENS_JOY_HAT_RIGHT		2
@@ -323,9 +362,15 @@ typedef struct bJoystickSensor {
 #define SENS_JOY_HAT_UP_LEFT	SENS_JOY_HAT_UP | SENS_JOY_HAT_LEFT
 #define SENS_JOY_HAT_DOWN_LEFT	SENS_JOY_HAT_DOWN | SENS_JOY_HAT_LEFT
 
-
 #define SENS_JOY_AXIS_SINGLE	3		/* axis type */
-
+#define SENS_JOY_LEFT_STICK_HORIZONTAL	1
+#define SENS_JOY_LEFT_STICK_VERTICAL	2
+#define SENS_JOY_RIGHT_STICK_HORIZONTAL	3
+#define SENS_JOY_RIGHT_STICK_VERTICAL	4
+
+#define SENS_JOY_SHOULDER_TRIGGER	4	/* axis type */
+#define SENS_JOY_LEFT_SHOULDER_TRIGGER	1
+#define SENS_JOY_RIGHT_SHOULDER_TRIGGER	2
 
 #define SENS_DELAY_REPEAT		1
 // should match JOYINDEX_MAX in SCA_JoystickDefines.h */
diff --git a/source/blender/makesdna/DNA_space_types.h b/source/blender/makesdna/DNA_space_types.h
index 5e01554..b6e79a8 100644
--- a/source/blender/makesdna/DNA_space_types.h
+++ b/source/blender/makesdna/DNA_space_types.h
@@ -1193,6 +1193,8 @@ typedef struct SpaceLogic {
 	short flag, scaflag;
 	int pad;
 	
+	char import_string[64];
+
 	struct bGPdata *gpd;        /* grease-pencil data */
 } SpaceLogic;
 
diff --git a/source/blender/makesdna/DNA_texture_types.h b/source/blender/makesdna/DNA_texture_types.h
index 995d764..d0358f1 100644
--- a/source/blender/makesdna/DNA_texture_types.h
+++ b/source/blender/makesdna/DNA_texture_types.h
@@ -76,11 +76,13 @@ typedef struct MTex {
 	
 	/* material */
 	float norfac, dispfac, warpfac;
+	float parallaxuv, parallaxsteps, parallaxbumpsc, padpfac;
 	float colspecfac, mirrfac, alphafac;
 	float difffac, specfac, emitfac, hardfac;
 	float raymirrfac, translfac, ambfac;
 	float colemitfac, colreflfac, coltransfac;
 	float densfac, scatterfac, reflfac;
+	float ior, refrratio;
 
 	/* particles */
 	float timefac, lengthfac, clumpfac, dampfac;
@@ -93,6 +95,11 @@ typedef struct MTex {
 
 	/* world */
 	float zenupfac, zendownfac, blendfac;
+
+	float lodbias;
+
+	/* parallax */
+	short parflag, pad3;
 } MTex;
 
 #ifndef DNA_USHORT_FIX
@@ -134,6 +141,7 @@ typedef struct EnvMap {
 	short cuberes, depth;
 	int ok, lastframe;
 	short recalc, lastsize;
+	int flag, filtering;
 } EnvMap;
 
 typedef struct PointDensity {
@@ -467,6 +475,16 @@ typedef struct ColorMapping {
 #define TEX_PR_OTHER	1
 #define TEX_PR_BOTH		2
 
+/* **************** ENVMAP ****************** */
+
+/* flag */
+#define ENVMAP_AUTO_UPDATE	(1 << 0)
+
+/* filtering */
+#define ENVMAP_MIPMAP_NONE		0
+#define ENVMAP_MIPMAP_LINEAR	1
+#define ENVMAP_MIPMAP_MIPMAP	2
+
 /* **************** MTEX ********************* */
 
 /* proj */
@@ -493,6 +511,10 @@ typedef struct ColorMapping {
 #define MTEX_BICUBIC_BUMP		8192
 #define MTEX_MAPTO_BOUNDS		16384
 
+#define MTEX_PARALLAX_UV		32768 // texflag
+#define MTEX_DISCARD_AT_EDGES	1     // parflag
+
+
 /* blendtype */
 #define MTEX_BLEND		0
 #define MTEX_MUL		1
@@ -560,6 +582,7 @@ enum {
 #define ENV_STATIC	0
 #define ENV_ANIM	1
 #define ENV_LOAD	2
+#define ENV_REALT	3
 
 /* ok */
 #define ENV_NORMAL	1
diff --git a/source/blender/makesdna/intern/makesdna.c b/source/blender/makesdna/intern/makesdna.c
index 2cea871..15fb4df 100644
--- a/source/blender/makesdna/intern/makesdna.c
+++ b/source/blender/makesdna/intern/makesdna.c
@@ -129,6 +129,7 @@ static const char *includefiles[] = {
 	"DNA_rigidbody_types.h",
 	"DNA_freestyle_types.h",
 	"DNA_linestyle_types.h",
+	"DNA_python_component_types.h",
 	"DNA_cachefile_types.h",
 	/* see comment above before editing! */
 
@@ -1341,5 +1342,6 @@ int main(int argc, char **argv)
 #include "DNA_rigidbody_types.h"
 #include "DNA_freestyle_types.h"
 #include "DNA_linestyle_types.h"
+#include "DNA_python_component_types.h"
 #include "DNA_cachefile_types.h"
 /* end of list */
diff --git a/source/blender/makesrna/RNA_access.h b/source/blender/makesrna/RNA_access.h
index f97a573..c4dcd3f 100644
--- a/source/blender/makesrna/RNA_access.h
+++ b/source/blender/makesrna/RNA_access.h
@@ -417,6 +417,7 @@ extern StructRNA RNA_Modifier;
 extern StructRNA RNA_MotionPath;
 extern StructRNA RNA_MotionPathVert;
 extern StructRNA RNA_MouseSensor;
+extern StructRNA RNA_MovementSensor;
 extern StructRNA RNA_MovieSequence;
 extern StructRNA RNA_MovieClipSequence;
 extern StructRNA RNA_MovieTracking;
@@ -485,6 +486,7 @@ extern StructRNA RNA_Property;
 extern StructRNA RNA_PropertyGroup;
 extern StructRNA RNA_PropertyGroupItem;
 extern StructRNA RNA_PropertySensor;
+extern StructRNA RNA_PythonComponent;
 extern StructRNA RNA_PythonConstraint;
 extern StructRNA RNA_PythonController;
 extern StructRNA RNA_QuickTimeSettings;
diff --git a/source/blender/makesrna/intern/CMakeLists.txt b/source/blender/makesrna/intern/CMakeLists.txt
index 0f3ea27..5624293 100644
--- a/source/blender/makesrna/intern/CMakeLists.txt
+++ b/source/blender/makesrna/intern/CMakeLists.txt
@@ -72,6 +72,7 @@ set(DEFSRC
 	rna_palette.c
 	rna_particle.c
 	rna_pose.c
+	rna_python_component.c
 	rna_property.c
 	rna_render.c
 	rna_rigidbody.c
diff --git a/source/blender/makesrna/intern/makesrna.c b/source/blender/makesrna/intern/makesrna.c
index 4552c77..11b99e2 100644
--- a/source/blender/makesrna/intern/makesrna.c
+++ b/source/blender/makesrna/intern/makesrna.c
@@ -3345,6 +3345,7 @@ static RNAProcessItem PROCESS_ITEMS[] = {
 	{"rna_palette.c", NULL, RNA_def_palette},
 	{"rna_particle.c", NULL, RNA_def_particle},
 	{"rna_pose.c", "rna_pose_api.c", RNA_def_pose},
+	{"rna_python_component.c", NULL, RNA_def_py_component},
 	{"rna_property.c", NULL, RNA_def_gameproperty},
 	{"rna_render.c", NULL, RNA_def_render},
 	{"rna_rigidbody.c", NULL, RNA_def_rigidbody},
diff --git a/source/blender/makesrna/intern/rna_actuator.c b/source/blender/makesrna/intern/rna_actuator.c
index a09853e..505d801 100644
--- a/source/blender/makesrna/intern/rna_actuator.c
+++ b/source/blender/makesrna/intern/rna_actuator.c
@@ -64,6 +64,7 @@ static EnumPropertyItem actuator_type_items[] = {
 	{ACT_SOUND, "SOUND", 0, "Sound", ""},
 	{ACT_STATE, "STATE", 0, "State", ""},
 	{ACT_STEERING, "STEERING", 0, "Steering", ""},
+	{ACT_VIBRATION, "VIBRATION", 0, "Vibration", ""},
 	{ACT_VISIBILITY, "VISIBILITY", 0, "Visibility", ""},
 	{0, NULL, 0, NULL, NULL}
 };
@@ -99,6 +100,8 @@ static StructRNA *rna_Actuator_refine(struct PointerRNA *ptr)
 			return &RNA_MessageActuator;
 		case ACT_GAME:
 			return &RNA_GameActuator;
+		case ACT_VIBRATION:
+			return &RNA_VibrationActuator;
 		case ACT_VISIBILITY:
 			return &RNA_VisibilityActuator;
 		case ACT_2DFILTER:
@@ -468,6 +471,7 @@ EnumPropertyItem *rna_Actuator_type_itemf(bContext *C, PointerRNA *ptr, Property
 
 	RNA_enum_items_add_value(&item, &totitem, actuator_type_items, ACT_SOUND);
 	RNA_enum_items_add_value(&item, &totitem, actuator_type_items, ACT_STATE);
+	RNA_enum_items_add_value(&item, &totitem, actuator_type_items, ACT_VIBRATION);
 	RNA_enum_items_add_value(&item, &totitem, actuator_type_items, ACT_VISIBILITY);
 	
 	RNA_enum_item_end(&item, &totitem);
@@ -1344,6 +1348,8 @@ static void rna_def_edit_object_actuator(BlenderRNA *brna)
 		{ACT_EDOB_ENABLE_RB, "ENABLERIGIDBODY", 0, "Enable Rigid Body", ""},
 		{ACT_EDOB_DISABLE_RB, "DISABLERIGIDBODY", 0, "Disable Rigid Body", ""},
 		{ACT_EDOB_SET_MASS, "SETMASS", 0, "Set Mass", ""},
+		{ACT_EDOB_RESTORE_PHY, "RESTOREPHY", 0, "Restore Physics", ""},
+		{ACT_EDOB_SUSPEND_PHY, "SUSPENDPHY", 0, "Suspend Physics", ""},
 		{0, NULL, 0, NULL, NULL}
 	};
 
@@ -1425,8 +1431,8 @@ static void rna_def_edit_object_actuator(BlenderRNA *brna)
 	RNA_def_property_pointer_funcs(prop, NULL, "rna_Actuator_editobject_mesh_set", NULL, NULL);
 	RNA_def_property_update(prop, NC_LOGIC, NULL);
 
-	prop = RNA_def_property(srna, "time", PROP_INT, PROP_NONE);
-	RNA_def_property_ui_range(prop, 0, 2000, 1, 1);
+	prop = RNA_def_property(srna, "time", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_ui_range(prop, 0.0f, FLT_MAX, 1, 2);
 	RNA_def_property_ui_text(prop, "Time", "Duration the new Object lives or the track takes");
 	RNA_def_property_update(prop, NC_LOGIC, NULL);
 
@@ -1729,6 +1735,52 @@ static void rna_def_game_actuator(BlenderRNA *brna)
 	/*XXX to do: an operator that calls file_browse with relative_path on and blender filtering active */
 }
 
+static void rna_def_vibration_actuator(BlenderRNA *brna)
+{
+	StructRNA *srna;
+	PropertyRNA *prop;
+
+	static EnumPropertyItem prop_mode_items[] = {
+		{ACT_VIBRATION_PLAY, "PLAY", 0, "Play", ""},
+		{ACT_VIBRATION_STOP, "STOP", 0, "Stop", ""},
+		{0, NULL, 0, NULL, NULL}
+	};
+
+	srna = RNA_def_struct(brna, "VibrationActuator", "Actuator");
+	RNA_def_struct_ui_text(srna, "Vibration Actuator", "Actuator to set vibration of a joystick");
+	RNA_def_struct_sdna_from(srna, "bVibrationActuator", "data");
+
+	prop = RNA_def_property(srna, "mode", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "mode");
+	RNA_def_property_enum_items(prop, prop_mode_items);
+	RNA_def_property_ui_text(prop, "Vibration Mode", "Joystick vibration mode");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	prop = RNA_def_property(srna, "joy_index", PROP_INT, PROP_NONE);
+	RNA_def_property_int_sdna(prop, NULL, "joyindex");
+	RNA_def_property_range(prop, 0, 7);
+	RNA_def_property_ui_text(prop, "JoyIndex", "Joystick index");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	prop = RNA_def_property(srna, "joy_duration", PROP_INT, PROP_NONE);
+	RNA_def_property_int_sdna(prop, NULL, "duration");
+	RNA_def_property_range(prop, 0, INT_MAX);
+	RNA_def_property_ui_text(prop, "Duration", "Joystick vibration duration");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	prop = RNA_def_property(srna, "joy_strength_left", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "strength");
+	RNA_def_property_range(prop, 0.0, 1.0);
+	RNA_def_property_ui_text(prop, "Strength Low Freq", "Joystick vibration strength for low frequency motor");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	prop = RNA_def_property(srna, "joy_strength_right", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "strength_right");
+	RNA_def_property_range(prop, 0.0, 1.0);
+	RNA_def_property_ui_text(prop, "Strength High Freq", "Joystick vibration strength for high frequency motor");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+}
+
 static void rna_def_visibility_actuator(BlenderRNA *brna)
 {
 	StructRNA *srna;
@@ -2207,6 +2259,7 @@ void RNA_def_actuator(BlenderRNA *brna)
 	rna_def_random_actuator(brna);
 	rna_def_message_actuator(brna);
 	rna_def_game_actuator(brna);
+	rna_def_vibration_actuator(brna);
 	rna_def_visibility_actuator(brna);
 	rna_def_twodfilter_actuator(brna);
 	rna_def_parent_actuator(brna);
diff --git a/source/blender/makesrna/intern/rna_camera.c b/source/blender/makesrna/intern/rna_camera.c
index 078ba13..17eef13 100644
--- a/source/blender/makesrna/intern/rna_camera.c
+++ b/source/blender/makesrna/intern/rna_camera.c
@@ -333,6 +333,11 @@ void RNA_def_camera(BlenderRNA *brna)
 	RNA_def_property_ui_text(prop, "Stereo", "");
 
 	/* flag */
+	prop = RNA_def_property(srna, "show_frustum", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "flag", CAM_SHOW_FRUSTUM);
+	RNA_def_property_ui_text(prop, "Show Frustum", "Show a visualization of frustum in Game Engine");
+	RNA_def_property_update(prop, NC_CAMERA, NULL);
+
 	prop = RNA_def_property(srna, "show_limits", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "flag", CAM_SHOWLIMITS);
 	RNA_def_property_ui_text(prop, "Show Limits", "Draw the clipping range and focus point on the camera");
diff --git a/source/blender/makesrna/intern/rna_internal.h b/source/blender/makesrna/intern/rna_internal.h
index 76455ad..f321a81 100644
--- a/source/blender/makesrna/intern/rna_internal.h
+++ b/source/blender/makesrna/intern/rna_internal.h
@@ -166,6 +166,7 @@ void RNA_def_packedfile(struct BlenderRNA *brna);
 void RNA_def_palette(struct BlenderRNA *brna);
 void RNA_def_particle(struct BlenderRNA *brna);
 void RNA_def_pose(struct BlenderRNA *brna);
+void RNA_def_py_component(struct BlenderRNA *brna);
 void RNA_def_render(struct BlenderRNA *brna);
 void RNA_def_rigidbody(struct BlenderRNA *brna);
 void RNA_def_rna(struct BlenderRNA *brna);
diff --git a/source/blender/makesrna/intern/rna_lamp.c b/source/blender/makesrna/intern/rna_lamp.c
index 51709d3..e41e2f5 100644
--- a/source/blender/makesrna/intern/rna_lamp.c
+++ b/source/blender/makesrna/intern/rna_lamp.c
@@ -223,6 +223,12 @@ static void rna_def_lamp_mtex(BlenderRNA *brna)
 	RNA_def_property_ui_range(prop, 0, 1, 10, 3);
 	RNA_def_property_ui_text(prop, "Shadow Factor", "Amount texture affects shadow");
 	RNA_def_property_update(prop, 0, "rna_Lamp_update");
+
+	prop = RNA_def_property(srna, "lod_bias", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "lodbias");
+	RNA_def_property_ui_range(prop, -FLT_MAX, FLT_MAX, 10, 3);
+	RNA_def_property_ui_text(prop, "Lod Bias", "Amount bias on mipmapping");
+	RNA_def_property_update(prop, 0, "rna_Lamp_update");
 }
 
 static void rna_def_lamp_sky_settings(BlenderRNA *brna)
@@ -539,6 +545,13 @@ static void rna_def_lamp_shadow(StructRNA *srna, int spot, int area)
 		{0, NULL, 0, NULL, NULL}
 	};
 
+	static EnumPropertyItem prop_shadow_filter_type_items[] = {
+		{LA_SHADOW_FILTER_NONE, "NONE", 0, "None", "None filtering"},
+		{LA_SHADOW_FILTER_PCF, "PCF", 0, "PCF", "Percentage Closer Filtering"},
+		{LA_SHADOW_FILTER_PCF_BAIL, "PCF_BAIL", 0, "PCF Early Bail", "Percentage Closer Filtering Early Bail"},
+		{0, NULL, 0, NULL, NULL}
+	};
+
 	prop = RNA_def_property(srna, "use_shadow", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_funcs(prop, "rna_use_shadow_get", "rna_use_shadow_set");
 	RNA_def_property_update(prop, 0, "rna_Lamp_draw_update");
@@ -557,6 +570,11 @@ static void rna_def_lamp_shadow(StructRNA *srna, int spot, int area)
 	RNA_def_property_int_funcs(prop, NULL, "rna_Lamp_buffer_size_set", NULL);
 	RNA_def_property_update(prop, 0, "rna_Lamp_update");
 
+	prop = RNA_def_property(srna, "static_shadow", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "mode", LA_STATIC_SHADOW);
+	RNA_def_property_ui_text(prop, "Static Shadow",
+	                         "Enable static shadows");
+
 	prop = RNA_def_property(srna, "shadow_filter_type", PROP_ENUM, PROP_NONE);
 	RNA_def_property_enum_sdna(prop, NULL, "filtertype");
 	RNA_def_property_enum_items(prop, prop_shadbuffiltertype_items);
@@ -602,6 +620,12 @@ static void rna_def_lamp_shadow(StructRNA *srna, int spot, int area)
 	RNA_def_property_ui_text(prop, "Shadow Buffer Soft", "Size of shadow buffer sampling area");
 	RNA_def_property_update(prop, 0, "rna_Lamp_update");
 
+	prop = RNA_def_property(srna, "shadow_buffer_sharp", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "bufsharp");
+	RNA_def_property_range(prop, -1.0f, 1.0f);
+	RNA_def_property_ui_text(prop, "Shadow Buffer Sharpness", "Sharpness of buffer sampling");
+	RNA_def_property_update(prop, 0, "rna_Lamp_update");
+
 	prop = RNA_def_property(srna, "shadow_buffer_samples", PROP_INT, PROP_NONE);
 	RNA_def_property_int_sdna(prop, NULL, "samp");
 	RNA_def_property_range(prop, 1, 16);
@@ -620,6 +644,11 @@ static void rna_def_lamp_shadow(StructRNA *srna, int spot, int area)
 	RNA_def_property_ui_text(prop, "Shadow Map Type", "The shadow mapping algorithm used");
 	RNA_def_property_update(prop, 0, "rna_Lamp_update");
 
+	prop = RNA_def_property(srna, "shadow_filter", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "shadow_filter");
+	RNA_def_property_enum_items(prop, prop_shadow_filter_type_items);
+	RNA_def_property_ui_text(prop, "Shadow Map Filter Type", "The shadow mapping filtering algorithm used");
+	RNA_def_property_update(prop, 0, "rna_Lamp_update");
 
 	prop = RNA_def_property(srna, "use_auto_clip_start", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "bufflag", LA_SHADBUF_AUTO_START);
diff --git a/source/blender/makesrna/intern/rna_material.c b/source/blender/makesrna/intern/rna_material.c
index b293f20..11caebf 100644
--- a/source/blender/makesrna/intern/rna_material.c
+++ b/source/blender/makesrna/intern/rna_material.c
@@ -148,11 +148,6 @@ static PointerRNA rna_Material_strand_get(PointerRNA *ptr)
 	return rna_pointer_inherit_refine(ptr, &RNA_MaterialStrand, ptr->id.data);
 }
 
-static PointerRNA rna_Material_physics_get(PointerRNA *ptr)
-{
-	return rna_pointer_inherit_refine(ptr, &RNA_MaterialPhysics, ptr->id.data);
-}
-
 static void rna_Material_type_set(PointerRNA *ptr, int value)
 {
 	Material *ma = (Material *)ptr->data;
@@ -550,6 +545,16 @@ static void rna_def_material_mtex(BlenderRNA *brna)
 	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_NORM);
 	RNA_def_property_ui_text(prop, "Normal", "The texture affects the rendered normal");
 	RNA_def_property_update(prop, 0, "rna_Material_update");
+
+	prop = RNA_def_property(srna, "use_map_parallax", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_PARALLAX);
+	RNA_def_property_ui_text(prop, "Parallax", "The texture affects the relief depth");
+	RNA_def_property_update(prop, 0, "rna_Material_update");
+
+	prop = RNA_def_property(srna, "use_parallax_uv", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "texflag", MTEX_PARALLAX_UV);
+	RNA_def_property_ui_text(prop, "Use Parallax UV", "This is necessary for proper use of the parallax mapping");
+	RNA_def_property_update(prop, 0, "rna_Material_update");
 	
 	prop = RNA_def_property(srna, "use_map_color_spec", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_COLSPEC);
@@ -658,6 +663,35 @@ static void rna_def_material_mtex(BlenderRNA *brna)
 	RNA_def_property_ui_text(prop, "Warp Factor", "Amount texture affects texture coordinates of next channels");
 	RNA_def_property_update(prop, 0, "rna_Material_update");
 
+	prop = RNA_def_property(srna, "parallax_uv_shift", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "parallaxuv");
+	RNA_def_property_ui_range(prop, 0.0, 2.0, 1.0, 3);
+	RNA_def_property_ui_text(prop, "UV Shift", "Amount texture is shifted");
+	RNA_def_property_update(prop, 0, "rna_Material_update");
+
+	prop = RNA_def_property(srna, "parallax_steps", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "parallaxsteps");
+	RNA_def_property_ui_range(prop, 0.0, 100.0, 1.0, 3);
+	RNA_def_property_ui_text(prop, "Parallax Steps", "Number of steps taken to achieve result");
+	RNA_def_property_update(prop, 0, "rna_Material_update");
+
+	prop = RNA_def_property(srna, "parallax_bump_scale", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "parallaxbumpsc");
+	RNA_def_property_ui_range(prop, 0.0, 0.5, 1.0, 3);
+	RNA_def_property_ui_text(prop, "Parallax Bump Scale", "Height of SPOM");
+	RNA_def_property_update(prop, 0, "rna_Material_update");
+
+	prop = RNA_def_property(srna, "parallax_uv_discard", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "parflag", MTEX_DISCARD_AT_EDGES);
+	RNA_def_property_ui_text(prop, "Parallax UV discard", "To discard parallax UV at edges");
+	RNA_def_property_update(prop, 0, "rna_Material_update");
+
+	prop = RNA_def_property(srna, "lod_bias", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "lodbias");
+	RNA_def_property_ui_range(prop, -FLT_MAX, FLT_MAX, 10, 3);
+	RNA_def_property_ui_text(prop, "Lod Bias", "Amount bias on mipmapping");
+	RNA_def_property_update(prop, 0, "rna_Material_update");
+
 	prop = RNA_def_property(srna, "specular_color_factor", PROP_FLOAT, PROP_NONE);
 	RNA_def_property_float_sdna(prop, NULL, "colspecfac");
 	RNA_def_property_ui_range(prop, 0, 1, 10, 3);
@@ -803,6 +837,20 @@ static void rna_def_material_mtex(BlenderRNA *brna)
 	RNA_def_property_ui_range(prop, 0, 1, 10, 3);
 	RNA_def_property_ui_text(prop, "Reflection Factor", "Amount texture affects brightness of out-scattered light");
 	RNA_def_property_update(prop, 0, "rna_Material_update");
+
+	prop = RNA_def_property(srna, "ior", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "ior");
+	RNA_def_property_range(prop, 1.0, 50.0);
+	RNA_def_property_ui_range(prop, 1.0, 50.0, 1, 2);
+	RNA_def_property_ui_text(prop, "Refraction Indice", "Indice of refraction");
+	RNA_def_property_update(prop, 0, "rna_Material_update");
+
+	prop = RNA_def_property(srna, "refraction_ratio", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "refrratio");
+	RNA_def_property_range(prop, 0.0, 1.0);
+	RNA_def_property_ui_range(prop, 0.0, 1.0, 1, 2);
+	RNA_def_property_ui_text(prop, "Refraction Ratio", "Amount refraction mixed with reflection");
+	RNA_def_property_update(prop, 0, "rna_Material_update");
 	
 	/* end volume material */
 	
@@ -849,7 +897,7 @@ static void rna_def_material_gamesettings(BlenderRNA *brna)
 		{GEMAT_SHADOW, "SHADOW", 0, "Shadow", "Faces are used for shadow"},
 		{0, NULL, 0, NULL, NULL}
 	};
-	
+
 	srna = RNA_def_struct(brna, "MaterialGameSettings", NULL);
 	RNA_def_struct_sdna(srna, "GameSettings");
 	RNA_def_struct_nested(brna, srna, "Material");
@@ -860,11 +908,6 @@ static void rna_def_material_gamesettings(BlenderRNA *brna)
 	RNA_def_property_ui_text(prop, "Backface Culling", "Hide Back of the face in Game Engine ");
 	RNA_def_property_update(prop, 0, "rna_Material_draw_update");
 
-	prop = RNA_def_property(srna, "text", PROP_BOOLEAN, PROP_NONE);
-	RNA_def_property_boolean_sdna(prop, NULL, "flag", GEMAT_TEXT); /* use bitflags */
-	RNA_def_property_ui_text(prop, "Text", "Use material as text in Game Engine ");
-	RNA_def_property_update(prop, 0, "rna_Material_draw_update");
-
 	prop = RNA_def_property(srna, "invisible", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "flag", GEMAT_INVISIBLE); /* use bitflags */
 	RNA_def_property_ui_text(prop, "Invisible", "Make face invisible");
@@ -881,8 +924,8 @@ static void rna_def_material_gamesettings(BlenderRNA *brna)
 	RNA_def_property_ui_text(prop, "Face Orientations", "Especial face orientation options");
 
 	prop = RNA_def_property(srna, "physics", PROP_BOOLEAN, PROP_NONE);
-	RNA_def_property_boolean_negative_sdna(prop, NULL, "flag", GEMAT_NOPHYSICS); /* use bitflags */
-	RNA_def_property_ui_text(prop, "Physics", "Use physics properties of materials ");
+	RNA_def_property_boolean_negative_sdna(prop, NULL, "flag", GEMAT_NOPHYSICS);
+	RNA_def_property_ui_text(prop, "Physics", "Use physics for this materials");
 }
 
 static void rna_def_material_colors(StructRNA *srna)
@@ -1722,50 +1765,6 @@ static void rna_def_material_strand(BlenderRNA *brna)
 	RNA_def_property_update(prop, 0, "rna_Material_update");
 }
 
-static void rna_def_material_physics(BlenderRNA *brna)
-{
-	StructRNA *srna;
-	PropertyRNA *prop;
-	
-	srna = RNA_def_struct(brna, "MaterialPhysics", NULL);
-	RNA_def_struct_sdna(srna, "Material");
-	RNA_def_struct_nested(brna, srna, "Material");
-	RNA_def_struct_ui_text(srna, "Material Physics", "Physics settings for a Material data-block");
-	
-	prop = RNA_def_property(srna, "friction", PROP_FLOAT, PROP_NONE);
-	RNA_def_property_float_sdna(prop, NULL, "friction");
-	RNA_def_property_range(prop, 0, 100);
-	RNA_def_property_ui_text(prop, "Friction", "Coulomb friction coefficient, when inside the physics distance area");
-
-	prop = RNA_def_property(srna, "elasticity", PROP_FLOAT, PROP_NONE);
-	RNA_def_property_float_sdna(prop, NULL, "reflect");
-	RNA_def_property_range(prop, 0, 1);
-	RNA_def_property_ui_text(prop, "Elasticity", "Elasticity of collisions");
-
-	/* FH/Force Field Settings */
-	prop = RNA_def_property(srna, "use_fh_normal", PROP_BOOLEAN, PROP_NONE);
-	RNA_def_property_boolean_sdna(prop, NULL, "dynamode", MA_FH_NOR);
-	RNA_def_property_ui_text(prop, "Align to Normal",
-	                         "Align dynamic game objects along the surface normal, "
-	                         "when inside the physics distance area");
-
-	prop = RNA_def_property(srna, "fh_force", PROP_FLOAT, PROP_NONE);
-	RNA_def_property_float_sdna(prop, NULL, "fh");
-	RNA_def_property_range(prop, 0, 1);
-	RNA_def_property_ui_range(prop, 0.0, 1.0, 10, 2);
-	RNA_def_property_ui_text(prop, "Force", "Upward spring force, when inside the physics distance area");
-	
-	prop = RNA_def_property(srna, "fh_distance", PROP_FLOAT, PROP_NONE);
-	RNA_def_property_float_sdna(prop, NULL, "fhdist");
-	RNA_def_property_range(prop, 0, 20);
-	RNA_def_property_ui_text(prop, "Distance", "Distance of the physics area");
-	
-	prop = RNA_def_property(srna, "fh_damping", PROP_FLOAT, PROP_NONE);
-	RNA_def_property_float_sdna(prop, NULL, "xyfrict");
-	RNA_def_property_range(prop, 0, 1);
-	RNA_def_property_ui_text(prop, "Damping", "Damping of the spring force, when inside the physics distance area");
-}
-
 void RNA_def_material(BlenderRNA *brna)
 {
 	StructRNA *srna;
@@ -1816,6 +1815,36 @@ void RNA_def_material(BlenderRNA *brna)
 	RNA_def_property_enum_funcs(prop, NULL, "rna_Material_type_set", NULL);
 	RNA_def_property_update(prop, 0, "rna_Material_draw_update");
 
+	prop = RNA_def_property(srna, "use_constant_material", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "constflag", MA_CONSTANT_MATERIAL);
+	RNA_def_property_ui_text(prop, "Material", "Use constant values for material");
+	RNA_def_property_update(prop, 0, "rna_Material_draw_update");
+
+	prop = RNA_def_property(srna, "use_constant_lamp", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "constflag", MA_CONSTANT_LAMP);
+	RNA_def_property_ui_text(prop, "Lamp", "Use constant values for lamps");
+	RNA_def_property_update(prop, 0, "rna_Material_draw_update");
+
+	prop = RNA_def_property(srna, "use_constant_texture", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "constflag", MA_CONSTANT_TEXTURE);
+	RNA_def_property_ui_text(prop, "Texture", "Use constant values for textures");
+	RNA_def_property_update(prop, 0, "rna_Material_draw_update");
+
+	prop = RNA_def_property(srna, "use_constant_texture_uv", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "constflag", MA_CONSTANT_TEXTURE_UV);
+	RNA_def_property_ui_text(prop, "Texture Uv", "Use constant values for textures uv transformation");
+	RNA_def_property_update(prop, 0, "rna_Material_draw_update");
+
+	prop = RNA_def_property(srna, "use_constant_world", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "constflag", MA_CONSTANT_WORLD);
+	RNA_def_property_ui_text(prop, "World", "Use constant values for world");
+	RNA_def_property_update(prop, 0, "rna_Material_draw_update");
+
+	prop = RNA_def_property(srna, "use_constant_mist", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "constflag", MA_CONSTANT_MIST);
+	RNA_def_property_ui_text(prop, "Mist", "Use constant values for mist");
+	RNA_def_property_update(prop, 0, "rna_Material_draw_update");
+
 	prop = RNA_def_property(srna, "use_transparency", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "mode", MA_TRANSP);
 	RNA_def_property_ui_text(prop, "Transparency", "Render material as transparent");
@@ -1826,7 +1855,19 @@ void RNA_def_material(BlenderRNA *brna)
 	RNA_def_property_enum_items(prop, transparency_items);
 	RNA_def_property_ui_text(prop, "Transparency Method", "Method to use for rendering transparency");
 	RNA_def_property_update(prop, 0, "rna_Material_update");
-	
+
+	/* For depth transparency */
+	prop = RNA_def_property(srna, "use_depth_transparency", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "mode2", MA_DEPTH_TRANSP);
+	RNA_def_property_ui_text(prop, "Depth Transparency", "Render material as transparent depending on the depth");
+	RNA_def_property_update(prop, 0, "rna_Material_draw_update");
+
+	prop = RNA_def_property(srna, "depth_transp_factor", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "depthtranspfactor");
+	RNA_def_property_range(prop, 0.001f, FLT_MAX);
+	RNA_def_property_ui_text(prop, "Depth Transparency Factor", "Amount of transparency depending on the depth");
+	RNA_def_property_update(prop, 0, "rna_Material_update");
+
 	/* For Preview Render */
 	prop = RNA_def_property(srna, "preview_render_type", PROP_ENUM, PROP_NONE);
 	RNA_def_property_enum_sdna(prop, NULL, "pr_type");
@@ -1862,6 +1903,10 @@ void RNA_def_material(BlenderRNA *brna)
 	RNA_def_property_ui_text(prop, "Object Color", "Modulate the result with a per-object color");
 	RNA_def_property_update(prop, 0, "rna_Material_draw_update");
 
+	prop = RNA_def_property(srna, "use_instancing", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "shade_flag", MA_INSTANCING);
+	RNA_def_property_ui_text(prop, "Geometry Instancing", "Use special vertex shader for instancing rendering in game engine");
+
 	prop = RNA_def_property(srna, "shadow_ray_bias", PROP_FLOAT, PROP_NONE);
 	RNA_def_property_float_sdna(prop, NULL, "sbias");
 	RNA_def_property_range(prop, 0, 0.25);
@@ -2073,12 +2118,6 @@ void RNA_def_material(BlenderRNA *brna)
 	RNA_def_property_struct_type(prop, "MaterialStrand");
 	RNA_def_property_pointer_funcs(prop, "rna_Material_strand_get", NULL, NULL, NULL);
 	RNA_def_property_ui_text(prop, "Strand", "Strand settings for the material");
-	
-	prop = RNA_def_property(srna, "physics", PROP_POINTER, PROP_NONE);
-	RNA_def_property_flag(prop, PROP_NEVER_NULL);
-	RNA_def_property_struct_type(prop, "MaterialPhysics");
-	RNA_def_property_pointer_funcs(prop, "rna_Material_physics_get", NULL, NULL, NULL);
-	RNA_def_property_ui_text(prop, "Physics", "Game physics settings");
 
 	/* game settings */
 	prop = RNA_def_property(srna, "game_settings", PROP_POINTER, PROP_NONE);
@@ -2134,7 +2173,6 @@ void RNA_def_material(BlenderRNA *brna)
 	rna_def_material_sss(brna);
 	rna_def_material_mtex(brna);
 	rna_def_material_strand(brna);
-	rna_def_material_physics(brna);
 	rna_def_material_gamesettings(brna);
 
 	RNA_api_material(srna);
diff --git a/source/blender/makesrna/intern/rna_object.c b/source/blender/makesrna/intern/rna_object.c
index 0cffba4..a8f591b 100644
--- a/source/blender/makesrna/intern/rna_object.c
+++ b/source/blender/makesrna/intern/rna_object.c
@@ -1668,6 +1668,11 @@ static void rna_def_object_game_settings(BlenderRNA *brna)
 	RNA_def_property_struct_type(prop, "GameProperty"); /* rna_property.c */
 	RNA_def_property_ui_text(prop, "Properties", "Game engine properties");
 
+	prop = RNA_def_property(srna, "components", PROP_COLLECTION, PROP_NONE);
+	RNA_def_property_collection_sdna(prop, NULL, "components", NULL);
+	RNA_def_property_struct_type(prop, "PythonComponent"); /* rna_python_component.c */
+	RNA_def_property_ui_text(prop, "Components", "Game engine components");
+
 	prop = RNA_def_property(srna, "show_sensors", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "scaflag", OB_SHOWSENS);
 	RNA_def_property_ui_text(prop, "Show Sensors", "Shows sensors for this object in the user interface");
@@ -1691,10 +1696,6 @@ static void rna_def_object_game_settings(BlenderRNA *brna)
 	RNA_def_property_ui_text(prop, "Physics Type", "Select the type of physical representation");
 	RNA_def_property_update(prop, NC_LOGIC, NULL);
 
-	prop = RNA_def_property(srna, "use_record_animation", PROP_BOOLEAN, PROP_NONE);
-	RNA_def_property_boolean_sdna(prop, NULL, "gameflag", OB_RECORD_ANIMATION);
-	RNA_def_property_ui_text(prop, "Record Animation", "Record animation objects without physics");
-
 	prop = RNA_def_property(srna, "use_actor", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "gameflag", OB_ACTOR);
 	RNA_def_property_ui_text(prop, "Actor", "Object is detected by the Near and Radar sensor");
@@ -1704,7 +1705,7 @@ static void rna_def_object_game_settings(BlenderRNA *brna)
 	RNA_def_property_ui_text(prop, "Ghost", "Object does not react to collisions, like a ghost");
 
 	prop = RNA_def_property(srna, "mass", PROP_FLOAT, PROP_NONE);
-	RNA_def_property_range(prop, 0.01, 10000.0);
+	RNA_def_property_range(prop, 0.01, 1000000.0);
 	RNA_def_property_float_default(prop, 1.0f);
 	RNA_def_property_ui_text(prop, "Mass", "Mass of the object");
 
@@ -1828,11 +1829,17 @@ static void rna_def_object_game_settings(BlenderRNA *brna)
 	prop = RNA_def_property(srna, "use_activity_culling", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_negative_sdna(prop, NULL, "gameflag2", OB_NEVER_DO_ACTIVITY_CULLING);
 	RNA_def_property_ui_text(prop, "Lock Z Rotation Axis", "Disable simulation of angular motion along the Z axis");
-	
 
-	prop = RNA_def_property(srna, "use_material_physics_fh", PROP_BOOLEAN, PROP_NONE);
+	prop = RNA_def_property(srna, "predefined_bound", PROP_POINTER, PROP_NONE);
+	RNA_def_property_struct_type(prop, "Mesh");
+	RNA_def_property_pointer_sdna(prop, NULL, "gamePredefinedBound");
+	RNA_def_property_flag(prop, PROP_EDITABLE);
+	RNA_def_property_ui_text(prop, "Predefined Bound", "Predefined mesh bounding volume used when Auto Update Bound is disable");
+
+
+	prop = RNA_def_property(srna, "use_physics_fh", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "gameflag", OB_DO_FH);
-	RNA_def_property_ui_text(prop, "Use Material Force Field", "React to force field physics settings in materials");
+	RNA_def_property_ui_text(prop, "Use Force Field", "React to force field physics settings");
 
 	prop = RNA_def_property(srna, "use_rotate_from_normal", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "gameflag", OB_ROT_FH);
@@ -1893,6 +1900,44 @@ static void rna_def_object_game_settings(BlenderRNA *brna)
 	RNA_def_property_range(prop, 0.0, 1000.0);
 	RNA_def_property_float_default(prop, 1.0f);
 	RNA_def_property_ui_text(prop, "Obstacle Radius", "Radius of object representation in obstacle simulation");
+
+	prop = RNA_def_property(srna, "friction", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "friction");
+	RNA_def_property_range(prop, 0, 100);
+	RNA_def_property_ui_text(prop, "Friction", "Coulomb friction coefficient, when inside the physics distance area");
+
+	prop = RNA_def_property(srna, "rolling_friction", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "rolling_friction");
+	RNA_def_property_range(prop, 0, 100);
+	RNA_def_property_ui_text(prop, "Rolling Friction", "Coulomb friction coefficient of rounded shapes");
+
+	prop = RNA_def_property(srna, "elasticity", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "reflect");
+	RNA_def_property_range(prop, 0, 1);
+	RNA_def_property_ui_text(prop, "Elasticity", "Elasticity of collisions");
+
+	/* FH/Force Field Settings */
+	prop = RNA_def_property(srna, "use_fh_normal", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "dynamode", OB_FH_NOR);
+	RNA_def_property_ui_text(prop, "Align to Normal",
+	                         "Align dynamic game objects along the surface normal, "
+	                         "when inside the physics distance area");
+
+	prop = RNA_def_property(srna, "fh_force", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "fh");
+	RNA_def_property_range(prop, 0, 1);
+	RNA_def_property_ui_range(prop, 0.0, 1.0, 10, 2);
+	RNA_def_property_ui_text(prop, "Force", "Upward spring force, when inside the physics distance area");
+	
+	prop = RNA_def_property(srna, "fh_distance", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "fhdist");
+	RNA_def_property_range(prop, 0, 20);
+	RNA_def_property_ui_text(prop, "Distance", "Distance of the physics area");
+	
+	prop = RNA_def_property(srna, "fh_damping", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "xyfrict");
+	RNA_def_property_range(prop, 0, 1);
+	RNA_def_property_ui_text(prop, "Damping", "Damping of the spring force, when inside the physics distance area");
 	
 	/* state */
 
diff --git a/source/blender/makesrna/intern/rna_property.c b/source/blender/makesrna/intern/rna_property.c
index 07bdbb0..c019d2a 100644
--- a/source/blender/makesrna/intern/rna_property.c
+++ b/source/blender/makesrna/intern/rna_property.c
@@ -86,7 +86,7 @@ static float rna_GameFloatProperty_value_get(PointerRNA *ptr)
 static void rna_GameFloatProperty_value_set(PointerRNA *ptr, float value)
 {
 	bProperty *prop = (bProperty *)(ptr->data);
-	CLAMP(value, -10000.0f, 10000.0f);
+	CLAMP(value, -FLT_MAX, FLT_MAX);
 	*(float *)(&prop->data) = value;
 }
 
@@ -159,7 +159,7 @@ void RNA_def_gameproperty(BlenderRNA *brna)
 	prop = RNA_def_property(srna, "value", PROP_INT, PROP_NONE);
 	RNA_def_property_int_sdna(prop, NULL, "data");
 	RNA_def_property_ui_text(prop, "Value", "Property value");
-	RNA_def_property_range(prop, -10000, 10000);
+	RNA_def_property_range(prop, -INT_MAX, INT_MAX);
 	RNA_def_property_update(prop, NC_LOGIC, NULL);
 
 	/* GameFloatProperty */
@@ -170,7 +170,7 @@ void RNA_def_gameproperty(BlenderRNA *brna)
 	prop = RNA_def_property(srna, "value", PROP_FLOAT, PROP_NONE);
 	/* RNA_def_property_float_sdna(prop, NULL, "data"); */
 	RNA_def_property_ui_text(prop, "Value", "Property value");
-	RNA_def_property_range(prop, -10000, 10000);
+	RNA_def_property_range(prop, -FLT_MAX, FLT_MAX);
 	RNA_def_property_float_funcs(prop, "rna_GameFloatProperty_value_get", "rna_GameFloatProperty_value_set", NULL);
 	RNA_def_property_update(prop, NC_LOGIC, NULL);
 
@@ -182,7 +182,7 @@ void RNA_def_gameproperty(BlenderRNA *brna)
 	prop = RNA_def_property(srna, "value", PROP_FLOAT, PROP_NONE);
 	/* RNA_def_property_float_sdna(prop, NULL, "data"); */
 	RNA_def_property_ui_text(prop, "Value", "Property value");
-	RNA_def_property_range(prop, -10000, 10000);
+	RNA_def_property_range(prop, -FLT_MAX, FLT_MAX);
 	RNA_def_property_float_funcs(prop, "rna_GameFloatProperty_value_get", "rna_GameFloatProperty_value_set", NULL);
 	RNA_def_property_update(prop, NC_LOGIC, NULL);
 
diff --git a/source/blender/makesrna/intern/rna_python_component.c b/source/blender/makesrna/intern/rna_python_component.c
new file mode 100644
index 0000000..de5fb27
--- /dev/null
+++ b/source/blender/makesrna/intern/rna_python_component.c
@@ -0,0 +1,236 @@
+/**
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contributor(s): Mitchell Stokes, Diego Lopes, Tristan Porteries.
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include <stdlib.h>
+
+#include "RNA_define.h"
+
+#include "rna_internal.h"
+#include "DNA_python_component_types.h"
+#include "DNA_property_types.h"
+
+#include "WM_types.h"
+
+#ifdef RNA_RUNTIME
+
+static StructRNA* rna_PythonComponentProperty_refine(struct PointerRNA *ptr)
+{
+	PythonComponentProperty *cprop = (PythonComponentProperty *)ptr->data;
+
+	switch(cprop->type) {
+		case CPROP_TYPE_BOOLEAN:
+			return &RNA_ComponentBooleanProperty;
+		case CPROP_TYPE_INT:
+			return &RNA_ComponentIntProperty;
+		case CPROP_TYPE_FLOAT:
+			return &RNA_ComponentFloatProperty;
+		case CPROP_TYPE_STRING:
+			return &RNA_ComponentStringProperty;
+		case CPROP_TYPE_SET:
+			return &RNA_ComponentSetProperty;
+		case CPROP_TYPE_VEC2:
+			return &RNA_ComponentVector2DProperty;
+		case CPROP_TYPE_VEC3:
+			return &RNA_ComponentVector3DProperty;
+		case CPROP_TYPE_VEC4:
+			return &RNA_ComponentVector4DProperty;
+		default:
+			return &RNA_PythonComponentProperty;
+	}
+}
+
+static int rna_ComponentSetProperty_get(struct PointerRNA *ptr)
+{
+	PythonComponentProperty *cprop = (PythonComponentProperty *)(ptr->data);
+	return cprop->itemval;
+}
+
+static void rna_ComponentSetProperty_set(struct PointerRNA *ptr, int value)
+{
+	PythonComponentProperty *cprop = (PythonComponentProperty *)(ptr->data);
+	cprop->itemval = value;
+}
+
+static EnumPropertyItem *rna_ComponentSetProperty_itemf(bContext *UNUSED(C), PointerRNA *ptr, PropertyRNA *UNUSED(prop), bool *r_free)
+{
+	PythonComponentProperty *cprop = (PythonComponentProperty *)(ptr->data);
+	EnumPropertyItem *items = NULL;
+	int totitem = 0;
+	int j = 0;
+
+	for (LinkData *link = cprop->enumval.first; link; link = link->next, ++j) {
+		EnumPropertyItem item = {0, "", 0, "", ""};
+		item.value = j;
+		item.identifier = link->data;
+		item.icon = 0;
+		item.name = link->data;
+		item.description = "";
+		RNA_enum_item_add(&items, &totitem, &item);
+	}
+
+	RNA_enum_item_end(&items, &totitem);
+	*r_free = true;
+
+	return items;
+}
+#else
+
+static void rna_def_py_component(BlenderRNA *brna)
+{
+	StructRNA *srna;
+	PropertyRNA *prop;
+
+	/* Python Component */
+	srna = RNA_def_struct(brna, "PythonComponent", NULL);
+	RNA_def_struct_sdna(srna, "PythonComponent");
+	RNA_def_struct_ui_text(srna, "Python Component", "");
+
+	prop = RNA_def_property(srna, "name", PROP_STRING, PROP_NONE);
+	RNA_def_property_string_sdna(prop, NULL, "name");
+	RNA_def_property_ui_text(prop, "Name", "");
+	RNA_def_struct_name_property(srna, prop);
+	RNA_def_property_clear_flag(prop, PROP_EDITABLE);
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	prop = RNA_def_property(srna, "properties", PROP_COLLECTION, PROP_NONE);
+	RNA_def_property_collection_sdna(prop, NULL, "properties", NULL);
+	RNA_def_property_struct_type(prop, "PythonComponentProperty");
+	RNA_def_property_ui_text(prop, "Properties", "Component properties");
+}
+
+static void rna_def_py_component_property(BlenderRNA *brna)
+{
+	StructRNA *srna;
+	PropertyRNA *prop;
+
+	static EnumPropertyItem empty_items[] = {
+		{0, "EMPTY", 0, "Empty", ""},
+		{0, NULL, 0, NULL, NULL}
+	};
+
+	/* Base Python Component Property */
+	srna = RNA_def_struct(brna, "PythonComponentProperty", NULL);
+	RNA_def_struct_sdna(srna, "PythonComponentProperty");
+	RNA_def_struct_ui_text(srna, "Python Component Property", "A property of a Python Component");
+	RNA_def_struct_refine_func(srna, "rna_PythonComponentProperty_refine");
+
+	prop = RNA_def_property(srna, "name", PROP_STRING, PROP_NONE);
+	RNA_def_property_string_sdna(prop, NULL, "name");
+	RNA_def_property_ui_text(prop, "Name", "");
+	RNA_def_struct_name_property(srna, prop);
+	RNA_def_property_clear_flag(prop, PROP_EDITABLE);
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	/* Boolean */
+	srna = RNA_def_struct(brna, "ComponentBooleanProperty", "PythonComponentProperty");
+	RNA_def_struct_sdna(srna, "PythonComponentProperty");
+	RNA_def_struct_ui_text(srna, "Python Component Boolean Property", "A boolean property of a Python Component");
+
+	prop = RNA_def_property(srna, "value", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "boolval", 1);
+	RNA_def_property_ui_text(prop, "Value", "Property value");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	/* Int */
+	srna = RNA_def_struct(brna, "ComponentIntProperty", "PythonComponentProperty");
+	RNA_def_struct_sdna(srna, "PythonComponentProperty");
+	RNA_def_struct_ui_text(srna, "Python Component Integer Property", "An integer property of a Python Component");
+
+	prop = RNA_def_property(srna, "value", PROP_INT, PROP_NONE);
+	RNA_def_property_int_sdna(prop, NULL, "intval");
+	RNA_def_property_ui_text(prop, "Value", "Property value");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	/* Float */
+	srna = RNA_def_struct(brna, "ComponentFloatProperty", "PythonComponentProperty");
+	RNA_def_struct_sdna(srna, "PythonComponentProperty");
+	RNA_def_struct_ui_text(srna, "Python Component Float Property", "A float property of a Python Component");
+
+	prop = RNA_def_property(srna, "value", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "floatval");
+	RNA_def_property_ui_text(prop, "Value", "Property value");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	/* String */
+	srna = RNA_def_struct(brna, "ComponentStringProperty", "PythonComponentProperty");
+	RNA_def_struct_sdna(srna, "PythonComponentProperty");
+	RNA_def_struct_ui_text(srna, "Python Component String Property", "A string property of a Python Component");
+
+	prop = RNA_def_property(srna, "value", PROP_STRING, PROP_NONE);
+	RNA_def_property_string_sdna(prop, NULL, "strval");
+	RNA_def_property_string_maxlength(prop, MAX_PROPSTRING);
+	RNA_def_property_ui_text(prop, "Value", "Property value");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	/* Set */
+	srna = RNA_def_struct(brna, "ComponentSetProperty", "PythonComponentProperty");
+	RNA_def_struct_sdna(srna, "PythonComponentProperty");
+	RNA_def_struct_ui_text(srna, "Python Component Set Property", "A set property of a Python Component");
+
+	prop = RNA_def_property(srna, "value", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_items(prop, empty_items);
+	RNA_def_property_enum_funcs(prop, "rna_ComponentSetProperty_get", "rna_ComponentSetProperty_set", "rna_ComponentSetProperty_itemf");
+	RNA_def_property_enum_default(prop, 0);
+	RNA_def_property_ui_text(prop, "Value", "Property value");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	/* Vector 2D */
+	srna = RNA_def_struct(brna, "ComponentVector2DProperty", "PythonComponentProperty");
+	RNA_def_struct_sdna(srna, "PythonComponentProperty");
+	RNA_def_struct_ui_text(srna, "Python Component Vector 2D Property", "A 2D vector property of a Python Component");
+
+	prop = RNA_def_property(srna, "value", PROP_FLOAT, PROP_COORDS);
+	RNA_def_property_float_sdna(prop, NULL, "vec");
+	RNA_def_property_array(prop, 2);
+	RNA_def_property_ui_text(prop, "Value", "Property value");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	/* Vector 3D */
+	srna = RNA_def_struct(brna, "ComponentVector3DProperty", "PythonComponentProperty");
+	RNA_def_struct_sdna(srna, "PythonComponentProperty");
+	RNA_def_struct_ui_text(srna, "Python Component Vector 3D Property", "A 3D vector property of a Python Component");
+
+	prop = RNA_def_property(srna, "value", PROP_FLOAT, PROP_COORDS);
+	RNA_def_property_float_sdna(prop, NULL, "vec");
+	RNA_def_property_array(prop, 3);
+	RNA_def_property_ui_text(prop, "Value", "Property value");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	/* Vector 4D */
+	srna = RNA_def_struct(brna, "ComponentVector4DProperty", "PythonComponentProperty");
+	RNA_def_struct_sdna(srna, "PythonComponentProperty");
+	RNA_def_struct_ui_text(srna, "Python Component Vector 4D Property", "A 4D vector property of a Python Component");
+
+	prop = RNA_def_property(srna, "value", PROP_FLOAT, PROP_COORDS);
+	RNA_def_property_float_sdna(prop, NULL, "vec");
+	RNA_def_property_array(prop, 4);
+	RNA_def_property_ui_text(prop, "Value", "Property value");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+}
+
+void RNA_def_py_component(BlenderRNA *brna)
+{
+	rna_def_py_component(brna);
+	rna_def_py_component_property(brna);
+}
+
+#endif /* RNA_RUNTIME */
diff --git a/source/blender/makesrna/intern/rna_scene.c b/source/blender/makesrna/intern/rna_scene.c
index ddfb5dc..672baf7 100644
--- a/source/blender/makesrna/intern/rna_scene.c
+++ b/source/blender/makesrna/intern/rna_scene.c
@@ -28,6 +28,7 @@
 
 #include "DNA_brush_types.h"
 #include "DNA_group_types.h"
+#include "DNA_material_types.h"
 #include "DNA_modifier_types.h"
 #include "DNA_particle_types.h"
 #include "DNA_rigidbody_types.h"
@@ -40,6 +41,7 @@
 #include "IMB_imbuf_types.h"
 
 #include "BLI_math.h"
+#include "BLI_string.h"
 
 #include "BLT_translation.h"
 
@@ -1817,6 +1819,54 @@ static void rna_GameSettings_exit_key_set(PointerRNA *ptr, int value)
 		gm->exitkey = value;
 }
 
+static void rna_GameSettings_python_key1_set(PointerRNA *ptr, int value)
+{
+	GameData *gm = (GameData *)ptr->data;
+
+	if (ISKEYBOARD(value)) {
+		gm->pythonkeys[0] = value;
+	}
+	else {
+		gm->pythonkeys[0] = EVENT_NONE;
+	}
+}
+
+static void rna_GameSettings_python_key2_set(PointerRNA *ptr, int value)
+{
+	GameData *gm = (GameData *)ptr->data;
+
+	if (ISKEYBOARD(value)) {
+		gm->pythonkeys[1] = value;
+	}
+	else {
+		gm->pythonkeys[1] = EVENT_NONE;
+	}
+}
+
+static void rna_GameSettings_python_key3_set(PointerRNA *ptr, int value)
+{
+	GameData *gm = (GameData *)ptr->data;
+
+	if (ISKEYBOARD(value)) {
+		gm->pythonkeys[2] = value;
+	}
+	else {
+		gm->pythonkeys[2] = EVENT_NONE;
+	}
+}
+
+static void rna_GameSettings_python_key4_set(PointerRNA *ptr, int value)
+{
+	GameData *gm = (GameData *)ptr->data;
+
+	if (ISKEYBOARD(value)) {
+		gm->pythonkeys[3] = value;
+	}
+	else {
+		gm->pythonkeys[3] = EVENT_NONE;
+	}
+}
+
 static TimeMarker *rna_TimeLine_add(Scene *scene, const char name[], int frame)
 {
 	TimeMarker *marker = MEM_callocN(sizeof(TimeMarker), "TimeMarker");
@@ -2206,7 +2256,7 @@ static void rna_def_gpencil_brush(BlenderRNA *brna)
 	RNA_def_property_range(prop, -M_PI_2, M_PI_2);
 	RNA_def_property_ui_text(prop, "Angle",
 	                         "Direction of the stroke at which brush gives maximal thickness "
-	                         "(0 for horizontal)");
+	                         "(0?? for horizontal)");
 	RNA_def_property_update(prop, NC_GPENCIL | ND_DATA, NULL);
 
 	/* Factor to change brush size depending of angle */
@@ -4318,6 +4368,13 @@ static void rna_def_scene_game_data(BlenderRNA *brna)
 		{0, NULL, 0, NULL, NULL}
 	};
 
+	static EnumPropertyItem hdr_items[] = {
+		{GAME_HDR_NONE, "HDR_NONE", 0, "None", "8 bits per channel"},
+		{GAME_HDR_HALF_FLOAT, "HDR_HALF_FLOAT", 0, "Half", "16 bits per channel"},
+		{GAME_HDR_FULL_FLOAT, "HDR_FULL_FLOAT", 0, "Full", "32 bits per channel"},
+		{0, NULL, 0, NULL, NULL}
+	};
+
 	static EnumPropertyItem framing_types_items[] = {
 		{SCE_GAMEFRAMING_BARS, "LETTERBOX", 0, "Letterbox",
 		                       "Show the entire viewport in the display window, using bar horizontally or vertically"},
@@ -4328,15 +4385,6 @@ static void rna_def_scene_game_data(BlenderRNA *brna)
 		{0, NULL, 0, NULL, NULL}
 	};
 
-	static EnumPropertyItem dome_modes_items[] = {
-		{DOME_FISHEYE, "FISHEYE", 0, "Fisheye", ""},
-		{DOME_TRUNCATED_FRONT, "TRUNCATED_FRONT", 0, "Front-Truncated", ""},
-		{DOME_TRUNCATED_REAR, "TRUNCATED_REAR", 0, "Rear-Truncated", ""},
-		{DOME_ENVMAP, "ENVMAP", 0, "Cube Map", ""},
-		{DOME_PANORAM_SPH, "PANORAM_SPH", 0, "Spherical Panoramic", ""},
-		{0, NULL, 0, NULL, NULL}
-	};
-		
 	static EnumPropertyItem stereo_modes_items[] = {
 		{STEREO_QUADBUFFERED, "QUADBUFFERED", 0, "Quad-Buffer", ""},
 		{STEREO_ABOVEBELOW, "ABOVEBELOW", 0, "Above-Below", ""},
@@ -4351,7 +4399,6 @@ static void rna_def_scene_game_data(BlenderRNA *brna)
 	static EnumPropertyItem stereo_items[] = {
 		{STEREO_NOSTEREO, "NONE", 0, "None", "Disable Stereo and Dome environments"},
 		{STEREO_ENABLED, "STEREO", 0, "Stereo", "Enable Stereo environment"},
-		{STEREO_DOME, "DOME", 0, "Dome", "Enable Dome environment"},
 		{0, NULL, 0, NULL, NULL}
 	};
 
@@ -4361,12 +4408,6 @@ static void rna_def_scene_game_data(BlenderRNA *brna)
 		{0, NULL, 0, NULL, NULL}
 	};
 
-	static EnumPropertyItem material_items[] = {
-		{GAME_MAT_MULTITEX, "MULTITEXTURE", 0, "Multitexture", "Multitexture materials"},
-		{GAME_MAT_GLSL, "GLSL", 0, "GLSL", "OpenGL shading language shaders"},
-		{0, NULL, 0, NULL, NULL}
-	};
-
 	static EnumPropertyItem obstacle_simulation_items[] = {
 		{OBSTSIMULATION_NONE, "NONE", 0, "None", ""},
 		{OBSTSIMULATION_TOI_rays, "RVO_RAYS", 0, "RVO (rays)", ""},
@@ -4381,13 +4422,6 @@ static void rna_def_scene_game_data(BlenderRNA *brna)
 		{0, NULL, 0, NULL, NULL}
 	};
 
-	static EnumPropertyItem storage_items[] = {
-		{RAS_STORE_AUTO, "AUTO", 0, "Auto Select", "Choose the best supported mode"},
-		{RAS_STORE_VA, "VERTEX_ARRAY", 0, "Vertex Arrays", "Usually the best choice (good performance with display lists)"},
-		{RAS_STORE_VBO, "VERTEX_BUFFER_OBJECT", 0, "Vertex Buffer Objects",
-		                "Typically slower than vertex arrays with display lists, requires at least OpenGL 1.4"},
-		{0, NULL, 0, NULL, NULL}};
-
 	srna = RNA_def_struct(brna, "SceneGameData", NULL);
 	RNA_def_struct_sdna(srna, "GameData");
 	RNA_def_struct_nested(brna, srna, "Scene");
@@ -4416,7 +4450,12 @@ static void rna_def_scene_game_data(BlenderRNA *brna)
 	RNA_def_property_enum_sdna(prop, NULL, "aasamples");
 	RNA_def_property_enum_items(prop, aasamples_items);
 	RNA_def_property_ui_text(prop, "AA Samples", "The number of AA Samples to use for MSAA");
-	
+
+	prop = RNA_def_property(srna, "hdr", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "hdr");
+	RNA_def_property_enum_items(prop, hdr_items);
+	RNA_def_property_ui_text(prop, "HDR", "The precision of screen display");
+
 	prop = RNA_def_property(srna, "depth", PROP_INT, PROP_UNSIGNED);
 	RNA_def_property_int_sdna(prop, NULL, "depth");
 	RNA_def_property_range(prop, 8, 32);
@@ -4432,13 +4471,7 @@ static void rna_def_scene_game_data(BlenderRNA *brna)
 	RNA_def_property_enum_funcs(prop, NULL, "rna_GameSettings_exit_key_set", NULL);
 	RNA_def_property_ui_text(prop, "Exit Key", "The key that exits the Game Engine");
 	RNA_def_property_update(prop, NC_SCENE, NULL);
-	
-	prop = RNA_def_property(srna, "raster_storage", PROP_ENUM, PROP_NONE);
-	RNA_def_property_enum_sdna(prop, NULL, "raster_storage");
-	RNA_def_property_enum_items(prop, storage_items);
-	RNA_def_property_ui_text(prop, "Storage", "Set the storage mode used by the rasterizer");
-	RNA_def_property_update(prop, NC_SCENE, NULL);
-	
+
 	/* Do we need it here ? (since we already have it in World */
 	prop = RNA_def_property(srna, "frequency", PROP_INT, PROP_NONE);
 	RNA_def_property_int_sdna(prop, NULL, "freqplay");
@@ -4492,48 +4525,7 @@ static void rna_def_scene_game_data(BlenderRNA *brna)
 	RNA_def_property_ui_text(prop, "Eye Separation",
 	                         "Set the distance between the eyes - the camera focal distance/30 should be fine");
 	RNA_def_property_update(prop, NC_SCENE, NULL);
-	
-	/* Dome */
-	prop = RNA_def_property(srna, "dome_mode", PROP_ENUM, PROP_NONE);
-	RNA_def_property_enum_sdna(prop, NULL, "dome.mode");
-	RNA_def_property_enum_items(prop, dome_modes_items);
-	RNA_def_property_ui_text(prop, "Dome Mode", "Dome physical configurations");
-	RNA_def_property_update(prop, NC_SCENE, NULL);
-	
-	prop = RNA_def_property(srna, "dome_tessellation", PROP_INT, PROP_NONE);
-	RNA_def_property_int_sdna(prop, NULL, "dome.res");
-	RNA_def_property_ui_range(prop, 1, 8, 1, 1);
-	RNA_def_property_int_default(prop, 4);
-	RNA_def_property_ui_text(prop, "Tessellation", "Tessellation level - check the generated mesh in wireframe mode");
-	RNA_def_property_update(prop, NC_SCENE, NULL);
-	
-	prop = RNA_def_property(srna, "dome_buffer_resolution", PROP_FLOAT, PROP_NONE);
-	RNA_def_property_float_sdna(prop, NULL, "dome.resbuf");
-	RNA_def_property_ui_range(prop, 0.1, 1.0, 0.1, 2);
-	RNA_def_property_float_default(prop, 1.0f);
-	RNA_def_property_ui_text(prop, "Buffer Resolution", "Buffer Resolution - decrease it to increase speed");
-	RNA_def_property_update(prop, NC_SCENE, NULL);
-	
-	prop = RNA_def_property(srna, "dome_angle", PROP_INT, PROP_NONE);
-	RNA_def_property_int_sdna(prop, NULL, "dome.angle");
-	RNA_def_property_ui_range(prop, 90, 250, 1, 1);
-	RNA_def_property_int_default(prop, 180);
-	RNA_def_property_ui_text(prop, "Angle", "Field of View of the Dome - it only works in mode Fisheye and Truncated");
-	RNA_def_property_update(prop, NC_SCENE, NULL);
-	
-	prop = RNA_def_property(srna, "dome_tilt", PROP_INT, PROP_NONE);
-	RNA_def_property_int_sdna(prop, NULL, "dome.tilt");
-	RNA_def_property_ui_range(prop, -180, 180, 1, 1);
-	RNA_def_property_ui_text(prop, "Tilt", "Camera rotation in horizontal axis");
-	RNA_def_property_update(prop, NC_SCENE, NULL);
-	
-	prop = RNA_def_property(srna, "dome_text", PROP_POINTER, PROP_NONE);
-	RNA_def_property_pointer_sdna(prop, NULL, "dome.warptext");
-	RNA_def_property_struct_type(prop, "Text");
-	RNA_def_property_flag(prop, PROP_EDITABLE);
-	RNA_def_property_ui_text(prop, "Warp Data", "Custom Warp Mesh data file");
-	RNA_def_property_update(prop, NC_SCENE, NULL);
-	
+
 	/* physics */
 	prop = RNA_def_property(srna, "physics_engine", PROP_ENUM, PROP_NONE);
 	RNA_def_property_enum_sdna(prop, NULL, "physicsEngine");
@@ -4673,20 +4665,11 @@ static void rna_def_scene_game_data(BlenderRNA *brna)
 	                         "Respect the frame rate from the Physics panel in the world properties "
 	                         "rather than rendering as many frames as possible");
 
-	prop = RNA_def_property(srna, "use_display_lists", PROP_BOOLEAN, PROP_NONE);
-	RNA_def_property_boolean_sdna(prop, NULL, "flag", GAME_DISPLAY_LISTS);
-	RNA_def_property_ui_text(prop, "Display Lists",
-	                         "Use display lists to speed up rendering by keeping geometry on the GPU");
-
 	prop = RNA_def_property(srna, "use_deprecation_warnings", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_negative_sdna(prop, NULL, "flag", GAME_IGNORE_DEPRECATION_WARNINGS);
 	RNA_def_property_ui_text(prop, "Deprecation Warnings",
 	                         "Print warnings when using deprecated features in the python API");
 
-	prop = RNA_def_property(srna, "use_animation_record", PROP_BOOLEAN, PROP_NONE);
-	RNA_def_property_boolean_sdna(prop, NULL, "flag", GAME_ENABLE_ANIMATION_RECORD);
-	RNA_def_property_ui_text(prop, "Record Animation", "Record animation to F-Curves");
-
 	prop = RNA_def_property(srna, "use_auto_start", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_funcs(prop, "rna_GameSettings_auto_start_get", "rna_GameSettings_auto_start_set");
 	RNA_def_property_ui_text(prop, "Auto Start", "Automatically start game at load time");
@@ -4696,14 +4679,52 @@ static void rna_def_scene_game_data(BlenderRNA *brna)
 	RNA_def_property_ui_text(prop, "Restrict Animation Updates",
 	                         "Restrict the number of animation updates to the animation FPS (this is "
 	                         "better for performance, but can cause issues with smooth playback)");
-	
-	/* materials */
-	prop = RNA_def_property(srna, "material_mode", PROP_ENUM, PROP_NONE);
-	RNA_def_property_enum_sdna(prop, NULL, "matmode");
-	RNA_def_property_enum_items(prop, material_items);
-	RNA_def_property_ui_text(prop, "Material Mode", "Material mode to use for rendering");
-	RNA_def_property_update(prop, NC_SCENE | NA_EDITED, NULL);
 
+	prop = RNA_def_property(srna, "show_bounding_box", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "flag", GAME_SHOW_BOUNDING_BOX);
+	RNA_def_property_ui_text(prop, "Show Bounding Box", "Show a visualization of bounding volume box");
+
+	prop = RNA_def_property(srna, "show_armatures", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "flag", GAME_SHOW_ARMATURES);
+	RNA_def_property_ui_text(prop, "Show Armatures", "Show a visualization of armatures");
+
+	prop = RNA_def_property(srna, "use_python_console", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "flag", GAME_PYTHON_CONSOLE);
+	RNA_def_property_ui_text(prop, "Python Console", "Create a python interpreter console in game");
+
+	prop = RNA_def_property(srna, "python_console_key1", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "pythonkeys[0]");
+	RNA_def_property_enum_items(prop, rna_enum_event_type_items);
+	RNA_def_property_enum_funcs(prop, NULL, "rna_GameSettings_python_key1_set", NULL);
+	RNA_def_property_enum_default(prop, LEFTCTRLKEY);
+	RNA_def_property_translation_context(prop, BLT_I18NCONTEXT_UI_EVENTS);
+	RNA_def_property_ui_text(prop, "Python Console Key", "First python console shortcut key");
+
+	prop = RNA_def_property(srna, "python_console_key2", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "pythonkeys[1]");
+	RNA_def_property_enum_items(prop, rna_enum_event_type_items);
+	RNA_def_property_enum_funcs(prop, NULL, "rna_GameSettings_python_key2_set", NULL);
+	RNA_def_property_enum_default(prop, LEFTSHIFTKEY);
+	RNA_def_property_translation_context(prop, BLT_I18NCONTEXT_UI_EVENTS);
+	RNA_def_property_ui_text(prop, "Python Console Key", "Second python console shortcut key");
+
+	prop = RNA_def_property(srna, "python_console_key3", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "pythonkeys[2]");
+	RNA_def_property_enum_items(prop, rna_enum_event_type_items);
+	RNA_def_property_enum_funcs(prop, NULL, "rna_GameSettings_python_key3_set", NULL);
+	RNA_def_property_enum_default(prop, LEFTALTKEY);
+	RNA_def_property_translation_context(prop, BLT_I18NCONTEXT_UI_EVENTS);
+	RNA_def_property_ui_text(prop, "Python Console Key", "Third python console shortcut key");
+
+	prop = RNA_def_property(srna, "python_console_key4", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "pythonkeys[3]");
+	RNA_def_property_enum_items(prop, rna_enum_event_type_items);
+	RNA_def_property_enum_funcs(prop, NULL, "rna_GameSettings_python_key4_set", NULL);
+	RNA_def_property_enum_default(prop, TKEY);
+	RNA_def_property_translation_context(prop, BLT_I18NCONTEXT_UI_EVENTS);
+	RNA_def_property_ui_text(prop, "Python Console Key", "Fourth python console shortcut key");
+
+	/* materials */
 	prop = RNA_def_property(srna, "use_glsl_lights", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_negative_sdna(prop, NULL, "flag", GAME_GLSL_NO_LIGHTS);
 	RNA_def_property_ui_text(prop, "GLSL Lights", "Use lights for GLSL rendering");
@@ -4745,12 +4766,6 @@ static void rna_def_scene_game_data(BlenderRNA *brna)
 	RNA_def_property_ui_text(prop, "GLSL Environment Lighting", "Use environment lighting for GLSL rendering");
 	RNA_def_property_update(prop, NC_SCENE | NA_EDITED, "rna_Scene_glsl_update");
 
-	prop = RNA_def_property(srna, "use_material_caching", PROP_BOOLEAN, PROP_NONE);
-	RNA_def_property_boolean_negative_sdna(prop, NULL, "flag", GAME_NO_MATERIAL_CACHING);
-	RNA_def_property_ui_text(prop, "Use Material Caching",
-	                         "Cache materials in the converter (this is faster, but can cause problems with older "
-	                         "Singletexture and Multitexture games)");
-
 	/* obstacle simulation */
 	prop = RNA_def_property(srna, "obstacle_simulation", PROP_ENUM, PROP_NONE);
 	RNA_def_property_enum_sdna(prop, NULL, "obstacleSimulation");
diff --git a/source/blender/makesrna/intern/rna_sensor.c b/source/blender/makesrna/intern/rna_sensor.c
index ee24a43..8a547b2 100644
--- a/source/blender/makesrna/intern/rna_sensor.c
+++ b/source/blender/makesrna/intern/rna_sensor.c
@@ -57,6 +57,7 @@ static EnumPropertyItem sensor_type_items[] = {
 	{SENS_NEAR, "NEAR", 0, "Near", ""},
 	{SENS_PROPERTY, "PROPERTY", 0, "Property", ""},
 	{SENS_RADAR, "RADAR", 0, "Radar", ""},
+	{SENS_MOVEMENT, "MOVEMENT", 0, "Movement", ""},
 	{SENS_RANDOM, "RANDOM", 0, "Random", ""},
 	{SENS_RAY, "RAY", 0, "Ray", ""},
 	{0, NULL, 0, NULL, NULL}
@@ -92,6 +93,8 @@ static StructRNA *rna_Sensor_refine(struct PointerRNA *ptr)
 			return &RNA_RandomSensor;
 		case SENS_RAY:
 			return &RNA_RaySensor;
+		case SENS_MOVEMENT:
+			return &RNA_MovementSensor;
 		case SENS_MESSAGE:
 			return &RNA_MessageSensor;
 		case SENS_JOYSTICK:
@@ -164,6 +167,7 @@ EnumPropertyItem *rna_Sensor_type_itemf(bContext *C, PointerRNA *ptr, PropertyRN
 	RNA_enum_items_add_value(&item, &totitem, sensor_type_items, SENS_KEYBOARD);
 	RNA_enum_items_add_value(&item, &totitem, sensor_type_items, SENS_MESSAGE);
 	RNA_enum_items_add_value(&item, &totitem, sensor_type_items, SENS_MOUSE);
+	RNA_enum_items_add_value(&item, &totitem, sensor_type_items, SENS_MOVEMENT);
 	RNA_enum_items_add_value(&item, &totitem, sensor_type_items, SENS_NEAR);
 	RNA_enum_items_add_value(&item, &totitem, sensor_type_items, SENS_PROPERTY);
 	RNA_enum_items_add_value(&item, &totitem, sensor_type_items, SENS_RADAR);
@@ -793,6 +797,52 @@ static void rna_def_ray_sensor(BlenderRNA *brna)
 	RNA_def_property_enum_items(prop, axis_items);
 	RNA_def_property_ui_text(prop, "Axis", "Along which axis the ray is cast");
 	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	prop = RNA_def_property(srna, "mask", PROP_BOOLEAN, PROP_LAYER_MEMBER);
+	RNA_def_property_boolean_sdna(prop, NULL, "mask", 1);
+	RNA_def_property_array(prop, OB_MAX_COL_MASKS);
+	RNA_def_property_ui_text(prop, "Mask", "Mask filter compared with object's collision group");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+}
+
+static void rna_def_movement_sensor(BlenderRNA *brna)
+{
+	StructRNA *srna;
+	PropertyRNA *prop;
+	static EnumPropertyItem axis_items[] = {
+		{ SENS_MOVEMENT_X_AXIS, "XAXIS", 0, "+X axis", "" },
+		{ SENS_MOVEMENT_Y_AXIS, "YAXIS", 0, "+Y axis", "" },
+		{ SENS_MOVEMENT_Z_AXIS, "ZAXIS", 0, "+Z axis", "" },
+		{ SENS_MOVEMENT_NEG_X_AXIS, "NEGXAXIS", 0, "-X axis", "" },
+		{ SENS_MOVEMENT_NEG_Y_AXIS, "NEGYAXIS", 0, "-Y axis", "" },
+		{ SENS_MOVEMENT_NEG_Z_AXIS, "NEGZAXIS", 0, "-Z axis", "" },
+		{ SENS_MOVEMENT_ALL_AXIS, "ALLAXIS", 0, "All axis", "" },
+		{ 0, NULL, 0, NULL, NULL }
+	};
+
+	srna = RNA_def_struct(brna, "MovementSensor", "Sensor");
+	RNA_def_struct_ui_text(srna, "Movement Sensor", "Sensor to detect if the owner has moved");
+	RNA_def_struct_sdna_from(srna, "bMovementSensor", "data");
+
+	prop = RNA_def_property(srna, "axis", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "axisflag");
+	RNA_def_property_enum_items(prop, axis_items);
+	RNA_def_property_ui_text(prop, "Axis", "Along which axis movement has to be detected");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	prop = RNA_def_property(srna, "use_local", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "localflag", SENS_MOVEMENT_LOCAL);
+	RNA_def_property_ui_text(prop, "Local",
+		"Toggle beetween local/global coordinates");
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
+
+	prop = RNA_def_property(srna, "threshold", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "threshold");
+	RNA_def_property_float_default(prop, 0.01f);
+	RNA_def_property_ui_text(prop, "Threshold", "Set Threshold");
+	RNA_def_property_range(prop, 0.001f, 10000.0f);
+	RNA_def_property_ui_range(prop, 0.001, 10000.0, 0.1, 3);
+	RNA_def_property_update(prop, NC_LOGIC, NULL);
 }
 
 static void rna_def_message_sensor(BlenderRNA *brna)
@@ -817,31 +867,57 @@ static void rna_def_joystick_sensor(BlenderRNA *brna)
 	PropertyRNA *prop;
 
 	static EnumPropertyItem event_type_joystick_items[] = {
-		{SENS_JOY_BUTTON, "BUTTON", 0, "Button", ""},
-		{SENS_JOY_AXIS, "AXIS", 0, "Axis", ""},
-		{SENS_JOY_HAT, "HAT", 0, "Hat", ""},
-		{SENS_JOY_AXIS_SINGLE, "AXIS_SINGLE", 0, "Single Axis", ""},
+		{SENS_JOY_AXIS, "STICK_DIRECTIONS", 0, "Stick Directions", ""},
+		{SENS_JOY_AXIS_SINGLE, "STICK_AXIS", 0, "Stick Axis", ""},
+		{SENS_JOY_SHOULDER_TRIGGER, "SHOULDER_TRIGGERS", 0, "Shoulder Triggers", ""},
+		{SENS_JOY_BUTTON, "BUTTONS", 0, "Buttons", ""},
+		{0, NULL, 0, NULL, NULL}
+	};
+
+	static EnumPropertyItem axis_items[] = {
+		{SENS_JOY_LEFT_STICK, "LEFT_STICK", 0, "Left Stick", ""},
+		{SENS_JOY_RIGHT_STICK, "RIGHT_STICK", 0, "Right Stick", ""},
 		{0, NULL, 0, NULL, NULL}
 	};
 
 	static EnumPropertyItem axis_direction_items[] = {
-		{SENS_JOY_X_AXIS, "RIGHTAXIS", 0, "Right Axis", ""},
-		{SENS_JOY_Y_AXIS, "UPAXIS", 0, "Up Axis", ""},
-		{SENS_JOY_NEG_X_AXIS, "LEFTAXIS", 0, "Left Axis", ""},
-		{SENS_JOY_NEG_Y_AXIS, "DOWNAXIS", 0, "Down Axis", ""},
+		{SENS_JOY_X_AXIS, "RIGHTAXIS", 0, "Right", ""},
+		{SENS_JOY_Y_AXIS, "UPAXIS", 0, "Up", ""},
+		{SENS_JOY_NEG_X_AXIS, "LEFTAXIS", 0, "Left", ""},
+		{SENS_JOY_NEG_Y_AXIS, "DOWNAXIS", 0, "Down", ""},
+		{0, NULL, 0, NULL, NULL}
+	};
+
+	static EnumPropertyItem axis_trigger_items[] = {
+		{SENS_JOY_LEFT_SHOULDER_TRIGGER, "LEFT_SHOULDER_TRIGGER", 0, "Left Shoulder Trigger", ""},
+		{SENS_JOY_RIGHT_SHOULDER_TRIGGER, "RIGHT_SHOULDER_TRIGGER", 0, "Right Shoulder Trigger", ""},
 		{0, NULL, 0, NULL, NULL}
 	};
 
-	static EnumPropertyItem hat_direction_items[] = {
-		{SENS_JOY_HAT_UP, "UP", 0, "Up", ""},
-		{SENS_JOY_HAT_DOWN, "DOWN", 0, "Down", ""},
-		{SENS_JOY_HAT_LEFT, "LEFT", 0, "Left", ""},
-		{SENS_JOY_HAT_RIGHT, "RIGHT", 0, "Right", ""},
+	static EnumPropertyItem axis_single_items[] = {
+		{SENS_JOY_LEFT_STICK_HORIZONTAL, "LEFT_STICK_HORIZONTAL", 0, "Left Stick Horizontal", ""},
+		{SENS_JOY_LEFT_STICK_VERTICAL, "LEFT_STICK_VERTICAL", 0, "Left Stick Vertical", ""},
+		{SENS_JOY_RIGHT_STICK_HORIZONTAL, "RIGHT_STICK_HORIZONTAL", 0, "Right Stick Horizontal", ""},
+		{SENS_JOY_RIGHT_STICK_VERTICAL, "RIGHT_STICK_VERTICAL", 0, "Right Stick Vertical", ""},
+		{0, NULL, 0, NULL, NULL}
+	};
 
-		{SENS_JOY_HAT_UP_RIGHT, "UPRIGHT", 0, "Up/Right", ""},
-		{SENS_JOY_HAT_DOWN_LEFT, "DOWNLEFT", 0, "Down/Left", ""},
-		{SENS_JOY_HAT_UP_LEFT, "UPLEFT", 0, "Up/Left", ""},
-		{SENS_JOY_HAT_DOWN_RIGHT, "DOWNRIGHT", 0, "Down/Right", ""},
+	static EnumPropertyItem button_items[] = {
+		{SENS_JOY_BUTTON_A, "BUTTON_A", 0, "A", ""},
+		{SENS_JOY_BUTTON_B, "BUTTON_B", 0, "B", ""},
+		{SENS_JOY_BUTTON_X, "BUTTON_X", 0, "X", ""},
+		{SENS_JOY_BUTTON_Y, "BUTTON_Y", 0, "Y", ""},
+		{SENS_JOY_BUTTON_BACK, "BUTTON_BACK", 0, "Back", ""},
+		{SENS_JOY_BUTTON_GUIDE, "BUTTON_GUIDE", 0, "Guide", ""},
+		{SENS_JOY_BUTTON_START, "BUTTON_START", 0, "Start", ""},
+		{SENS_JOY_BUTTON_STICK_LEFT, "BUTTON_STICK_LEFT", 0, "Left Stick", ""},
+		{SENS_JOY_BUTTON_STICK_RIGHT, "BUTTON_STICK_RIGHT", 0, "Right Stick", ""},
+		{SENS_JOY_BUTTON_SHOULDER_LEFT, "BUTTON_SHOULDER_LEFT", 0, "Left Shoulder", ""},
+		{SENS_JOY_BUTTON_SHOULDER_RIGHT, "BUTTON_SHOULDER_RIGHT", 0, "Right Shoulder", ""},
+		{SENS_JOY_BUTTON_DPAD_UP, "BUTTON_DPAD_UP", 0, "Dpad Up", ""},
+		{SENS_JOY_BUTTON_DPAD_DOWN, "BUTTON_DPAD_DOWN", 0, "Dpad Down", ""},
+		{SENS_JOY_BUTTON_DPAD_LEFT, "BUTTON_DPAD_LEFT", 0, "Dpad Left", ""},
+		{SENS_JOY_BUTTON_DPAD_RIGHT, "BUTTON_DPAD_RIGHT", 0, "Dpad Right", ""},
 		{0, NULL, 0, NULL, NULL}
 	};
 
@@ -851,7 +927,7 @@ static void rna_def_joystick_sensor(BlenderRNA *brna)
 	
 	prop = RNA_def_property(srna, "joystick_index", PROP_INT, PROP_NONE);
 	RNA_def_property_int_sdna(prop, NULL, "joyindex");
-	RNA_def_property_ui_text(prop, "Index", "Which joystick to use");
+	RNA_def_property_ui_text(prop, "Joystick Index", "Which joystick to use");
 	RNA_def_property_range(prop, 0, SENS_JOY_MAXINDEX - 1);
 	RNA_def_property_update(prop, NC_LOGIC, NULL);
 
@@ -865,53 +941,48 @@ static void rna_def_joystick_sensor(BlenderRNA *brna)
 	prop = RNA_def_property(srna, "use_all_events", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "flag", SENS_JOY_ANY_EVENT);
 	RNA_def_property_ui_text(prop, "All Events",
-	                         "Triggered by all events on this joystick's current type (axis/button/hat)");
+							 "Triggered by all events on this joystick's current type (axis/button)");
 	RNA_def_property_update(prop, NC_LOGIC, NULL);
 
 	/* Button */
-	prop = RNA_def_property(srna, "button_number", PROP_INT, PROP_NONE);
-	RNA_def_property_int_sdna(prop, NULL, "button");
-	RNA_def_property_ui_text(prop, "Button Number", "Which button to use");
-	RNA_def_property_range(prop, 0, 18);
+	prop = RNA_def_property(srna, "button_number", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "button");
+	RNA_def_property_enum_items(prop, button_items);
+	RNA_def_property_ui_text(prop, "Button", "Which button to use");
 	RNA_def_property_update(prop, NC_LOGIC, NULL);
 
 	/* Axis */
-	prop = RNA_def_property(srna, "axis_number", PROP_INT, PROP_NONE);
-	RNA_def_property_int_sdna(prop, NULL, "axis");
-	RNA_def_property_ui_text(prop, "Axis Number", "Which axis pair to use, 1 is usually the main direction input");
-	RNA_def_property_range(prop, 1, 8);
-	RNA_def_property_update(prop, NC_LOGIC, NULL);
-
-	prop = RNA_def_property(srna, "axis_threshold", PROP_INT, PROP_NONE);
-	RNA_def_property_int_sdna(prop, NULL, "precision");
-	RNA_def_property_ui_text(prop, "Axis Threshold", "Precision of the axis");
-	RNA_def_property_range(prop, 0, 32768);
+	prop = RNA_def_property(srna, "axis_number", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "axis");
+	RNA_def_property_enum_items(prop, axis_items);
+	RNA_def_property_ui_text(prop, "Stick", "Which Stick to use");
 	RNA_def_property_update(prop, NC_LOGIC, NULL);
 
 	prop = RNA_def_property(srna, "axis_direction", PROP_ENUM, PROP_NONE);
 	RNA_def_property_enum_sdna(prop, NULL, "axisf");
 	RNA_def_property_enum_items(prop, axis_direction_items);
-	RNA_def_property_ui_text(prop, "Axis Direction", "The direction of the axis");
+	RNA_def_property_ui_text(prop, "Stick Direction", "The direction of the stick");
 	RNA_def_property_update(prop, NC_LOGIC, NULL);
 
-	/* Single Axis */
-	prop = RNA_def_property(srna, "single_axis_number", PROP_INT, PROP_NONE);
-	RNA_def_property_int_sdna(prop, NULL, "axis_single");
-	RNA_def_property_ui_text(prop, "Axis Number", "Single axis (vertical/horizontal/other) to detect");
-	RNA_def_property_range(prop, 1, 16);
+	/* Triggers */
+	prop = RNA_def_property(srna, "axis_trigger_number", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "axis_single");
+	RNA_def_property_enum_items(prop, axis_trigger_items);
+	RNA_def_property_ui_text(prop, "Triggers", "Which trigger to detect");
 	RNA_def_property_update(prop, NC_LOGIC, NULL);
 
-	/* Hat */
-	prop = RNA_def_property(srna, "hat_number", PROP_INT, PROP_NONE);
-	RNA_def_property_int_sdna(prop, NULL, "hat");
-	RNA_def_property_ui_text(prop, "Hat Number", "Which hat to use");
-	RNA_def_property_range(prop, 1, 2);
+	/* Single Axis */
+	prop = RNA_def_property(srna, "single_axis_number", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "axis_single");
+	RNA_def_property_enum_items(prop, axis_single_items);
+	RNA_def_property_ui_text(prop, "Stick Axis", "Which stick single axis (vertical/horizontal/other) to detect");
 	RNA_def_property_update(prop, NC_LOGIC, NULL);
 
-	prop = RNA_def_property(srna, "hat_direction", PROP_ENUM, PROP_NONE);
-	RNA_def_property_enum_sdna(prop, NULL, "hatf");
-	RNA_def_property_enum_items(prop, hat_direction_items);
-	RNA_def_property_ui_text(prop, "Hat Direction", "Hat direction");
+	/* Common */
+	prop = RNA_def_property(srna, "axis_threshold", PROP_INT, PROP_NONE);
+	RNA_def_property_int_sdna(prop, NULL, "precision");
+	RNA_def_property_ui_text(prop, "Threshold", "Threshold minimum to detect the stick/trigger");
+	RNA_def_property_range(prop, 0, 32768);
 	RNA_def_property_update(prop, NC_LOGIC, NULL);
 }
 
@@ -931,6 +1002,7 @@ void RNA_def_sensor(BlenderRNA *brna)
 	rna_def_radar_sensor(brna);
 	rna_def_random_sensor(brna);
 	rna_def_ray_sensor(brna);
+	rna_def_movement_sensor(brna);
 	rna_def_message_sensor(brna);
 	rna_def_joystick_sensor(brna);
 }
diff --git a/source/blender/makesrna/intern/rna_space.c b/source/blender/makesrna/intern/rna_space.c
index 5e364a3..ef7eec9 100644
--- a/source/blender/makesrna/intern/rna_space.c
+++ b/source/blender/makesrna/intern/rna_space.c
@@ -4448,6 +4448,11 @@ static void rna_def_space_logic(BlenderRNA *brna)
 	RNA_def_struct_sdna(srna, "SpaceLogic");
 	RNA_def_struct_ui_text(srna, "Space Logic Editor", "Logic editor space data");
 
+	/* Properties */
+	prop = RNA_def_property(srna, "import_string", PROP_STRING, PROP_NONE);
+	RNA_def_property_string_sdna(prop, NULL, "import_string");
+	RNA_def_property_ui_text(prop, "Import String", "Import string used to find the component when adding a new component");
+
 	/* sensors */
 	prop = RNA_def_property(srna, "show_sensors_selected_objects", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "scaflag", BUTS_SENS_SEL);
diff --git a/source/blender/makesrna/intern/rna_texture.c b/source/blender/makesrna/intern/rna_texture.c
index 1e88585..986463e 100644
--- a/source/blender/makesrna/intern/rna_texture.c
+++ b/source/blender/makesrna/intern/rna_texture.c
@@ -670,6 +670,11 @@ static void rna_def_mtex(BlenderRNA *brna)
 	RNA_def_property_ui_text(prop, "Size", "Set scaling for the texture's X, Y and Z sizes");
 	RNA_def_property_update(prop, 0, "rna_TextureSlot_update");
 
+	prop = RNA_def_property(srna, "rotation", PROP_FLOAT, PROP_EULER);
+	RNA_def_property_float_sdna(prop, NULL, "rot");
+	RNA_def_property_ui_text(prop, "Rotation", "Set rotation for the texture");
+	RNA_def_property_update(prop, 0, "rna_TextureSlot_update");
+
 	prop = RNA_def_property(srna, "color", PROP_FLOAT, PROP_COLOR);
 	RNA_def_property_float_sdna(prop, NULL, "r");
 	RNA_def_property_array(prop, 3);
@@ -772,6 +777,7 @@ static void rna_def_environment_map(BlenderRNA *brna)
 		{ENV_STATIC, "STATIC", 0, "Static", "Calculate environment map only once"},
 		{ENV_ANIM, "ANIMATED", 0, "Animated", "Calculate environment map at each rendering"},
 		{ENV_LOAD, "IMAGE_FILE", 0, "Image File", "Load a saved environment map image from disk"},
+		{ENV_REALT, "REALTIME", 0, "Realtime", "Image generated for realtime reflections in the game engine"},
 		{0, NULL, 0, NULL, NULL}
 	};
 	
@@ -781,6 +787,13 @@ static void rna_def_environment_map(BlenderRNA *brna)
 		{0, NULL, 0, NULL, NULL}
 	};
 
+	static EnumPropertyItem prop_filtering_items[] = {
+		{ENVMAP_MIPMAP_NONE, "NONE", 0, "None", "None texture filtering"},
+		{ENVMAP_MIPMAP_LINEAR, "LINEAR", 0, "Linear Filtering", "Linear texture filtering"},
+		{ENVMAP_MIPMAP_MIPMAP, "MIPMAP", 0, "Mipmap Filtering", "Mipmap texture filtering"},
+		{0, NULL, 0, NULL, NULL}
+	};
+
 	srna = RNA_def_struct(brna, "EnvironmentMap", NULL);
 	RNA_def_struct_sdna(srna, "EnvMap");
 	RNA_def_struct_ui_text(srna, "EnvironmentMap",
@@ -848,6 +861,15 @@ static void rna_def_environment_map(BlenderRNA *brna)
 	RNA_def_property_clear_flag(prop, PROP_EDITABLE);
 	RNA_def_property_ui_text(prop, "Validity", "True if this map is ready for use, False if it needs rendering");
 
+	prop = RNA_def_property(srna, "auto_update", PROP_BOOLEAN, 0);
+	RNA_def_property_boolean_sdna(prop, NULL, "flag", ENVMAP_AUTO_UPDATE);
+	RNA_def_property_ui_text(prop, "Auto Update", "True if the cube map is updated every frame");
+
+	prop = RNA_def_property(srna, "filtering", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "filtering");
+	RNA_def_property_enum_items(prop, prop_filtering_items);
+	RNA_def_property_ui_text(prop, "Filtering", "Texture filtering method");
+
 	RNA_api_environment_map(srna);
 }
 
diff --git a/source/blender/makesrna/intern/rna_world.c b/source/blender/makesrna/intern/rna_world.c
index 7c1ef6b..984aad3 100644
--- a/source/blender/makesrna/intern/rna_world.c
+++ b/source/blender/makesrna/intern/rna_world.c
@@ -164,6 +164,12 @@ static void rna_def_world_mtex(BlenderRNA *brna)
 	RNA_def_property_ui_text(prop, "Zenith Down", "Affect the color of the zenith below");
 	RNA_def_property_update(prop, 0, "rna_World_update");
 
+	prop = RNA_def_property(srna, "lod_bias", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "lodbias");
+	RNA_def_property_ui_range(prop, -FLT_MAX, FLT_MAX, 10, 3);
+	RNA_def_property_ui_text(prop, "Lod Bias", "Amount bias on mipmapping");
+	RNA_def_property_update(prop, 0, "rna_World_update");
+
 	prop = RNA_def_property(srna, "texture_coords", PROP_ENUM, PROP_NONE);
 	RNA_def_property_enum_sdna(prop, NULL, "texco");
 	RNA_def_property_enum_items(prop, texco_items);
diff --git a/source/blender/python/intern/bpy.c b/source/blender/python/intern/bpy.c
index 5bbfb49..180dc59 100644
--- a/source/blender/python/intern/bpy.c
+++ b/source/blender/python/intern/bpy.c
@@ -362,4 +362,10 @@ void BPy_init_modules(void)
 
 	/* add our own modules dir, this is a python package */
 	bpy_package_py = bpy_import_test("bpy");
+	bpy_sys_module_backup = PyDict_Copy(PyImport_GetModuleDict());
+}
+
+void BPy_end_modules(void)
+{
+	Py_DECREF(bpy_sys_module_backup);
 }
diff --git a/source/blender/python/intern/bpy.h b/source/blender/python/intern/bpy.h
index b647d0d..3906030 100644
--- a/source/blender/python/intern/bpy.h
+++ b/source/blender/python/intern/bpy.h
@@ -27,7 +27,9 @@
 #define __BPY_H__
 
 void BPy_init_modules(void);
+void BPy_end_modules(void);
 extern PyObject *bpy_package_py;
+PyObject *bpy_sys_module_backup;
 
 /* bpy_interface_atexit.c */
 void BPY_atexit_register(void);
diff --git a/source/blender/python/intern/bpy_interface.c b/source/blender/python/intern/bpy_interface.c
index 311f621..36ad4dd 100644
--- a/source/blender/python/intern/bpy_interface.c
+++ b/source/blender/python/intern/bpy_interface.c
@@ -353,6 +353,9 @@ void BPY_python_end(void)
 	/* bpy.app modules that need cleanup */
 	BPY_app_translations_end();
 
+	/* Release copy of clear sys modules dictionary */
+	BPy_end_modules();
+
 #ifndef WITH_PYTHON_MODULE
 	BPY_atexit_unregister(); /* without this we get recursive calls to WM_exit */
 
diff --git a/source/blender/python/intern/gpu.c b/source/blender/python/intern/gpu.c
index 50dd461..9455133 100644
--- a/source/blender/python/intern/gpu.c
+++ b/source/blender/python/intern/gpu.c
@@ -108,12 +108,12 @@ static PyObject *PyInit_gpu(void)
 	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_LAMP_DYNPERSMAT);
 	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_LAMP_DYNENERGY);
 	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_LAMP_DYNCOL);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_LAMP_DYNSPOTSCALE);
 	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_LAMP_ATT1);
 	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_LAMP_ATT2);
 	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_LAMP_DISTANCE);
 	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_LAMP_SPOTSIZE);
 	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_LAMP_SPOTBLEND);
-	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_LAMP_SPOTSCALE);
 	/* GPU_DYNAMIC_GROUP_SAMPLER */
 	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_SAMPLER_2DBUFFER);
 	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_SAMPLER_2DIMAGE);
@@ -138,6 +138,25 @@ static PyObject *PyInit_gpu(void)
 	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_MAT_EMIT);
 	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_MAT_AMB);
 	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_MAT_ALPHA);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_MAT_MIR);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_MAT_SPECTRA);
+	/* GPU_DYNAMIC_GROUP_TEX */
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_COLINTENS);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_COLFAC);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_ALPHA);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_SPECINTENS);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_SPECFAC);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_HARDNESS);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_EMIT);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_MIRROR);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_NORMAL);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_PARALLAXBUMP);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_PARALLAXSTEP);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_IOR);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_REFRRATIO);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_UVOFFSET);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_UVSIZE);
+	PY_MODULE_ADD_CONSTANT(m, GPU_DYNAMIC_TEX_UVROTATION);
 
 
 	/* -------------------------------------------------------------------- */
diff --git a/source/blender/python/intern/gpu_offscreen.c b/source/blender/python/intern/gpu_offscreen.c
index c4863b2..c5e4b83 100644
--- a/source/blender/python/intern/gpu_offscreen.c
+++ b/source/blender/python/intern/gpu_offscreen.c
@@ -376,7 +376,7 @@ static PyObject *pygpu_offscreen_new(PyObject *UNUSED(self), PyObject *args, PyO
 		return NULL;
 	}
 
-	ofs = GPU_offscreen_create(width, height, samples, err_out);
+	ofs = GPU_offscreen_create(width, height, samples, GPU_OFFSCREEN_DEPTH_COMPARE, GPU_HDR_NONE, err_out);
 
 	if (ofs == NULL) {
 		PyErr_Format(PyExc_RuntimeError,
diff --git a/source/blender/windowmanager/CMakeLists.txt b/source/blender/windowmanager/CMakeLists.txt
index b6245a8..f1ecd20 100644
--- a/source/blender/windowmanager/CMakeLists.txt
+++ b/source/blender/windowmanager/CMakeLists.txt
@@ -38,7 +38,7 @@ set(INC
 	../makesrna
 	../nodes
 	../render/extern/include
-	../../gameengine/BlenderRoutines
+	../../gameengine/Launcher
 	../../../intern/ghost
 	../../../intern/guardedalloc
 	../../../intern/glew-mx
diff --git a/source/blender/windowmanager/intern/wm_init_exit.c b/source/blender/windowmanager/intern/wm_init_exit.c
index c11c398..f1e3ce1 100644
--- a/source/blender/windowmanager/intern/wm_init_exit.c
+++ b/source/blender/windowmanager/intern/wm_init_exit.c
@@ -84,7 +84,7 @@
 #endif
 
 #ifdef WITH_GAMEENGINE
-#  include "BL_System.h"
+#  include "LA_SystemCommandLine.h"
 #endif
 #include "GHOST_Path-api.h"
 #include "GHOST_C-api.h"
diff --git a/source/blender/windowmanager/intern/wm_window.c b/source/blender/windowmanager/intern/wm_window.c
index 2d43c47..3e92d31 100644
--- a/source/blender/windowmanager/intern/wm_window.c
+++ b/source/blender/windowmanager/intern/wm_window.c
@@ -1341,6 +1341,13 @@ void wm_window_testbreak(void)
 	}
 }
 
+void wm_window_set_order(wmWindow *win, int order)
+{
+	if (win->ghostwin) {
+		GHOST_SetWindowOrder(win->ghostwin, (order == 0) ? GHOST_kWindowOrderBottom : GHOST_kWindowOrderTop);
+	}
+}
+
 /* **************** init ********************** */
 
 void wm_ghost_init(bContext *C)
diff --git a/source/blender/windowmanager/wm_window.h b/source/blender/windowmanager/wm_window.h
index c106f9d..0917360 100644
--- a/source/blender/windowmanager/wm_window.h
+++ b/source/blender/windowmanager/wm_window.h
@@ -71,6 +71,8 @@ void		wm_cursor_position_to_ghost		(wmWindow *win, int *x, int *y);
 
 void		wm_window_testbreak		(void);
 
+void wm_window_set_order(wmWindow *win, int order);
+
 #ifdef WITH_INPUT_IME
 void		wm_window_IME_begin	(wmWindow *win, int x, int y, int w, int h, bool complete);
 void		wm_window_IME_end	(wmWindow *win);
diff --git a/source/blenderplayer/CMakeLists.txt b/source/blenderplayer/CMakeLists.txt
index 58bebc6..9f734ce 100644
--- a/source/blenderplayer/CMakeLists.txt
+++ b/source/blenderplayer/CMakeLists.txt
@@ -97,8 +97,7 @@ add_dependencies(blenderplayer makesdna)
 get_property(BLENDER_LINK_LIBS GLOBAL PROPERTY BLENDER_LINK_LIBS)
 
 list(APPEND BLENDER_LINK_LIBS
-	ge_player_common
-	ge_player_ghost
+	ge_player
 	blenkernel_blc
 )
 
@@ -109,8 +108,7 @@ endif()
 # if(UNIX)
 	# Sort libraries
 	set(BLENDER_SORTED_LIBS
-		ge_player_ghost 
-		ge_player_common 
+		ge_player 
 		bf_intern_string 
 		bf_intern_ghost
 		bf_rna
@@ -121,14 +119,18 @@ endif()
 		bf_blenloader
 		ge_blen_routines
 		bf_editor_datafiles
+		ge_launcher
+		ge_player
 		ge_converter 
 		ge_logic_ketsji 
 		ge_phys_bullet 
 		ge_phys_dummy
-		ge_logic 
-		ge_rasterizer 
-		ge_oglrasterizer 
-		ge_logic_expressions 
+		ge_logic
+		ge_device
+		ge_oglrasterizer
+		ge_rasterizer
+		ge_logic_expressions
+		ge_common
 		ge_scenegraph
 		bf_ikplugin
 		bf_intern_itasc
@@ -141,8 +143,6 @@ endif()
 		bf_imbuf
 		bf_avi 
 		ge_logic_network 
-		ge_logic_ngnetwork 
-		ge_logic_loopbacknetwork 
 		extern_bullet 
 		bf_intern_guardedalloc 
 		bf_intern_memutil 
diff --git a/source/creator/CMakeLists.txt b/source/creator/CMakeLists.txt
index eea4554..2abf08d 100644
--- a/source/creator/CMakeLists.txt
+++ b/source/creator/CMakeLists.txt
@@ -76,7 +76,7 @@ if(WITH_HEADLESS)
 endif()
 
 if(WITH_GAMEENGINE)
-	blender_include_dirs(../gameengine/BlenderRoutines)
+	blender_include_dirs(../gameengine/Launcher)
 
 	add_definitions(-DWITH_GAMEENGINE)
 endif()
diff --git a/source/creator/creator.c b/source/creator/creator.c
index a59a45f..545327c 100644
--- a/source/creator/creator.c
+++ b/source/creator/creator.c
@@ -84,7 +84,7 @@
 
 /* for passing information between creator and gameengine */
 #ifdef WITH_GAMEENGINE
-#  include "BL_System.h"
+#  include "LA_SystemCommandLine.h"
 #else /* dummy */
 #  define SYS_SystemHandle int
 #endif
diff --git a/source/creator/creator_args.c b/source/creator/creator_args.c
index 4eb72fb..8b46529 100644
--- a/source/creator/creator_args.c
+++ b/source/creator/creator_args.c
@@ -78,7 +78,7 @@
 
 /* for passing information between creator and gameengine */
 #ifdef WITH_GAMEENGINE
-#  include "BL_System.h"
+#  include "LA_SystemCommandLine.h"
 #else /* dummy */
 #  define SYS_SystemHandle int
 #endif
diff --git a/source/creator/creator_signals.c b/source/creator/creator_signals.c
index 80aba76..b97a52a 100644
--- a/source/creator/creator_signals.c
+++ b/source/creator/creator_signals.c
@@ -66,7 +66,7 @@
 
 /* for passing information between creator and gameengine */
 #ifdef WITH_GAMEENGINE
-#  include "BL_System.h"
+#  include "LA_SystemCommandLine.h"
 #else /* dummy */
 #  define SYS_SystemHandle int
 #endif
@@ -325,4 +325,4 @@ void main_signal_setup_fpe(void)
 #endif
 }
 
-#endif  /* WITH_PYTHON_MODULE */
\ No newline at end of file
+#endif  /* WITH_PYTHON_MODULE */
